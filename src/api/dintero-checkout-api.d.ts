/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/sessions-profile": {
    /**
     * Create a corresponding Checkout Session for an order placed in your system
     * using predefined session profile
     *
     * #### Session with Instabank
     *
     * Note that `items` is a required property when creating a session with
     * Instabank configured.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["checkout_session_profile_post"];
  };
  "/sessions": {
    /**
     * List all Checkout sessions
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["checkout_sessions_get"];
    /**
     * Create a corresponding Checkout Session for an order placed in your system
     *
     * #### Session with Instabank
     *
     * Note that `items` is a required property when creating a session with
     * Instabank configured.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["checkout_session_post"];
  };
  "/sessions/{session_id}": {
    /**
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["checkout_session_get"];
    /**
     * Session must be locked for paying before updating.
     *
     * **Requirements**:
     * - `order.shipping_option` must be included in `express_shipping_options` if both are set.
     * - `order.amount` must be equal to the sum of `order.items` and `order.shipping_option`
     *
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    put: operations["checkout_session_put"];
  };
  "/sessions/{session_id}/cancel": {
    /**
     * Cancel a session
     *
     * The session transaction will be voided in case where it is
     * initialized or authorized.
     *
     * Cancel is not allowed in case where the current transaction
     * state is not initialized or authorized.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["checkout_session_cancel_post"];
  };
  "/sessions/{session_id}/qr": {
    /**
     * Generate a QR Code containing the URL for the Checkout Session.
     * The QR Code can be displayed in POS to enable Checkout payment.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["qr_sessions_sid_post"];
  };
  "/sessions/payment-token": {
    /**
     * This endpoint lets you create payment and recurrence tokens without reserving
     * or charging any amount.
     *
     * The URL returned by this endpoint opens a web site where the customer
     * can enter their payment details, e.g. card information.
     *
     * The payment details will be validated and a transaction with a
     * payment/recurrence token will be created on success containing the payment
     * token created from the customer payment details.
     *
     * - [GET /v1/transactions/{id}?includes=card.payment_token](#operation/transactions_id_get)
     * - [GET /v1/transactions/{id}?includes=card.recurrence_token](#operation/transactions_id_get)
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["checkout_payment_token_session_post"];
  };
  "/sessions/{session_id}/pay": {
    /**
     * For Express Checkout sessions, the _`order.shipping_address`_ must be set on
     * the session, and a _`order.items.shipping_option` item is required if the
     * session has either an _`express.shipping_address_callback_url`_ or the
     * session has at least one option in _`express.shipping_options`_.
     */
    post: operations["checkout_sid_pay_post"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
  };
  "/sessions/{session_id}/redirect/{redirect_ref}": {
    get: operations["checkout_sid_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
    };
  };
  "/sessions/pay": {
    /**
     * For merchant initiated payments, where the customer is not involved.
     *
     * Receives a session and pays it with the given card token.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["checkout_session_pay_post"];
  };
  "/view/{session_id}": {
    get: operations["checkout_sid_html_get"];
  };
  "/view/{session_id}/payments/{payment_product_type}": {
    post: operations["checkout_sid_payments_product_type_post"];
  };
  "/view/{session_id}/session": {
    get: operations["checkout_sid_json_get"];
  };
  "/view/{session_id}/session/abandon": {
    /** Abandon a checkout payment before completing payment. */
    post: operations["view_sid_session_abandon_post"];
    parameters: {
      path: {
        /** The session ID */
        session_id: string;
      };
    };
  };
  "/view/{session_id}/session/lock": {
    /**
     * When locked, the session can not be paid.
     * Locking the session is only available when express is enabled.
     */
    post: operations["checkout_sid_lock"];
  };
  "/view/{session_id}/session/order/addresses": {
    /**
     * Changes the `order.shipping_address` and `order.billing_address` submitted by end user in the Express Checkout flow.
     *
     * If the _`express.shipping_address_callback_url`_ is set, the _`express.shipping_options`_
     * in the response will be updated to show the available shipping options for
     * the updated address.
     *
     * Also changes the checkboxes that are part of the session as they are
     * checked or unchecked by the end user in the Express Checkout flow.
     */
    put: operations["checkout_sid_json_order_addresses_put"];
  };
  "/view/{session_id}/session/order/discount_codes": {
    /**
     * Changes the `order.discount_codes` submitted by end user in the Express Checkout flow.
     *
     * If the _`express.discount_codes_callback_url`_ is set, the session will be
     * updated with discount on the order and the shipping options.
     */
    put: operations["checkout_sid_json_order_discount_codes_put"];
  };
  "/view/{session_id}/session/order/gift_cards": {
    /**
     * Change the active `gift_cards` for the session. Updating with empty gift cards
     * removes all gift cards from the session
     */
    put: operations["checkout_sid_json_order_gift_cards_put"];
  };
  "/view/{session_id}/session/order/shipping_address": {
    /**
     * **Deprecated** in favor of [PUT /v1/view/{session_id}/session/order/addresses](#operation/checkout_sid_json_order_addresses_put)
     *
     * Changes the order.shipping_address, submitted by end user in the Express Checkout flow.
     *
     * If the _`express.shipping_address_callback_url`_ is set, the _`express.shipping_options`_
     * in the response will be updated to show the available shipping options for
     * the updated address.
     */
    put: operations["checkout_sid_json_order_shipping_address_put"];
  };
  "/view/{session_id}/session/order/shipping_option": {
    /** Changes the selected shipping_option, submitted by end user in the  Express Checkout flow. */
    put: operations["checkout_sid_json_order_items_shipping_option_put"];
  };
  "/view/{session_id}/session/publish/scc": {
    /** Send a SMS with a payment verification code */
    post: operations["checkout_sid_send_scc"];
  };
  "/examples/discount_code_callback_url": {
    /**
     * This API endpoint on the merchant side allows Dintero to get
     * shipping_options and order with discounts based on the provided
     * session that had its `order.discount_codes` updated.
     */
    post: operations["example_discount_codes_callback_url"];
  };
  "/examples/session_url_callback": {
    /**
     * This API endpoint on the merchant side allows Dintero to notify
     * the `session.url.callback_url` when the payment is completed
     *
     * > The `transaction_id` is optional if `report_error=true`
     */
    get: operations["example_session_get_callback_url"];
    /**
     * This API endpoint on the merchant side allows Dintero to notify
     * the `session.url.callback_url` when the payment is completed
     * > POST is only use if `callback_url` includes `method=POST` query parameter.
     *
     * > The `body` and `transaction_id` is optional if `report_error=true`
     */
    post: operations["example_session_post_callback_url"];
    parameters: {
      header: {
        /**
         * Dintero signature that can be used to verify the payload from the
         * callback.
         *
         * Only include if a signature secret exist:
         *
         * - [POST /v1/admin/signature](#operation/admin_signature_post)
         */
        "Dintero-Signature"?: string;
      };
      query: {
        /** The Id for the transaction created */
        transaction_id: string;
        /** Session Id. Either `session_id` or `sid` is required. */
        session_id?: string;
        /** Session Id if `sid_parameter_name=sid`. Either `session_id` or `sid` is required. */
        sid?: string;
        /** The merchants reference */
        merchant_reference: string;
        /** ISO 8601 format for when the transaction was created */
        time: string;
        /** Error code */
        error?: string;
        /** Event applied to transaction */
        event?: string;
        /** Id for the event applied to transaction */
        event_id?: string;
        /** The method to use when delivering the callback */
        method?: string;
        /** Report error callback */
        report_error?: boolean;
        /** Delay before delivering the callback */
        delay_callback?: number;
        /** Deliver callback on othe transaction events */
        report_event?: string;
      };
    };
  };
  "/examples/shipping_address_callback_url": {
    /**
     * This API endpoint on the merchant side allows Dintero to get
     * shipping options based on the provided session after an address
     * update
     */
    post: operations["example_shipping_address_callback_url"];
  };
  "/transactions": {
    /**
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["transactions_get"];
  };
  "/transactions/{id}": {
    /**
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["transactions_id_get"];
    /**
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    put: operations["transactions_id_put"];
  };
  "/transactions/{id}/capture": {
    /**
     * Captures a transaction that was created with the Checkout
     * endpoint with a `capture_now` value of `false`.
     *
     * #### Capture Instabank transaction
     *
     * Note that `items` is required when capturing a transaction
     * with `payment_product=instabank`. The items must include
     * the lines to Capture, with `line_id`, `quantity` and `amount`.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["transactions_id_capture_post"];
  };
  "/transactions/{id}/authorization": {
    /**
     * Extend authorization on transaction for greater time to capture.
     * NB: Currently only supported for Klarna.
     */
    post: operations["transaction_tid_extend_authorization_post"];
  };
  "/transactions/{id}/refund": {
    /**
     * Once a transaction has been successfully captured,
     * a refund operation is available. Like other operations,
     * refund can be partial or total
     *
     * #### Refund Instabank transaction
     *
     * Note that `items` is required when refunding a transaction
     * with `payment_product=instabank`. The items must include the
     * lines to Refund, with `line_id`, `quantity` and `amount`.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["transactions_id_refund_post"];
  };
  "/transactions/{id}/void": {
    /**
     * At any moment before capture of a transaction, it is
     * possible to cancel an authorization. This operation is
     * called voiding and can be performed by doing a POST to
     * this endpoint
     *
     * #### Void on part capture
     *
     * Void after a part capture will cancel the difference between
     * the capture amount and the authorization amount.
     *
     * Void on part capture is only supported on following types:
     *   - `payex.creditcard`
     *   - `payex.mobilepay`
     *   - `payex.vipps`
     *   - `payex.applepay`
     *   - `payex.clicktopay`
     *   - `payex.googlepay`
     *   - `vipps`
     *   - `klarna.klarna`
     *   - `klarna.billie`
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["transactions_id_void_post"];
  };
  "/transactions/events/settlements": {
    /**
     * Add settlement events to list of transactions
     *
     * scopes:
     * - admin:checkout
     */
    post: operations["transactions_events_settlements_post"];
  };
  "/admin/api-keys": {
    /**
     * scopes:
     * - admin:checkout
     */
    get: operations["admin_api_keys_get"];
    /**
     * scopes:
     * - admin:checkout
     */
    post: operations["admin_api_keys_post"];
  };
  "/admin/api-keys/{api_key_id}": {
    /**
     * scopes:
     * - admin:checkout
     */
    delete: operations["admin_parameters_api_key_delete"];
  };
  "/admin/api-keys/{api_key_id}/rotate-api-key": {
    /**
     * scopes:
     * - admin:checkout
     */
    post: operations["admin_api_keys_api_key_id_rotate_post"];
  };
  "/admin/checkout": {
    /**
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["admin_checkout_id_get"];
    /**
     * scopes:
     * - admin:checkout
     */
    put: operations["admin_checkout_id_put"];
  };
  "/view/{session_id}/netaxept": {
    get: operations["checkout_sid_netaxept_html_get"];
  };
  "/view/{session_id}/payex/{payment_id}/status": {
    get: operations["checkout_sid_payex_payment_get"];
  };
  "/view/{session_id}/swish/{payment_request_id}/status": {
    /**
     * Get status about the Swish session. Will check if the session contains a transaction_id,
     * and if the transaction is paid with the given Swish payment_request_id.
     */
    get: operations["checkout_sid_swish_get"];
  };
  "/view/{session_id}/vipps": {
    get: operations["checkout_sid_html_vipps_get"];
  };
  "/admin/gateways/bambora": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_bambora_put"];
  };
  "/admin/gateways/collector/credentials": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_gateways_collector_credentials_put"];
  };
  "/admin/gateways/collector/override": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_override_collector_put"];
  };
  "/admin/gateways/collector": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_collector_put"];
  };
  "/admin/gateways/{gateway}/status": {
    /**
     * verify the gateway configuration
     *
     * scopes:
     * - admin:checkout
     */
    post: operations["admin_checkout_gw_type_status_post"];
  };
  "/admin/gateways/instabank": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_instabank_put"];
  };
  "/admin/gateways/klarna/credentials": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_gateways_klarna_credentials_put"];
  };
  "/admin/gateways/klarna": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_klarna_put"];
  };
  "/admin/gateways/netaxept/override": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_override_netaxept_put"];
  };
  "/admin/gateways/netaxept": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_netaxept_put"];
  };
  "/admin/gateways/payex/credentials": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_gateways_payex_credentials_put"];
  };
  "/admin/gateways/payex/override": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_override_payex_put"];
  };
  "/admin/gateways/payex": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_payex_put"];
  };
  "/admin/gateways/santander/override": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_override_santander_put"];
  };
  "/admin/gateways/santander": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_santander_put"];
  };
  "/admin/gateways/swish/override": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_override_swish_put"];
  };
  "/admin/gateways/swish": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_swish_put"];
  };
  "/admin/gateways/vipps/override": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_override_vipps_put"];
  };
  "/admin/gateways/vipps": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_vipps_put"];
  };
  "/admin/gateways/dintero_psp": {
    /**
     * scopes:
     * - admin:dintero
     */
    put: operations["admin_checkout_id_gw_psp_put"];
  };
  "/admin/session/profiles/{profile_id}": {
    /**
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["admin_session_profile_details_get"];
    /**
     * scopes:
     * - admin:checkout
     */
    put: operations["admin_session_profile_details_put"];
    /**
     * scopes:
     * - admin:checkout
     */
    delete: operations["admin_session_profile_details_delete"];
  };
  "/admin/session/profiles": {
    /**
     * scopes:
     * - admin:checkout
     */
    get: operations["admin_session_profile_get"];
    /**
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    post: operations["admin_session_profile_post"];
  };
  "/admin/signature": {
    /**
     * Get the current signature secret Dintero uses when create the
     * `Dintero-Signature` header included in requests it sends to your
     * endpoints.
     *
     * scopes:
     * - admin:checkout
     * - read:checkout
     */
    get: operations["admin_signature_get"];
    /**
     * Dintero can optionally sign all request it sends to your endpoints.
     *
     * We do so by including a signature in the request `Dintero-Signature`
     * header. This allows you to verify that the request was done by
     * Dintero, not by a third party.
     *
     * *`v0-hmac-sha256`*
     *
     * ```
     * <timestamp>\n<account_id>\n<method>\n<hostname>\n<pathname>\n<query>
     * ```
     *
     * ```
     * secret: 123
     * timestamp: 1582236537
     * account_id: P00000000
     * method: GET
     * url: https://example.com/callback?B=123&A=992
     *
     * Dintero-Signature: t=1582236537,
     *     v0-hmac-sha256=6bed2ab1b919d460ef7465a20dc6c97260dca73fab6647106ca525f0908df64a
     * ```
     *
     * > The timestamp (`t`) in the Dintero-Signature, is included in the signature payload to
     * > mitigate `replay attach`. If your signature is valid but the timestamp is too old, you
     * > can have your application reject the request. We recommend that your application have
     * > a tolerance of five minutes between the timestamp and the current time.
     *
     * > *NOTE:* The query parameters must be sorted.
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["admin_signature_post"];
  };
  "/branding/logos/{logos}/variant/{variant}/color/{color}/width/{width}/{template}": {
    /** Endpoint that returns an svg that can be used to show the world your payment options. [Go to the documentation for the checkout branding endpoints.](/docs/checkout-branding) */
    get: operations["branding_logoframe"];
  };
  "/branding/profiles/{profile_id}/variant/{variant}/color/{color}/width/{width}/{template}": {
    /** Endpoint that returns an svg that can be used to show the world your payment options. [Go to the documentation for the checkout branding endpoints.](/docs/checkout-branding) */
    get: operations["branding_profile"];
  };
  "/callbacks/collector/antifraud": {
    get: operations["checkout_sid_collector_callback_post"];
  };
  "/creditchecks": {
    /**
     * Perform a credit check
     *
     * scopes:
     * - admin:checkout
     * - write:checkout
     */
    post: operations["creditchecks_post"];
  };
  "/events/gateways/collector/idp/signin/test": {
    get: operations["checkout_collector_idp_signin_test_get"];
  };
  "/events/gateways/collector/idp/signin": {
    get: operations["checkout_collector_idp_signin_get"];
  };
  "/events/gateways/netaxept/transaction/hooks": {
    post: operations["checkout_netaxept_webhooks_post"];
  };
  "/events/gateways/swish/transaction/payment/{session_id}/{callback_ref}": {
    post: operations["checkout_swish_payment_callback_post"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        callback_ref: string;
      };
    };
  };
  "/events/gateways/swish/transaction/refund/{id}/{callback_ref}": {
    post: operations["checkout_swish_refund_callback_post"];
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
        callback_ref: string;
      };
    };
  };
  "/events/transaction/{intent}": {
    /**
     * Handle async update of transaction.
     *
     * scopes:
     * - admin:checkout
     */
    post: operations["events_transaction_post"];
  };
  "/sessions/{session_id}/bambora/callback/{callback_ref}": {
    get: operations["checkout_bambora_callback_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        callback_ref: string;
      };
    };
  };
  "/sessions/{session_id}/bambora/redirect/{redirect_ref}": {
    get: operations["checkout_sid_bambora_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
    };
  };
  "/sessions/{session_id}/collector/redirect": {
    get: operations["checkout_sid_collector_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
  };
  "/sessions/{session_id}/dintero/redirect/{redirect_ref}": {
    get: operations["checkout_sid_dintero_redirect_get"];
  };
  "/sessions/{session_id}/dintero_psp/redirect/{redirect_ref}": {
    get: operations["checkout_sid_dintero_psp_redirect_get"];
  };
  "/sessions/{session_id}/klarna/redirect/{redirect_ref}": {
    get: operations["checkout_sid_klarna_redirect_get"];
  };
  "/sessions/{session_id}/netaxept/redirect/{redirect_ref}": {
    get: operations["checkout_sid_netaxept_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
    };
  };
  "/sessions/{session_id}/payex/callback/{payment_product_type}": {
    /**
     * Creates a transaction from the session with status determined
     * by the payment status provided by Payex.
     */
    post: operations["checkout_sid_callback_post"];
  };
  "/sessions/{session_id}/payex/redirect/{action}/{payment_product_type}": {
    get: operations["checkout_sid_payex_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        action: "complete" | "cancel";
        payment_product_type:
          | "payex.creditcard"
          | "payex.mobilepay"
          | "payex.swish"
          | "payex.vipps";
      };
    };
  };
  "/sessions/{session_id}/payex-v3/callback/{callback_ref}": {
    /**
     * Creates a transaction from the session with status determined
     * by the payment status provided by Payex.
     */
    post: operations["checkout_payex_v3_callback_post"];
  };
  "/sessions/{session_id}/payex-v3/redirect/{redirect_ref}": {
    get: operations["checkout_sid_payex_v3_redirect_get"];
  };
  "/sessions/{session_id}/santander/redirect": {
    get: operations["checkout_sid_santander_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
  };
  "/sessions/{session_id}/swish/redirect/{redirect_ref}": {
    get: operations["checkout_sid_swish_redirect_get"];
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
    };
  };
  "/sessions/{session_id}/vipps/v2/payments/{order_id}": {
    post: operations["checkout_sid_vipps_payments_orderid_post"];
  };
}

export interface definitions {
  SwishPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  VippsPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  BamboraMobilePayPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  PayExCreditcardPayment: definitions["PayPayment"] & {
    /** @enum {string} */
    operation: "unscheduled_purchase" | "recurring_purchase";
  };
  BamboraCreditcardPayment: definitions["PayPayment"] & {
    /** @enum {string} */
    operation: "unscheduled_purchase" | "recurring_purchase";
  };
  CollectorInvoiceB2BPayment: definitions["Payment"] &
    definitions["CollectorPaymentDetails"] & {
      shipping_address: definitions["CollectorB2BAddress"];
      billing_address: definitions["CollectorB2BAddress"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  CollectorFinancePayment: definitions["Payment"] &
    definitions["CollectorDetails"] &
    definitions["CollectorPaymentDetails"] & {
      shipping_address: definitions["CollectorAddress"];
      billing_address: definitions["CollectorAddress"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
      /** @description Code from authorized customer. */
      authorization_code?: string;
    };
  /** @description Contains href URI to authorize customer */
  CollectorAuthorizationOperation: definitions["PaymentOperation"] & {
    /**
     * @description Contains the URI to authorize customer
     *
     * @example https://idp.collectorbank.se/authorize?acr_values=...
     */
    href?: string;
  };
  /** @description Contains href URI to initiate a pay with Collector Invoice B2B */
  CollectorInvoiceB2BPaymentOperation: definitions["PaymentOperation"] & {
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://checkout.dintero.com/v1/sessions/{session_id}/pay
     */
    href?: string;
    shipping_address: definitions["CollectorB2BPaymentOperationAddress"];
  };
  SantanderPayment: definitions["Payment"] &
    definitions["SantanderDetails"] &
    definitions["SantanderPaymentDetails"];
  /** @description Contains href URI to initiate a pay with Collector Installment */
  CollectorInstallmentPaymentOperation: definitions["PaymentOperation"] & {
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://checkout.dintero.com/v1/sessions/{session_id}/pay
     */
    href?: string;
    product: definitions["CollectorProduct"];
  };
  /** @description Contains href URI to initiate an Apple Pay payment with Swedbank Pay (v3) */
  PayExV3ApplepayPaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  /** @description Send SSC verification code */
  SendSCCPaymentOperation: definitions["PaymentOperation"] & {
    /**
     * @description Contains the URI to to send SCC code.
     *
     * @example https://checkout.dintero.com/view/{session_id}/sessions/publish/scc
     */
    href?: string;
  };
  PayExTokenProvider: definitions["TokenProvider"] & {
    token_types: ("payment_token" | "recurrence_token")[];
  };
  BamboraTokenProvider: definitions["TokenProvider"] & {
    token_types: ("payment_token" | "recurrence_token")[];
  };
  TransactionBambora: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "bambora.creditcard" | "bambora.vipps";
      card?: {
        /**
         * @description Visa, MasterCard, etc. The brand of the card.
         * @example Visa
         */
        brand?: string;
        /** @example 476173******0416 */
        masked_pan?: string;
        /** Format: \d{2}/\d{4} */
        expiry_date?: string;
        /**
         * @description Credit or Debit. Indicates the type of card used
         *
         * @enum {string}
         */
        type?: "Credit Card";
        eci?: string;
        /**
         * Format: iso-3166-1
         * @description The country the card is issued in
         */
        country?: string;
      };
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          "bambora:transaction:status"?: string;
          "bambora:transactionoperation:id"?: string;
          "bambora:meta:action:source"?: string;
          "bambora:meta:action:code"?: string;
          "bambora:meta:action:type"?: string;
        };
      }[];
      metadata?: {
        "gateway:id"?: string;
        "bambora:merchant_number"?: string;
        "bambora:transaction_id"?: string;
        "bambora:reference"?: string;
        "bambora:acquirer"?: string;
        "bambora:wallet"?: string;
      };
    };
  /** @description Contains href URI to initiate a Click to Pay payment using Swedbank Pay (v3) */
  PayExV3ClickToPayPaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  /** @description Contains href URI to initiate a Swish payment with Swedbank Pay (v3) */
  PayExV3SwishPaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  /** @description Contains href URI to initiate a Vipps payment with Swedbank Pay (v3) */
  PayExV3VippsPaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  /** @description Contains href URI to initiate a MobilePay payment with Swedbank Pay (v3) */
  PayExV3MobilePayPaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  /** @description Contains href URI to initiate a Google Pay payment using Swedbank Pay (v3) */
  PayExV3GooglePayPaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  PayExVippsPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  TransactionSantander: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "santander.debit_account";
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          /** @description ID of the application provided by Santander */
          "santander:debit_account.ApplicationNumber"?: string;
          /** @description Status code from Santander */
          "santander:debit_account.StatusCode"?: string;
        };
      }[];
      metadata?: {
        /** @description ID of the application provided by Santander */
        "santander:debit_account.ApplicationNumber"?: string;
        /** @description Status code from Santander */
        "santander:debit_account.StatusCode"?: string;
      };
    };
  TransactionVipps: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "vipps";
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          /** Format: date-time */
          "vipps:transactionInfo.timeStamp"?: string;
          "vipps:transactionInfo.transactionId"?: string;
          /** @enum {string} */
          "vipps:transactionInfo.status"?:
            | "INITIATE"
            | "RESERVE"
            | "CANCEL"
            | "CAPTURE"
            | "VOID";
          "vipps:transaction.transactionText"?: string;
        };
      }[];
      metadata?: {
        "vipps:transaction.orderId"?: string;
        "vipps:transaction.transactionText"?: string;
        /**
         * Format: ^\d{6}$
         * @description Unique id for this merchant's sales channel: website, mobile app
         * etc. Short name: MSN.
         */
        "vipps:merchantInfo.merchantSerialNumber"?: string;
        /** @enum {string} */
        "vipps:merchantInfo.paymentType"?: "eComm Regular Payment";
      };
    };
  /** @description Contains href URI to initiate a pay with Klarna */
  KlarnaPaymentOperation: {
    /** @enum {string} */
    rel: "pay-klarna";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://checkout.dintero.com/v1/sessions/{session_id}/pay
     */
    href: string;
    /** @enum {string} */
    method: "POST";
    /**
     * @description Client token to be passed to the JS client while initializing the
     * JS SDK
     */
    client_token: string;
    /** @description String representation of the payment order to be used with the payment operations. */
    order: string;
    /** @enum {string} */
    content_type: "application/json";
  } & definitions["PaymentOperation"];
  CollectorInvoiceB2BPreapprovedPayment: definitions["Payment"] &
    definitions["CollectorPaymentDetails"] & {
      shipping_address: definitions["CollectorB2BAddress"];
      /** @description Optional query parameter. SMS-confirm-code. To verify the identity of the payee. */
      scc?: string;
      /** @description Id to represent the company being paid from */
      company_id: string;
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  BamboraVippsPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  /** @description Contains href URI to initiate a pay with Swedbank Pay (v3) */
  PayExV3PaymentOperation: {
    /** @enum {string} */
    content_type: "application/javascript";
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://ecom.payex.com/payment/core/js...
     */
    href: string;
  } & definitions["PaymentOperation"];
  TransactionNetaxept: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "netaxept.creditcard";
      card?: {
        /**
         * @description Visa, MasterCard, etc. The brand of the card.
         * @example Visa
         */
        brand?: string;
        /** @example 476173******0416 */
        masked_pan?: string;
        /** Format: \d{2}/\d{4} */
        expiry_date?: string;
        /**
         * @description Credit or Debit. Indicates the type of card used
         *
         * @enum {string}
         */
        type?: "Credit Card";
        /** @description The name of the bank that issued the card used */
        issuing_bank?: string;
        /**
         * Format: iso-3166-1
         * @description The country the card is issued in
         */
        country?: string;
      };
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          "netaxept:transaction_id"?: string;
          "netaxept:operation"?: string;
          "netaxept:execution_time"?: string;
          "netaxept:bat_number"?: string;
          "netaxept:response_code"?: string;
          "netaxept:terminal_url"?: string;
        };
      }[];
      metadata?: {
        "netaxept:merchant_id"?: string;
        "netaxept:transaction_id"?: string;
      };
    };
  PayExSwishPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     *
     * The `redirect_url` in the response will be a Swish URL that will
     * open the app with the payment request if no phone_number is provided.
     */
    phone_number?: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  InstabankPostponementPayment: definitions["Payment"] &
    definitions["InstabankDetails"] &
    definitions["InstabankPaymentDetails"] & {
      /** @example 633 */
      product_code: string;
      applicant?: definitions["InstabankApplication"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  TransactionSwish: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment type corresponding to this transaction
       *
       * @enum {undefined}
       */
      payment_product_type: "swish.swish";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: definitions["SwishTransactionEventMetadata"];
      }[];
      metadata?: {
        "swish:payment_request:id"?: string;
        "swish:swish_number"?: string;
        /** @description Payment request id */
        "swish:id"?: string;
        /** @description Capture payment reference from bank */
        "swish:paymentReference"?: string;
      };
    };
  TransactionKlarna: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "klarna.klarna" | "klarna.billie";
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          /** @description Internal reference sent to Klarna for the capture/refund. This will be included in the settlement files. */
          "klarna:reference"?: string;
          /** @description Id of the capture created in Klarna */
          "klarna:headers:capture_id"?: string;
          /** @description Id of the refund created in Klarna */
          "klarna:headers:refund_id"?: string;
          /** @description The URI at which the capture or refund created in Klarna can be found */
          "klarna:headers:location"?: string;
          /** @description Authorization expiration date (ISO 8601 format), e.g. "2023-08-16T15:00:00Z" */
          "klarna:authorization_expiration"?: string;
          /** @description The reason for extending the authorization date. */
          "klarna:authorization_expiration_reason"?: string;
          /** @description A reference specified by the merchant to identify the transaction. */
          "klarna:authorization_expiration_reference"?: string;
          /** @description The reason an error occurred when trying to extend the authorization date. */
          "klarna:authorization_expiration_error_reason"?: string;
        };
      }[];
      metadata?: {
        /** @description Order Id in Klarna */
        "gateway:id"?: string;
        merchant_name?: string;
        /** @enum {string} */
        "klarna:authorized_payment_method:type"?:
          | "invoice"
          | "fixed_amount"
          | "base_account"
          | "direct_debit"
          | "direct_bank_transfer"
          | "b2b_invoice"
          | "card"
          | "slice_it_by_card"
          | "pay_later_by_card"
          | "pay_by_card"
          | "fixed_sum_credit";
        "klarna:authorized_payment_method:number_of_days"?: string;
        "klarna:authorized_payment_method:number_of_installments"?: string;
        /**
         * @description Fraud status for order
         *
         * @enum {string}
         */
        "klarna:authorized_payment_method:fraud_status"?:
          | "ACCEPTED"
          | "PENDING";
      };
    };
  /** @description Contains href URI to initiate a pay with Bambora Checkout */
  BamboraPaymentOperation: definitions["PaymentOperation"] & {
    session: {
      /** @example fb49265d30aa4f1bb327b943c4d43b14 */
      token: string;
    };
    /**
     * @description Contains the URI to initiate a payment.
     *
     * @example https://v1.checkout.bambora.com/fb49265d30aa4f1bb327b943c4d43b14
     */
    href: string;
  };
  InstabankInstallmentPayment: definitions["Payment"] &
    definitions["InstabankDetails"] &
    definitions["InstabankPaymentDetails"] & {
      /** @example 633 */
      product_code: string;
      applicant?: definitions["InstabankApplication"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  /**
   * @description Contains href URI of the JavaScript used to create a Hosted View
   * iframe directly without redirecting the consumer to a separate
   * payment page
   */
  ViewPaymentOperation: definitions["PaymentOperation"] & {
    /**
     * @description Contains the URI of the JavaScript used to create
     * a Hosted View iframe directly without redirecting the consumer to
     * separate payment page.
     */
    href?: string;
  };
  CollectorInstallmentPayment: definitions["Payment"] &
    definitions["CollectorDetails"] &
    definitions["CollectorPaymentDetails"] & {
      product: {
        /**
         * @description Id of the payment product
         * @example IF_3_001
         */
        id: string;
      };
      shipping_address: definitions["CollectorAddress"];
      billing_address: definitions["CollectorAddress"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
      /** @description Code from authorized customer. */
      authorization_code?: string;
    };
  CollectorInstallmentB2BPreapprovedPayment: definitions["Payment"] &
    definitions["CollectorPaymentDetails"] & {
      product: {
        /**
         * @description Id of the payment product
         * @example IF_3_001
         */
        id: string;
      };
      shipping_address: definitions["CollectorB2BAddress"];
      /** @description Optional query parameter. SMS-confirm-code. To verify the identity of the payee. */
      scc?: string;
      /** @description Id to represent the company being paid from */
      company_id: string;
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  TransactionInstabank: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type:
        | "instabank.finance"
        | "instabank.invoice"
        | "instabank.installment"
        | "instabank.postponement";
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          /** @description External status reported after the transaction event */
          "instabank:Sale.Status"?: string;
          /** @description External request id */
          "instabank:RequestId"?: string;
        };
      }[];
      metadata?: {
        /** @description External reference for the transaction */
        "instabank:Sale.ExternalReference"?: string;
        /** @description External case sequence (id) */
        "instabank:Sale.Sequence"?: number;
        /** @description Payment product name */
        "instabank:Sale.Product.Name"?: string;
      };
    };
  TransactionCollector: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type:
        | "collector.finance"
        | "collector.invoice"
        | "collector.invoice_b2b"
        | "collector.invoice_b2b_preapproved"
        | "collector.installment";
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "ON_HOLD"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "ON_HOLD"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          /** @description External status reported after adding invoice and activating invoice */
          "collector:Invoice.InvoiceStatus"?: number;
          /** @description External request id */
          "collector:CorrelationId"?: string;
          /** @description The payment identification number. This is the id the customer must use when they do a payment of an invoice. */
          "collector:Invoice.PaymentReference"?: string;
          /** @description The lowest amount to pay on the invoice. */
          "collector:Invoice.LowestAmountToPay"?: number;
          /** @description The total amount to pay for the invoice. */
          "collector:Invoice.TotalAmount"?: number;
          /** @description The due date of the invoice. */
          "collector:Invoice.DueDate"?: string;
          /** @description The url to invoice in pdf format. */
          "collector:Invoice.InvoiceUrl"?: string;
          /** @description The invoice number of the invoice that this event belongs to. */
          "collector:Invoice.CurrentInvoiceNumber"?: string;
          /** @description The invoice number for the next capture. */
          "collector:Invoice.NewInvoiceNumber"?: string;
        };
      }[];
      metadata?: {
        /** @description The Collector Store ID of the payment */
        "collector:StoreId"?: string;
        /** @description The invoice number of the invoice. */
        "collector:Invoice.InvoiceNumber"?: string;
        /** @description Corresponds to the Dintero session ID */
        "collector:Invoice.OrderNumber"?: string;
        /** @description The country of the payment */
        "collector:Invoice.CountryCode"?: string;
        "collector:Invoice.ProductCode"?: string;
        "collector:Invoice.InvoiceType"?: string;
        /** @description The SettlementReference used for the payment. */
        "collector:Invoice.SettlementReference"?: string;
      };
    };
  CollectorInvoicePayment: definitions["Payment"] &
    definitions["CollectorDetails"] &
    definitions["CollectorPaymentDetails"] & {
      shipping_address: definitions["CollectorAddress"];
      billing_address: definitions["CollectorAddress"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
      /** @description Code from authorized customer. */
      authorization_code?: string;
    };
  KlarnaPayment: definitions["Payment"] & {
    /** @description Token received from Klarna on the client-side after successful authorization */
    authorization_token: string;
    billing_address: definitions["KlarnaAddress"];
    shipping_address: definitions["KlarnaAddress"];
    /**
     * @description Combination of purchase country and language. Example: `"en-GB"`
     *
     * @example en-GB
     */
    locale: string;
  };
  KlarnaBilliePayment: definitions["Payment"] & {
    /** @description Token received from Klarna on the client-side after successful authorization */
    authorization_token: string;
    billing_address: unknown & definitions["OrderAddress"];
    shipping_address: unknown & definitions["OrderAddress"];
    /**
     * @description Combination of purchase country and language. Example: `"en-GB"`
     *
     * @example en-GB
     */
    locale: string;
  };
  PayExMobilePayPayment: definitions["Payment"] & {
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description If true will either make the backend add or update a signed cookie with
     * customer data. If false the cookie will be removed. If not set,
     * any existing cookie will remain unchanged
     */
    remember_me?: boolean;
  };
  InstabankFinancePayment: definitions["Payment"] &
    definitions["InstabankDetails"] &
    definitions["InstabankApplication"] &
    definitions["InstabankPaymentDetails"] & {
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  TransactionPayEx: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type:
        | "payex.creditcard"
        | "payex.mobilepay"
        | "payex.swish"
        | "payex.vipps"
        | "payex.applepay"
        | "payex.clicktopay"
        | "payex.googlepay";
      card?: {
        /**
         * @description Visa, MasterCard, etc. The brand of the card.
         * @example Visa
         */
        brand?: string;
        /** @example 476173******0416 */
        masked_pan?: string;
        /** Format: \d{2}/\d{4} */
        expiry_date?: string;
        /**
         * @description Credit or Debit. Indicates the type of card used
         *
         * @enum {string}
         */
        type?: "Credit Card" | "Debit Card";
        /** @description The name of the bank that issued the card used */
        issuing_bank?: string;
        /**
         * Format: iso-3166-1
         * @description The country the card is issued in
         */
        country?: string;
        /**
         * @description 3DSECURE or SSL. Indicates the transaction type of the acquirer.
         *
         * @enum {string}
         */
        acquirer_transaction_type?: "3DSECURE" | "SSL";
        /**
         * @description The System Trace Audit Number assigned by the acquirer to
         * uniquely identify the transaction.
         */
        acquirer_stan?: string;
        /** @description The ID of the acquirer terminal. */
        acquirer_terminal_id?: string;
        /**
         * Format: date-time
         * @description The ISO-8601 date and time of the acquirer transaction.
         */
        acquirer_transaction_time?: string;
        /**
         * @description Y, A, U or N. Indicates the status of the authentication.
         *
         * @enum {string}
         */
        authentication_status?: "Y" | "A" | "U" | "N";
        /**
         * @description The payment token generated by the authorization. Only available
         * for transactions created from session where the
         * generate_payment_token option is enabled in the payex session
         * configuration or from payment token sessions created with payex
         * configured
         *
         * - [POST /v1/sessions-payment-token](#operation/checkout_payment_token_session_post)
         */
        payment_token?: string;
        /**
         * @description The id of the payment_token, only included in transaction where
         * a payment_token was generated.
         */
        payment_token_id?: string;
        /**
         * @description The payment token generated by the authorization. Only available
         * for transactions created from session where the
         * generate_recurrence_token option is enabled in the payex session
         * configuration or from payment token sessions created with payex
         * configured
         *
         * - [POST /v1/sessions-payment-token](#operation/checkout_payment_token_session_post)
         */
        recurrence_token?: string;
        /**
         * @description The id of the recurrence_token, only included in transaction where
         * a recurrence_token was generated.
         */
        recurrence_token_id?: string;
      };
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "VERIFIED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "VERIFIED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          "payex:transaction:id"?: string;
          "payex:transaction:number"?: unknown;
          "payex:transaction:type"?: string;
          "payex:transaction:state"?: string;
          /** Format: date-time */
          "payex:transaction:created"?: string;
          "payex:transaction:payee_reference"?: string;
        };
      }[];
      metadata?: {
        "payex:payment:payee_info:payee_id"?: string;
        "payex:payment:payee_info:payee_name"?: string;
        "payex:payment:payee_info:subsite"?: string;
        "payex:payment:id"?: string;
        "payex:payment:number"?: unknown;
        "payex:payment:operation"?: string;
        /** Format: date-time */
        "payex:payment:created"?: string;
      };
    };
  InstabankInvoicePayment: definitions["Payment"] &
    definitions["InstabankDetails"] &
    definitions["InstabankPaymentDetails"] & {
      applicant?: definitions["InstabankApplication"];
      /**
       * @description If true will either make the backend add or update a signed cookie with
       * customer data. If false the cookie will be removed. If not set,
       * any existing cookie will remain unchanged
       */
      remember_me?: boolean;
    };
  TransactionDintero: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "dintero.zero" | "dintero.wallets";
    };
  DinteroPayment: definitions["Payment"];
  DinteroWalletsPayment: definitions["Payment"];
  /** @description Contains href URI to view card GUI for Dintero PSP creditcard payment */
  DinteroPspViewCardPaymentOperation: ({
    /**
     * @description Contains the URI to view card GUI for Dintero PSP creditcard payment
     *
     * @example https://payments.psp.dintero.com/keys/v1
     */
    href: string;
    /** @enum {string} */
    method: "GET";
    /** @enum {string} */
    content_type: "text/html";
  } & {
    rel: unknown;
  }) &
    definitions["PaymentOperation"];
  /** @description Contains href URI to submit card details to Dintero PSP */
  DinteroPspSubmitCardPaymentOperation: ({
    /**
     * @description Contains the URI to submit card details to Dintero PSP
     *
     * @example https://payments.psp.dintero.com/card/v1/{account_id}/payments/{payment_id}/transactions
     */
    href: string;
    /** @enum {string} */
    method: "POST";
    /** @enum {string} */
    content_type: "application/json";
  } & {
    rel: unknown;
  }) &
    definitions["PaymentOperation"];
  /** @description Contains href URI to initiate a pay with Dintero PSP creditcard */
  DinteroPspPayCardPaymentOperation: ({
    /**
     * @description Contains the URI to initiate a pay with Dintero PSP creditcard
     *
     * @example https://checkout.dintero.com/v1/sessions/{session_id}/pay
     */
    href: string;
    /** @enum {string} */
    method: "POST";
    /** @enum {string} */
    content_type: "application/json";
  } & {
    rel: unknown;
  }) &
    definitions["PaymentOperation"];
  DinteroPspCreditcardPayment: definitions["Payment"] & {
    /** @description Transaction id received from psp-service when creating card transaction */
    psp_transaction_id: string;
  };
  TransactionDinteroPsp: definitions["Transaction"] &
    definitions["Id"] & {
      /**
       * @description The payment product type corresponding to this transaction
       *
       * @enum {string}
       */
      payment_product_type: "dintero_psp.creditcard";
      /**
       * @example CAPTURED
       * @enum {string}
       */
      status?:
        | "INITIATED"
        | "AUTHORIZED"
        | "AUTHORIZATION_VOIDED"
        | "CAPTURED"
        | "PARTIALLY_CAPTURED"
        | "REFUNDED"
        | "PARTIALLY_REFUNDED"
        | "DECLINED"
        | "FAILED"
        | "UNKNOWN";
      events?: {
        /** @enum {string} */
        transaction_status?:
          | "INITIATED"
          | "AUTHORIZED"
          | "AUTHORIZATION_VOIDED"
          | "CAPTURED"
          | "PARTIALLY_CAPTURED"
          | "REFUNDED"
          | "PARTIALLY_REFUNDED"
          | "DECLINED"
          | "FAILED"
          | "UNKNOWN";
        metadata?: {
          /** @description Unique reference of operation */
          "dintero_psp:operation_ref"?: string;
          /** @description Reference to authorization operation upon void or capture */
          "dintero_psp:authorization_operation_ref"?: string;
          /** @description Reference to capture operation upon refund */
          "dintero_psp:capture_operation_ref"?: string;
          /** @description Reference to sale operation upon sale refund */
          "dintero_psp:sale_operation_ref"?: string;
        };
      }[];
      metadata?: {
        /** @description Transaction Id in Dintero PSP */
        "gateway:id"?: string;
      };
      card?: {
        masked_pan?: string;
        /** Format: \d{2}/\d{4} */
        expiry_date?: string;
        /** @example visa */
        brand?: string;
        /** @example credit */
        type?: string;
        /** @example 3DSECURE */
        acquirer_transaction_type?: string;
        /** @example 2 */
        three_ds_version?: string;
        three_ds_server_trans_id?: string;
        /** @example 04 */
        eci?: string;
        /** @example wallet */
        payment_system_type?: string;
      };
    };
  /**
   * Format: uri
   * @description URL that Checkout will call when the session
   * payment is complete and the transaction has been authorized.
   *
   * > **Callback is only delivered to HTTPS URLs**
   *
   * > A callback done with a transaction with status `ON_HOLD` will receive
   * > an aditional callback (later) when the transaction state changes status
   * > from `ON_HOLD`.
   *
   * > The callback may be received after the transaction is `CAPTURED`
   * > in case when the transaction was created from a session where
   * > `auto_capture` was enabled.
   *
   * Unlike the `return_url` the `callback_url` is system-to-system
   * which means delivery is guaranteed.
   *
   * Once a session payment is complete the callback_url is invoked as a
   * `GET` request to notify your system that the payment has been approved.
   *
   * - A callback_url with `method=POST` query parameter will be invoked as a
   *   `POST` request with the transaction included in the request body.
   *
   * - A callback_url with `report_error=true` will enable the callback_url
   *   to be called if the payment failed with error `cancelled`, `authorization`
   *   or `failed`.
   *
   * - A callback_url with `delay_callback=<seconds>` will delay the callback
   *   before trying to deliver the callback. The **maximum** delay is 60 seconds.
   *
   * - A callback_url with `report_event={EVENT}` will enable the callback_url
   *   to be called if a payment event has been applied to the transaction. Valid
   *   values are `CAPTURE`, `REFUND` and `VOID`. The callback_url can contain
   *   multiple `report_event` query parameters. An `event` query parameter will be
   *   included in the request sent to the callback_url.
   *
   * - A callback_url with `includes=session` will enable the callback_url
   *   to include the session data in the body.
   *
   * - A callback_url with `sid_parameter_name=sid` will change the query param `session_id`
   *   to `sid` to avoid false session fixation alarms in firewalls. Possible values: `sid`, `session_id`
   *
   * A successful delivery to an HTTPS callback_url sometimes requires
   * more than one attempt. This can be the case, for example, if the server
   * hosting the callback_url is down for maintenance or is experiencing
   * heavy traffic.
   *
   * Dintero attempts a retry only after a failed delivery attempt, following
   * situations is considered as failed delivery
   *
   *  - HTTP status code 100 to 101 and 500 to 599 (inclusive)
   *    (HTTP status code 400 to 499 is considered as permanent failure)
   *  - A request timeout (10 seconds)
   *  - Any connection error such as connection timeout, bad certificate, etc
   *
   * Failed delivery will be retried 20 times.
   *
   *  query name        | type          | description                  | required
   * ------------------ | :-----------: | :--------------------------- | :-----------
   * transaction_id     | string        | Transaction Id               | true
   * session_id         | string        | Session Id                   | true
   * sid                | string        | Session Id when sid_parameter_name=sid | true
   * merchant_reference | string        | The merchants reference      | true
   * time               | string        | ISO 8601 format              | true
   * error              | string        | Error code                   | false
   * event              | string        | event applied                | false
   * event_id           | string        | event id for callback        | false
   * includes           | string array  | include additional data      | false
   *
   * > The transaction_id is optional when callback_url enables `report_error`
   * > where error query will be included in case where the payment was completed
   * > without creating an authorized transaction.
   *
   * > It is not possible to use `https://localhost` or `http://127.0.0.1` for
   * > the callback URL as Checkout backend would then call itself.
   *
   * See [validating callbacks](https://docs.dintero.com/docs/validating-callbacks) to see how you can verify the integrity of the callbacks,
   *
   * @example https://example.com/callback?method=GET
   */
  CallbackUrl: string;
  SessionUrls: {
    /**
     * Format: uri
     * @description URL to page where Checkout will redirect the
     * customer to after the Checkout process has ended.
     *
     * If a transaction was completed successfully, a `transaction_id`
     * will be appended to the URL as a `query` string parameter
     *
     * > A `transaction_id` will be appended to the URL if the
     * > Checkout failed with `error=capture`
     *
     * > A transaction with status `ON_HOLD` must be handled as a payment
     * > that is pending approval, where the transaction will later be updated
     * > with a final payment staus `AUTHORIZED` or `FAILED`.
     * > We recommend that `callback_url` is used to receive the callback when
     * > the transaction changes status from `ON_HOLD` to `AUTHORIZED` or `FAILED`.
     * > Alternative is to do an hourly/daily poll on the transaction to check
     * > if the status has changed.
     *
     * *Example*:
     *
     *    ```
     *    https://example.com/accept?transaction_id=T00000000.3YkJXSdSnUBXcmQSzn7uJj
     *    ```
     *
     *  query name        | type         | description                    | required
     * ------------------ | :----------: | ------------------------------ | :-----------:
     * transaction_id     |   string     | Transaction Id                 | false
     * error              |   string     | Error code identifying cause   | false
     * merchant_reference |   string     | The merchants reference        | true
     *
     * In case of that something went wrong with the payment flow, an
     * `error` query parameter will be appended to the URL. The value
     * of the error is a code identifying the cause.
     *
     * error         | Description
     * ------------- | ------------
     * cancelled     | Customer cancelled the checkout payment
     * authorization | Customer failed to authorize the payment
     * failed        | The transaction has been rejected by us, or an error has occurred during transaction processing
     *
     * ### configuration.channel=in_app
     *
     * The `in_app` channel is intended for payments done from mobile devices
     * where `url.return_url` can be set to the application's appswitch URL.
     *
     * If the query-param `?initial_recipient=merchant` is appended to the appswitch URL,
     * the payment app will redirect directly to the app, without proxying through Dintero.
     *
     * In that case, the `transaction_id` will be appended to the `return_url`,
     * and you will need to poll [GET /v1/transactions](#operation/transactions_get) with this id
     * until the transaction has been updated with one of these statuses:
     *
     * - AUTHORIZED
     * - CAPTURED
     * - FAILED
     *
     * Example url: `myapp://?initial_recipient=merchant&transaction_id=T12345678.abc&merchant_reference=mref123&session_id=T12345678.abd`
     *
     * @example https://example.com/accept
     */
    return_url: string;
    callback_url?: definitions["CallbackUrl"];
    /**
     * Format: uri
     * @description URL to a webpage with the merchant's Terms of Service. Will be linked to from the checkout.
     *
     * @example https://example.com/terms.html
     */
    merchant_terms_url?: string;
  };
  SessionCustomer: {
    /** @description Customer id */
    customer_id?: string;
    /**
     * @description Customer email address
     *
     * @example john.doe@example.com
     */
    email?: string;
    /**
     * @description Customer phone number, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     *
     * @example +4799999999
     */
    phone_number?: string;
  };
  /** @description Address */
  OrderAddress: {
    /** @example John */
    first_name?: string;
    /** @example Doe */
    last_name?: string;
    /** @description Gaustadalleen 21 */
    address_line?: string;
    /** @description PB 123 */
    address_line_2?: string;
    /** @example Land Lord */
    co_address?: string;
    /** @description Name of the company */
    business_name?: string;
    /**
     * @description The zip code / postal code of the address.
     * @example 0349
     */
    postal_code?: string;
    /**
     * @description The name of the postal code
     * @example Oslo
     */
    postal_place?: string;
    /**
     * Format: iso3166-alpha2
     * @description Country of the location
     * @example NO
     */
    country?: string;
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number?: string;
    /** @description The email address of a person or an organization */
    email?: string;
    latitude?: number;
    longitude?: number;
    /** @description Comment about the address */
    comment?: string;
    /** @description The organization number of the customer. */
    organization_number?: string;
    /** @description Type indicating what kind of organization it is. */
    organization_type?: string;
    /** @description The customer's reference */
    customer_reference?: string;
    /** @description For companies that needs to specify a cost center. */
    cost_center?: string;
  };
  /**
   * @description Specify how fees are handled with splits. The default behaviour is to share
   * the fees proportional with all splits destinations
   */
  PayoutFeeSplit: {
    /** @enum {string} */
    type: "proportional";
    /**
     * @description Seller ids that will be debited for the payment fees
     * All destinations must be included in the list of splits
     */
    destinations?: string[];
  };
  PayoutSplit: {
    /**
     * @description An id that identifies the seller
     *
     * @example P000000001
     */
    payout_destination_id: string;
    /**
     * Format: int32
     * @description The split amount in smalles unit for the currency, e.g. cents.
     *
     * @example 29700
     */
    amount: number;
  };
  /**
   * @description Only required if the item is related to an event or multiple events,
   * like for example tickets to a concert.
   *
   * If you are selling an event package as a single ticket or item that
   * includes multiple events, for example a festival, you need to provide
   * information about all the individual events that are part of the package.
   */
  EmdEvent: {
    /**
     * @description Name of the event, e.g. "Fancy Singer"
     * @example Michael Jackson
     */
    event_name: string;
    /**
     * @description Name of the company arranging the event, e.g. "Happy Parties Ltd."
     * @example Diamond Events
     */
    event_company: string;
    /**
     * @description Category or type of venue, e.g. "Pop"
     * @example Pop
     */
    genre_of_event: string;
    /**
     * @description Name of the venue, e.g. "Song Arena"
     * @example Oslo Spektrum
     */
    arena_name?: string;
    arena_location?: {
      /**
       * @description Street address representing the venue location, e.g. "Sonja Henies plass 2"
       * @example Sonja Henies plass 2
       */
      street_address?: string;
      /**
       * @description Postal code for the venue location, e.g. "0185"
       * @example 0185
       */
      postal_code?: string;
      /**
       * @description City that the venue is located in, e.g. "Oslo"
       * @example Oslo
       */
      city: string;
      /**
       * @description Country that the venue is located in (ISO 3166-1 alpha-2 format), e.g. "NO"
       *
       * @example NO
       */
      country: string;
    };
    /**
     * Format: date-time
     * @description Start time of the event (ISO 8601 format), e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    start_time: string;
    /**
     * Format: date-time
     * @description End time of the event (ISO 8601 format), e.g. "2023-08-16T16:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-16T16:00:00Z
     */
    end_time: string;
    /**
     * @description If tickets are digitally checked when entering the venue, e.g. true
     * @example true
     */
    access_controlled_venue?: boolean;
    /**
     * @example email
     * @enum {string}
     */
    ticket_delivery_method: "pick_up" | "email" | "post" | "phone";
    /**
     * @description Name of the recipient the ticket is delivered to, e.g. "recipient@mail.com".
     *
     * If email or phone, then use either the email address or the phone number respectively.
     *
     * @example recipient@mail.com
     */
    ticket_delivery_recipient: string;
    /**
     * @description Name of the affiliate that originated the purchase.
     *
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  }[];
  /** @description Details related to the subscription. */
  EmdSubscription: {
    /**
     * @description Name of the product on subscription, e.g. "Contact lenses"
     * @example Contact lenses
     */
    subscription_name: string;
    /**
     * Format: date-time
     * @description The start time of the subscription (ISO 8601 format),
     * e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC
     *
     * @example 2023-08-16T15:00:00Z
     */
    start_time: string;
    /**
     * Format: date-time
     * @description The end time of the subscription (ISO 8601 format),
     * e.g. "2023-09-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC
     *
     * @example 2023-09-16T15:00:00Z
     */
    end_time: string;
    /**
     * @description Whether the subscription will be auto renewed upon expiry, e.g. true
     *
     * @example true
     */
    auto_renewal_of_subscription: boolean;
    /**
     * @description Name of the affiliate that originated the purchase.
     *
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  /** @description Information related to the customer that wants to purchase the subscription. */
  EmdCustomerAccountInfo: {
    /**
     * @description Unique name / number to identify the specific customer account.
     * Max 24 characters, e.g. "Adam Adamsson"
     *
     * @example Adam Adamsson
     */
    unique_account_identifier: string;
    /**
     * @description The date and time the account was registered (ISO 8601 format),
     * e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    account_registration_date: string;
    /**
     * @description The date and time the account was last modified (ISO 8601 format),
     * e.g. "2023-10-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-10-16T15:00:00Z
     */
    account_last_modified: string;
  };
  /**
   * @description Only required if the item is related to a subscription.
   *
   * If that is the case, you need to provide information about both the subscription
   * and the customer account.
   */
  EmdRecurring: {
    subscription: definitions["EmdSubscription"];
    customer_account_info: definitions["EmdCustomerAccountInfo"];
  };
  EmdAirReservationDetailsItinerary: {
    /**
     * @description IATA Airport Code (three letters), e.g. "OSL"
     * @example OSL
     */
    departure: string;
    /**
     * @description City the flight departs from, e.g. "Oslo"
     * @example Oslo
     */
    departure_city?: string;
    /**
     * @description IATA Airport Code (three letters), e.g. "MUC"
     * @example MUC
     */
    arrival: string;
    /**
     * @description City the flight arrives in, e.g. "Munich"
     * @example Munich
     */
    arrival_city?: string;
    /**
     * @description IATA Airline standard (two letters or digits), e.g. "LH"
     * @example LH
     */
    carrier: string;
    /**
     * @description Price for that specific segment of the flight
     * in smallest unit of local currency, e.g. 200000
     *
     * @example 200000
     */
    segment_price?: number;
    /**
     * @description Departure date (ISO 8601 format), e.g. "2023-08-16T15:00:00Z"
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    departure_date: string;
    /**
     * @example phone
     * @enum {string}
     */
    ticket_delivery_method: "pick_up" | "email" | "post" | "phone";
    /**
     * @description Name of the recipient the ticket is delivered to, e.g. "Maximilian".
     *
     * If email or phone, then use either the email address or the phone number respectively.
     *
     * @example 97712123
     */
    ticket_delivery_recipient: string;
    /**
     * @description IDs of all the passengers included in this itinerary.
     * @example [
     *   1
     * ]
     */
    passenger_id?: number[];
    /**
     * @description Travel class, e.g. "First Class"
     * @example First Class
     */
    class?: string;
  };
  EmdTravelInsurance: {
    /**
     * @description Name of the company which offers the insurance, e.g. "Oopsie Insurance Ltd."
     * @example Oopsie Insurance Ltd.
     */
    insurance_company?: string;
    /**
     * @description Type of insurance, e.g. "travel"
     * @example travel
     * @enum {string}
     */
    insurance_type?:
      | "cancellation"
      | "travel"
      | "cancellation_travel"
      | "bankruptcy";
    /**
     * @description Price of the insurance in smallest unit of local currency,
     * e.g. 50000
     *
     * @example 50000
     */
    insurance_price?: number;
  };
  EmdTravelPassenger: {
    /**
     * @description Passenger id, e.g. 1
     * @example 1
     */
    id?: number;
    /**
     * @description Passenger title, e.g. "mr".
     *
     * Blank if under 12 years.
     *
     * @example mr
     * @enum {string}
     */
    title?: "mr" | "mrs" | "ms" | "";
    /**
     * @description First name of the passenger, e.g. "Paul"
     * @example Paul
     */
    first_name: string;
    /**
     * @description Last name of the passenger, e.g. "Lamb"
     * @example Lamb
     */
    last_name: string;
  };
  /** @description Details about the reservation of airline tickets. */
  EmdAirReservationDetails: {
    /**
     * @description Trip booking number, e.g. "VH67899"
     *
     * @example VH67899
     */
    pnr?: string;
    /**
     * @description Itinerary data, one per segment.
     *
     * If you are selling a ticket that contains one flight from Oslo to Munich,
     * and another flight from Munich to Dubai, you need to provide one
     * itinerary object for each of these two flights, and so on.
     */
    itinerary: definitions["EmdAirReservationDetailsItinerary"][];
    /** @description Insurance data, one per segment */
    insurance?: definitions["EmdTravelInsurance"][];
    /** @description Passenger data, one per passenger. */
    passengers?: definitions["EmdTravelPassenger"][];
    /**
     * @description Name of the affiliate that originated the purchase.
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  EmdBusReservationDetailsItinerary: {
    /**
     * @description City the bus departs from, e.g. "Oslo"
     * @example Oslo
     */
    departure_city: string;
    /**
     * @description City the bus arrives in, e.g. "Munich"
     * @example Munich
     */
    arrival_city: string;
    /**
     * @description Name of transportation company. "Big Bus Travels Ltd."
     * @example Big Bus Travels Ltd.
     */
    carrier: string;
    /**
     * @description Price for that specific segment of the bus journey
     * in smallest unit of local currency, e.g. 200000
     *
     * @example 200000
     */
    segment_price?: number;
    /**
     * @description Departure date (ISO 8601 format), e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    departure_date: string;
    /**
     * @example phone
     * @enum {string}
     */
    ticket_delivery_method: "pick_up" | "email" | "post" | "phone";
    /**
     * @description Name of the recipient the ticket is delivered to, e.g. "Maximilian".
     *
     * If email or phone, then use either the email address or the phone number respectively.
     *
     * @example 97712123
     */
    ticket_delivery_recipient: string;
    /**
     * @description IDs of all the passengers included in this itinerary.
     * @example [
     *   1
     * ]
     */
    passenger_id?: number[];
    /**
     * @description Travel class, e.g. "First Class"
     * @example First Class
     */
    class?: string;
  };
  /** @description Details about the reservation of bus tickets. */
  EmdBusReservationDetails: {
    /**
     * @description Trip booking number, e.g. "VH67899"
     *
     * @example VH67899
     */
    pnr?: string;
    /**
     * @description Itinerary data, one per segment.
     *
     * If you are selling a ticket that contains one bus journey from Oslo to Munich,
     * and another bus journey from Munich to Rome, you need to provide one
     * itinerary object for each of these two bus journeys, and so on.
     */
    itinerary: definitions["EmdBusReservationDetailsItinerary"][];
    /** @description Insurance data, one per segment */
    insurance?: definitions["EmdTravelInsurance"][];
    /** @description Passenger data, one per passenger. */
    passengers?: definitions["EmdTravelPassenger"][];
    /**
     * @description Name of the affiliate that originated the purchase.
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  EmdTrainReservationDetailsItinerary: {
    /**
     * @description City the train departs from, e.g. "Oslo"
     * @example Oslo
     */
    departure_city: string;
    /**
     * @description City the train arrives in, e.g. "Munich"
     * @example Munich
     */
    arrival_city: string;
    /**
     * @description Name of transportation company. "Big Train Travels Ltd."
     * @example Big Train Travels Ltd.
     */
    carrier: string;
    /**
     * @description Price for that specific segment of the train journey
     * in smallest unit of local currency, e.g. 200000
     *
     * @example 200000
     */
    segment_price?: number;
    /**
     * @description Departure date (ISO 8601 format), e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    departure_date: string;
    /**
     * @example phone
     * @enum {string}
     */
    ticket_delivery_method: "pick_up" | "email" | "post" | "phone";
    /**
     * @description Name of the recipient the ticket is delivered to, e.g. "Maximilian".
     *
     * If email or phone, then use either the email address or the phone number respectively.
     *
     * @example 97712123
     */
    ticket_delivery_recipient: string;
    /**
     * @description IDs of all the passengers included in this itinerary.
     * @example [
     *   1
     * ]
     */
    passenger_id: number[];
    /**
     * @description Travel class, e.g. "First Class"
     * @example First Class
     */
    class?: string;
  };
  /** @description Details about the reservation of train tickets. */
  EmdTrainReservationDetails: {
    /**
     * @description Trip booking number, e.g. "VH67899"
     *
     * @example VH67899
     */
    pnr?: string;
    /**
     * @description Itinerary data, one per segment.
     *
     * If you are selling a ticket that contains one train journey from Oslo to Munich,
     * and another train journey from Munich to Rome, you need to provide one
     * itinerary object for each of these two train journeys, and so on.
     */
    itinerary: definitions["EmdTrainReservationDetailsItinerary"][];
    /** @description Insurance data, one per segment */
    insurance?: definitions["EmdTravelInsurance"][];
    /** @description Passenger data, one per passenger. */
    passengers?: definitions["EmdTravelPassenger"][];
    /**
     * @description Name of the affiliate that originated the purchase.
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  EmdFerryReservationDetailsItinerary: {
    /**
     * @description City the ferry departs from, e.g. "Oslo"
     * @example Oslo
     */
    departure_city: string;
    /**
     * @description City the ferry arrives in, e.g. "Munich"
     * @example Munich
     */
    arrival_city: string;
    /**
     * @description Name of transportation company. "Big Ferry Travels Ltd."
     * @example Big Ferry Travels Ltd.
     */
    carrier: string;
    /**
     * @description Price for that specific segment of the ferry journey
     * in smallest unit of local currency, e.g. 200000
     *
     * @example 200000
     */
    segment_price?: number;
    /**
     * @description Departure date (ISO 8601 format), e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    departure_date: string;
    /**
     * @example phone
     * @enum {string}
     */
    ticket_delivery_method: "pick_up" | "email" | "post" | "phone";
    /**
     * @description Name of the recipient the ticket is delivered to, e.g. "Maximilian".
     *
     * If email or phone, then use either the email address or the phone number respectively.
     *
     * @example 97712123
     */
    ticket_delivery_recipient: string;
    /**
     * @description IDs of all the passengers included in this itinerary.
     * @example [
     *   1
     * ]
     */
    passenger_id?: number[];
    /**
     * @description Travel class, e.g. "First Class"
     * @example First Class
     */
    class?: string;
  };
  /** @description Details about the reservation of ferry tickets. */
  EmdFerryReservationDetails: {
    /**
     * @description Trip booking number, e.g. "VH67899"
     *
     * @example VH67899
     */
    pnr?: string;
    /**
     * @description Itinerary data, one per segment.
     *
     * If you are selling a ticket that contains one ferry journey from Oslo to Kiel,
     * and another ferry journey from Kiel to Gothenburg, you need to provide one
     * itinerary object for each of these two ferry journeys, and so on.
     */
    itinerary: definitions["EmdFerryReservationDetailsItinerary"][];
    /** @description Insurance data, one per segment */
    insurance?: definitions["EmdTravelInsurance"][];
    /** @description Passenger data, one per passenger. */
    passengers?: definitions["EmdTravelPassenger"][];
    /**
     * @description Name of the affiliate that originated the purchase.
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  EmdHotelReservationDetailsItinerary: {
    /**
     * @description Name of the hotel, e.g. "Premium Hotel"
     * @example Premium Hotel
     */
    hotel_name?: string;
    /** @description Address details of the hotel. */
    address?: {
      /**
       * @description Street address of the hotel, e.g. "Karl Johans gt. 31"
       * @example Karl Johans gt. 31
       */
      street_address?: string;
      /**
       * @description Postal code of the hotel, e.g. "0159"
       * @example 0159
       */
      postal_code?: string;
      /**
       * @description City the hotel is located in, e.g. "Oslo"
       * @example Oslo
       */
      city: string;
      /**
       * @description Country the hotel is located in (ISO 3166-1 alpha-2 format), e.g. "NO",
       *
       * @example NO
       */
      country: string;
    };
    /**
     * @description Start time of the hotel stay (ISO 8601 format), e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    start_time: string;
    /**
     * @description End time of the hotel stay (ISO 8601 format), e.g. "2023-08-20T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-20T15:00:00Z
     */
    end_time: string;
    /**
     * @description Number of rooms booked, e.g. 2
     * @example 2
     */
    number_of_rooms: number;
    /**
     * @description IDs of all the passengers included in this itinerary.
     * @example [
     *   1
     * ]
     */
    passenger_id: number[];
    /**
     * @example phone
     * @enum {string}
     */
    ticket_delivery_method: "pick_up" | "email" | "post" | "phone";
    /**
     * @description Name of the recipient the ticket is delivered to, e.g. "Maximilian".
     *
     * If email or phone, then use either the email address or the phone number respectively.
     *
     * @example 97712123
     */
    ticket_delivery_recipient: string;
    /**
     * @description Price for the hotel stay in smallest unit of local currency, e.g. 200000
     *
     * @example 200000
     */
    hotel_price: number;
    /**
     * @description Travel class, e.g. "First Class"
     * @example First Class
     */
    class?: string;
  };
  /** @description Details about the reservation of hotel rooms. */
  EmdHotelReservationDetails: {
    /**
     * @description Trip booking number, e.g. "VH67899"
     *
     * @example VH67899
     */
    pnr?: string;
    /**
     * @description Hotel itinerary data, one per hotel stay.
     *
     * If you are selling a package that contains multiple hotel stays,
     * you need to provide itinerary data for each of the individual stays.
     */
    itinerary: definitions["EmdHotelReservationDetailsItinerary"][];
    /** @description Insurance data, one per segment */
    insurance?: definitions["EmdTravelInsurance"][];
    /** @description Passenger data, one per passenger. */
    passengers?: definitions["EmdTravelPassenger"][];
    /**
     * @description Name of the affiliate that originated the purchase.
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  EmdCarRentalReservationDetailsItinerary: {
    /**
     * @description Name of the car rental company, e.g. "Premium Cars Ltd."
     * @example Premium Cars
     */
    rental_company: string;
    /**
     * @description Driver IDs.
     * @example [
     *   1
     * ]
     */
    drivers_id?: number[];
    /** @description Details related to the pick up location. */
    pick_up_location?: {
      /**
       * @description Street address where the car should be picked up, e.g. "Karl Johans gt. 31"
       * @example Karl Johans gt. 31
       */
      street_address?: string;
      /**
       * @description Postal code where the car should be picked up, e.g. "0159"
       * @example 0159
       */
      postal_code?: string;
      /**
       * @description City where the car should be picked up, e.g. "Oslo"
       * @example Oslo
       */
      city: string;
      /**
       * @description Country where the car should be picked up (ISO 3166-1 alpha-2 format), e.g. "NO",
       *
       * @example NO
       */
      country: string;
    };
    /** @description Details related to the drop off location. */
    drop_off_location?: {
      /**
       * @description Street address where the car should be dropped off, e.g. "Karl Johans gt. 31"
       * @example Karl Johans gt. 31
       */
      street_address?: string;
      /**
       * @description Postal code where the car should be dropped off, e.g. "0159"
       * @example 0159
       */
      postal_code?: string;
      /**
       * @description City where the car should be dropped off, e.g. "Oslo"
       * @example Oslo
       */
      city: string;
      /**
       * @description Country where the car should be dropped off (ISO 3166-1 alpha-2 format), e.g. "NO"
       *
       * @example NO
       */
      country: string;
    };
    /**
     * @description Start time of the car rental reservation (ISO 8601 format), e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    start_time: string;
    /**
     * @description End time of the car rental reservation (ISO 8601 format), e.g. "2023-08-20T15:00:00Z".
     *
     * If a timezone is not specified, we assume UTC.
     *
     * @example 2023-08-20T15:00:00Z
     */
    end_time: string;
    /**
     * @description Price for the car rental reservation in smallest unit of local currency, e.g. 500000
     *
     * @example 500000
     */
    car_price?: number;
    /**
     * @description Travel class, e.g. "Premium Cars Premium Class"
     * @example Premium Cars Premium Class
     */
    class?: string;
  };
  /** @description Details about the reservation of rental cars. */
  EmdCarRentalReservationDetails: {
    /**
     * @description Trip booking number, e.g. "VH67899"
     *
     * @example VH67899
     */
    pnr?: string;
    /**
     * @description Car rental itinerary data, one per car rental.
     *
     * If you are selling a package that contains multiple car rentals,
     * you need to provide itinerary data for each of the individual rentals.
     */
    itinerary: definitions["EmdCarRentalReservationDetailsItinerary"][];
    /** @description Insurance data, one per segment */
    insurance?: definitions["EmdTravelInsurance"][];
    /** @description Driver data, one per driver. */
    drivers: definitions["EmdTravelPassenger"][];
    /**
     * @description Name of the affiliate that originated the purchase.
     * @example Klarna affiliate
     */
    affiliate_name?: string;
  };
  /**
   * @description Only required if the item is part of a travel-related transaction.
   *
   * If that is the case, you need to provide information about the itinerary
   * to be booked.
   */
  EmdTravel: {
    air_reservation_details?: definitions["EmdAirReservationDetails"];
    bus_reservation_details?: definitions["EmdBusReservationDetails"];
    train_reservation_details?: definitions["EmdTrainReservationDetails"];
    ferry_reservation_details?: definitions["EmdFerryReservationDetails"];
    hotel_reservation_details?: definitions["EmdHotelReservationDetails"];
    car_rental_reservation_details?: definitions["EmdCarRentalReservationDetails"];
  };
  EmdMarketplaceAccountLastModified: {
    /**
     * Format: date-time
     * @description Date and time that the password was last modified (ISO 8601 format),
     * e.g. "2023-08-17T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-17T15:00:00Z
     */
    password: string;
    /**
     * Format: date-time
     * @description Date and time that the email was last modified (ISO 8601 format),
     * e.g. "2023-08-17T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-17T15:00:00Z
     */
    email: string;
    /**
     * Format: date-time
     * @description Date and time that the listing details were last modified (ISO 8601 format),
     * e.g. "2023-08-17T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-17T15:00:00Z
     */
    listing: string;
    /**
     * Format: date-time
     * @description Date and time that the login details were last changed (ISO 8601 format),
     * e.g. "2023-08-17T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-17T15:00:00Z
     */
    login: string;
    /**
     * Format: date-time
     * @description Date and time that the (physical) address was last modified (ISO 8601 format),
     * e.g. "2023-08-17T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-17T15:00:00Z
     */
    address: string;
  };
  /** @description Details related to the seller involved in the marketplace order. */
  EmdMarketplaceSellerInfo: {
    /** @description Details about the seller. */
    unique_account_identifier_seller?: {
      /** @description Seller's email address, e.g. "seller@mail.com" */
      email?: string;
      /**
       * @description Seller's phone number, e.g. "97712123"
       * @example 97712123
       */
      phone_number?: string;
      other?: string;
    };
    /**
     * @description Name or unique number of the selling/delivering merchant,
     * e.g. "Marketbrick Ltd."
     *
     * @example Marketbrick Ltd.
     */
    sub_merchant_id: string;
    /**
     * @description Name of the category to which the specific good belongs to,
     * according to the selling merchant's categorization, e.g. "Phones".
     *
     * @example Phones
     */
    product_category: string;
    /**
     * @description Name of the good purchased.
     *
     * @example iPhone 14 Pro Max
     */
    product_name?: string;
    /**
     * Format: date-time
     * @description Date and time that the account was registered (ISO 8601 format),
     * e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    account_registration_date: string;
    account_last_modified: definitions["EmdMarketplaceAccountLastModified"];
    /**
     * @description Current rating of the good purchased according
     * to the marketplace's rating scale, e.g. 5
     *
     * @example 5
     */
    seller_rating?: number;
    /**
     * @description Number of trades the sub-merchant did in the last 12 months, e.g. 23
     *
     * @example 23
     */
    number_of_trades: number;
    /**
     * @description Volumes of trades the sub-merchant did in the last 12 months,
     * e.g. 230
     *
     * @example 230
     */
    volume_of_trades?: number;
  };
  /** @description Details related to the winner involved in the marketplace order. */
  EmdMarketplaceWinnerInfo: {
    /** @description Details about the winner. */
    unique_account_identifier_winner?: {
      /** @description Winner's email address, e.g. "winner@mail.com" */
      email?: string;
      /**
       * @description Winner's phone number, e.g. "97712123"
       * @example 97712123
       */
      phone_number?: string;
      other?: string;
    };
    /**
     * Format: date-time
     * @description Date and time that the account was registered (ISO 8601 format),
     * e.g. "2023-08-16T15:00:00Z".
     *
     * If a timezone is not specified we assume UTC.
     *
     * @example 2023-08-16T15:00:00Z
     */
    account_registration_date: string;
    account_last_modified: definitions["EmdMarketplaceAccountLastModified"];
    /**
     * @description Number of trades the winner did in the last 12 months, e.g. 23
     *
     * @example 23
     */
    number_of_trades: number;
    /**
     * @description Volumes of trades the winner did in the last 12 months,
     * e.g. 230
     *
     * @example 230
     */
    volume_of_trades?: number;
  };
  /**
   * @description Only required if them item is related to a marketplace order.
   *
   * If that is the case, you need to provide information about both the seller and
   * the winner.
   */
  EmdMarketplaceOrder: {
    seller_info: definitions["EmdMarketplaceSellerInfo"];
    winner_info: definitions["EmdMarketplaceWinnerInfo"];
  };
  /**
   * @description Details related to [Klarna EMD](https://docs.klarna.com/klarna-payments/in-depth-knowledge/extra-merchant-data/).
   *
   * Some items require extra information to be provided when using
   * Klarna as an enabled payment option.
   */
  Emd: {
    event?: definitions["EmdEvent"];
    subscription?: definitions["EmdRecurring"];
    travel?: definitions["EmdTravel"];
    marketplace_order?: definitions["EmdMarketplaceOrder"];
  };
  /** @description details about order item */
  OrderItem: {
    /**
     * @description The ID or SKU of the product on the line
     *
     * @example item_01
     */
    id?: string;
    /**
     * @description The groups the product on the line belongs to
     *
     * @example [
     *   {
     *     "id": "B234",
     *     "name": "Stol"
     *   }
     * ]
     */
    groups?: {
      /** @description Group ID */
      id: string;
      /** @description Group name */
      name?: string;
    }[];
    /**
     * @description the number of the line (or id), must be `unique` between
     * all items. `required` when Instabank payment is configured.
     *
     * @example 1
     */
    line_id?: string;
    /**
     * @description The version where the item was added or last updated, see the
     * events for the source.
     */
    version?: number;
    /**
     * @description A short, localized description of the line item
     *
     * @example Stablestol
     */
    description?: string;
    /**
     * @description The quantity of the product in the item line.
     *
     * @example 1
     */
    quantity?: number;
    /**
     * @description The total monetary amount of the line item, including VAT and discounts.
     *
     * In smallest unit for the currency, e.g. cents
     *
     * @example 2000
     */
    amount?: number;
    /**
     * @description The VAT of the `amount` parameter. Only
     * used for display purposes.
     *
     * In smallest unit for the currency, e.g. cents
     *
     * @example 400
     */
    vat_amount?: number;
    /**
     * @description The VAT percentage
     *
     * @example 20
     */
    vat?: number;
    /** @description The volume of one item in m³ (cubic meters) */
    unit_volume?: number;
    /** @description The volume of one item in kg (kilo grams) */
    unit_weight?: number;
    /** @description The dimensional weight (also known as volumetric) value unit of one item. [Dimensional weight at Wikipedia](https://en.wikipedia.org/wiki/Dimensional_weight) */
    unit_dimensional_weight?: number;
    /**
     * @description The type of order item this is.
     *
     * - **physical** - a physical item which must be delivered or handed over
     * - **digital** - a digital item which doesn't need shipping
     * - **service** - payment for services like maintenance performed in your home
     * - **gift_card** - usage of a gift card, where the amount is usually a negative number
     * - **shipping** - payment for shipping of the order
     * - **surcharge** - extra incurred costs, like taxes or necessary rounding
     *
     * @enum {string}
     */
    type?:
      | "physical"
      | "digital"
      | "service"
      | "gift_card"
      | "shipping"
      | "surcharge";
    fee_split?: definitions["PayoutFeeSplit"];
    /**
     * @description An array of objects specifying how the amount should be split between
     * sellers when using Dintero Payout
     *
     * Specify an empty array if the splits will be provided during capture.
     * `auto_capture` cannot be enabled when splits are defined as empty array.
     */
    splits?: definitions["PayoutSplit"][];
    /**
     * Format: uri
     * @description URL to a thumbnail of the item. Will be displayed when redirecting to the session.
     *
     * Recommended limitations for the image:
     *
     * - all images should preferrably have the same dimensions
     * - max file size should be less than 2MB
     */
    thumbnail_url?: string;
    emd?: definitions["Emd"];
  };
  /** @enum {string} */
  DiscountType:
    | "customer"
    | "periodic"
    | "manual"
    | "loyalty"
    | "total"
    | "employee"
    | "external";
  DiscountItem: {
    /**
     * @description Monetary amount in smallest unit for the currency
     *
     * @example 4400
     */
    amount?: number;
    /**
     * @description Optional, set if the amount given was from a percentage discount
     *
     * @example 44
     */
    percentage?: number;
    discount_type?: definitions["DiscountType"];
    /** @example 766da0ef-9283-42bd-b012-0582344ec53c */
    discount_id?: string;
    description?: string;
    /** @example 1 */
    line_id?: number;
  };
  /** @description Discount details for an order item */
  OrderDiscountItem: {
    /**
     * @description The item is eligible for discount
     *
     * @default false
     * @example true
     */
    eligible_for_discount?: boolean;
    /** @description Discount applied to amount */
    is_changed?: boolean;
    /** @description The origin item amount before any discount */
    gross_amount?: number;
    discount_lines?: definitions["DiscountItem"][];
  };
  /** @description A shipping option */
  ShippingOption: {
    /**
     * @description Id of this shipping option product.
     *
     * The express checkout will group all products with the same id. Used for
     * grouping delivery to the same address at different time slots, or for
     * grouping deliveries to different pick up points.
     *
     * @example bring-pick-up-00001
     */
    id: string;
    /**
     * @description Unique id of the specific configuration of this shipping product
     *
     * @example bring-pick-up-00001-location-0a1f6b
     */
    line_id: string;
    /** @description Countries where this shipping option can be used */
    countries?: string[];
    /**
     * @description The monetary amount of the shipping option, including VAT and discounts.
     *
     * In smallest unit for the currency, e.g. cents
     *
     * @example 3900
     */
    amount: number;
    /**
     * @description The VAT of the `amount` parameter. Only
     * used for display purposes.
     *
     * @example 975
     */
    vat_amount?: number;
    /**
     * @description The VAT percentage
     *
     * @example 25
     */
    vat?: number;
    /**
     * @description A shipping option title. Eg. "Standard"
     *
     * @example Standard
     */
    title: string;
    /**
     * @description A short description of the shipping option product
     *
     * @example Pick up at your nearest postal office
     */
    description?: string;
    /**
     * @example pick_up
     * @enum {string}
     */
    delivery_method?: "delivery" | "pick_up" | "unspecified" | "none";
    /**
     * @description Name of company that provides shipping service
     *
     * @example Bring
     */
    operator: string;
    /**
     * @description The operators own id for this shipping product
     *
     * @example pick-up-00001-location-0a1f6b
     */
    operator_product_id?: string;
    /** @description Estimated time of arrival */
    eta?: {
      /**
       * Format: date-time
       * @example 2020-10-14T19:00:00Z
       */
      starts_at?: string;
      /**
       * Format: date-time
       * @example 2020-10-14T20:00:00Z
       */
      ends_at?: string;
    };
    /** @description A specified time for delivery to customer */
    time_slot?: {
      /**
       * Format: date-time
       * @example 2020-10-14T19:00:00Z
       */
      starts_at?: string;
      /**
       * Format: date-time
       * @example 2020-10-14T20:00:00Z
       */
      ends_at?: string;
    };
    pick_up_address?: definitions["OrderAddress"] & {
      /** @description Distance in kilometers from the shipping_address. */
      distance?: number;
    };
    /**
     * @description Additional metadata about the shipping_option
     * @example {
     *   "operator_dest": "XAB1239",
     *   "number_x": 1921
     * }
     */
    metadata?: { [key: string]: unknown };
    /** @description Environmental data about the shipping option */
    environmental_data?: {
      /**
       * @description A short description of the environmental data, something like
       * - "Fossil free",
       * - "Carbon neutral"
       * - "Low emissions"
       * - "Renewable Energy Sourced"
       * - "Eco-certified Fleet"
       *
       * @example Fossil free
       */
      description: string;
      details?: {
        /**
         * @description Give context to the value field. Example:
         * - "CO2 emissions"
         * - "Energy consumption"
         * - "Carbon footprint"
         * - "Carbon offset"
         * - "Trees planted"
         * - "Renewable energy percentage"
         *
         * @example Carbon offset
         */
        label: string;
        /** @example 1KG CO2 */
        value: string;
      }[];
    };
  };
  SplitShippingOption: definitions["ShippingOption"] & {
    fee_split?: definitions["PayoutFeeSplit"];
    /**
     * @description An array of objects specifying how the amount should be split between
     * sellers when using Dintero Payout
     *
     * Specify an empty array if the splits will be provided during capture.
     * `auto_capture` cannot be enabled when splits are defined as empty array.
     */
    splits?: definitions["PayoutSplit"][];
  };
  Address: {
    /** @example Sommerkroveien 34 */
    address_line: string;
    /** @example PB 123 */
    address_line_2?: string;
    /** @example 0349 */
    postal_code?: string;
    /** @example Oslo */
    postal_place: string;
    /**
     * Format: iso-3166-1
     * @description ISO 3166-1 country code
     *
     * @example NO
     */
    country: string;
  };
  Store: {
    /** @example sc029 */
    id: string;
    /**
     * @description name of the store, aka trade name of the store
     *
     * @example SC Oslo
     */
    name?: string;
    /**
     * @description Official name of the person or entity that owns the store.
     *
     * @example SC Oslo AS
     */
    business_name?: string;
    address?: definitions["Address"];
    /** @example SuperChain */
    chain?: string;
    /** @example contact@superchain.com */
    email?: string;
    /** @example 5790001398644 */
    gln?: string;
    /** @example 123456789MVA */
    organization_number?: string;
    /** @example +4738260107 */
    phone_number?: string;
    /**
     * Format: iso-18245
     * @description A four-digit Merchant Category Code (MCC) for the store
     * [ISO 18245:2003](https://www.iso.org/standard/33365.html)
     *
     * @example 5814
     */
    mcc?: string;
    /**
     * @description Merchant number associated with the stores
     * payment terminal
     *
     * @example 102603
     */
    bax?: string;
    /**
     * @description Id to a specific point-of-sale (POS) terminal
     * or workstation
     *
     * @example T0292
     */
    terminal_id?: string;
  };
  SessionOrderUpdate: {
    /**
     * Format: int32
     * @description The amount to authorize/capture including VAT and discounts.
     * In smallest unit for the currency, e.g. cents
     *
     * The `amount` should be equal to the sum of the `items.amount` + `shipping_option.amount`.
     *
     * @example 72200
     */
    amount?: number;
    /**
     * Format: iso4217-code
     * @description The three-character ISO-4217 currency. https://en.wikipedia.org/wiki/ISO_4217
     * @example NOK
     */
    currency?: string;
    /**
     * Format: int32
     * @description The VAT of the `amount` parameter.
     * Only used for display purposes.
     *
     * In smallest unit for the currency, e.g. cents
     *
     * The `vat_amount` should be equal to the sum of the `items.vat_amount` + `shipping_option.vat_amount`.
     *
     * @example 13660
     */
    vat_amount?: number;
    /**
     * @description A reference by the merchant to identify the corresponding
     * order for the Checkout Session
     */
    merchant_reference_2?: string;
    shipping_address?: definitions["OrderAddress"];
    billing_address?: definitions["OrderAddress"];
    /**
     * @description This is a partial payment where the `order.amount` can be lower or
     * equal to the sum of `order.items.amount`
     *
     * @default false
     */
    partial_payment?: boolean;
    /**
     * @description Details about the order items.
     *
     * #### Instabank
     * `required` if Instabank payment is configured in and partial_payment is false.
     * All items must include a unique `line_id`, quantity and amount
     *
     * #### Collector Bank
     * `required` if Collector Bank payment is configured in and partial_payment is false.
     * All items must include a unique `line_id`, quantity and amount
     *
     * @example [
     *   {
     *     "amount": 2000,
     *     "quantity": 2,
     *     "line_id": "1",
     *     "description": "Forsvinnignspølse",
     *     "vat": 20,
     *     "id": "10"
     *   },
     *   {
     *     "amount": 6600,
     *     "quantity": 2,
     *     "line_id": "2",
     *     "description": "Vissvossafår på neppebrød",
     *     "vat": 20,
     *     "id": "6",
     *     "eligible_for_discount": true,
     *     "is_changed": true,
     *     "gross_amount": 10000,
     *     "discount_lines": [
     *       {
     *         "amount": 4400,
     *         "discount_type": "customer",
     *         "discount_id": "ed960ace-eb16-4e2e-ae52-b27647ccae8d",
     *         "description": "Vossafestpris",
     *         "line_id": 1
     *       }
     *     ]
     *   },
     *   {
     *     "amount": 59700,
     *     "quantity": 3,
     *     "line_id": "3",
     *     "description": "Luftboller",
     *     "vat": 20,
     *     "id": "1"
     *   }
     * ]
     */
    items?: (definitions["OrderItem"] & definitions["OrderDiscountItem"])[];
    /**
     * @description The origin amount to authorize/capture including VAT
     * before any discount, only set if the session was updated
     * when calculating discounts.
     *
     * In smallest unit for the currency, e.g. cents
     */
    gross_amount?: number;
    /**
     * @description The original order amount was changed by discount
     * given.
     */
    is_changed?: boolean;
    shipping_option?: definitions["SplitShippingOption"];
    store?: definitions["Store"];
    /** @description Discounts given, additions to any items discount_lines. */
    discount_lines?: definitions["DiscountItem"][];
    discount_codes?: string[];
  };
  SessionOrder: definitions["SessionOrderUpdate"] & {
    /**
     * @description An id that identifies the seller, value will be included
     * in the settlement reports
     */
    payout_destination_id?: string;
    /**
     * @description A reference by the merchant to identify the corresponding
     * order for the Checkout Session
     */
    merchant_reference: string;
  } & {
    amount: unknown;
    currency: unknown;
  };
  Checkbox: {
    /** @description ID to assign to the checkbox so you can reference it later */
    id: string;
    /** @description Label that should be visible next to the checkbox */
    label: string;
    /** @description If the checkbox should be checked by default or not */
    checked?: boolean;
    /** @description If the checkbox should be required or not */
    required?: boolean;
    link?: {
      /** @description Link URL */
      url: string;
      /**
       * @description Link text
       * @example Terms for checkbox action
       */
      text: string;
    };
  };
  /** @description Configuration for checkboxes that should be part of the checkout */
  CheckboxConfiguration: definitions["Checkbox"][];
  SessionBase: {
    url: definitions["SessionUrls"];
    customer?: definitions["SessionCustomer"];
    order: definitions["SessionOrder"];
    /** Format: date-time */
    expires_at?: string;
    checkboxes?: definitions["CheckboxConfiguration"];
  };
  /** @description Enable customer payment tokens in the session */
  SessionCustomerTokens: {
    customer?: {
      tokens?: {
        "bambora.creditcard"?: {
          /**
           * @description Preload the store payment data related to the payment
           * token and let the customer make a purchase without having
           * to enter all card data
           *
           * - The `bambora.creditcard` must be enabled in the session
           *   configuration to activate the use of provided payment token
           * - Use the `bambora.creditcard.generate_payment_token` option to
           *   generate the token.
           */
          payment_token?: string;
          /**
           * @description Preload the store payment data related to the recurrence
           * token and let the customer make a purchase without having
           * to enter all card data
           *
           * - The `bambora.creditcard` must be enabled in the session
           *   configuration to activate the use of provided payment token
           * - Use the `bambora.creditcard.generate_recurrence_token` option to
           *   generate the token.
           */
          recurrence_token?: string;
        };
        "payex.creditcard"?: {
          /**
           * @description Preload the store payment data related to the payment
           * token and let the customer make a purchase without having
           * to enter all card data
           *
           * - The `payex.creditcard` must be enabled in the session
           *   configuration to activate the use of provided payment token
           * - Use the `payex.creditcard.generate_payment_token` option to
           *   generate the token.
           */
          payment_token?: string;
          /**
           * @description Preload the store payment data related to the recurrence
           * token and let the customer make a purchase without having
           * to enter all card data
           *
           * - The `payex.creditcard` must be enabled in the session
           *   configuration to activate the use of provided payment token
           * - Use the `payex.creditcard.generate_recurrence_token` option to
           *   generate the token.
           */
          recurrence_token?: string;
        };
      };
    };
  };
  AutoCaptureConfiguration: {
    /**
     * @description If `true` the transaction from the payment session will be captured
     * automatically after the transaction has been `AUTHORIZED`. The checkout
     * sessions `callback_url` will not be called until after the transaction
     * has been `CAPTURED`.
     *
     * If `auto_capture` is not specified it defaults to `false`.
     *
     * A successful auto-capture of a transaction sometimes requires more
     * than one capture attempt. This can be the case if the payment gateway
     * is down or is experiencing heavy traffic.
     *
     * Dintero will attempts capture retries for 48 hours, the `callback_url`
     * will be invoked when capture succeeds.
     *
     * Manual capture of a transaction that is pending auto-capture will
     * stop the auto-capture process from completing the capture.
     */
    auto_capture?: boolean;
  };
  /** @description Publish checkout message to the customer. */
  PublishConfiguration: {
    /** @enum {string} */
    channel: "sms" | "push";
    /** @enum {string} */
    type: "checkout-link" | "app";
    id?: string;
    /**
     * @description status of the message sent to the customer.
     *
     * **`skipped`** will used in case where publish
     * cannot be sent given the `session.customer`.
     *
     * @enum {string}
     */
    status?: "sent" | "skipped" | "failed";
  }[];
  /**
   * @description Determines if the payment_product_type is currently available for payment
   * @enum {string}
   */
  SessionPayability:
    | "payable"
    | "disabled_by_gateway"
    | "disabled_by_order_amount";
  /** @description Bambora configuration */
  BamboraConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {string}
     */
    type?: "payment_type";
    creditcard?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Credit Card Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      /**
       * @description generate payment token to use for future payments
       *
       * The generated payment token will be made available from
       * the transaction details.
       *
       * @default false
       */
      generate_payment_token?: boolean;
      /**
       * @description generate recurrence payment token to use for future payments
       *
       * The generated recurrence payment token will be made available from
       * the transaction details.
       *
       * @default false
       */
      generate_recurrence_token?: boolean;
    };
    mobilepay?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable MobilePay Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    vipps?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Vipps Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
  };
  /** @description Dintero configuration */
  DinteroConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {string}
     */
    type?: "payment_type";
    /**
     * @description Allow the payment session to be fully or partial authorized with
     * Dintero Wallets gift card.
     */
    wallets?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable gift card */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    /**
     * @description Allow initiating pay on zero amount session, the payability will only
     * be enabled if the session order amount is zero. Initiating a `dintero.zero`
     * payment will result in a transaction with `dintero.zero` payment product type
     * that will be excluded from settlement reports (as it will not have any payout)
     */
    zero?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable zero amount session */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
  };
  /** @description Dintero PSP configuration */
  DinteroPspConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {string}
     */
    type?: "payment_type";
    creditcard?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable creditcard */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
  };
  InstabankFinanceProduct: {
    /** @example 630 */
    product_code: string;
    /**
     * Format: ^([0-9]*[.])?[0-9]+$
     * @description The minimum monthly installment basis as a percentage of the account balance.
     *
     * @example 1.67
     */
    minimum_monthly_balance_rate: string;
    /**
     * Format: ^([0-9]*[.])?[0-9]+$
     * @description The interest rate for the payment product.
     *
     * @example 0.0
     */
    annual_interest_rate?: string;
    /**
     * @description The effective annual interest rate for the payment product
     *
     * @example 0.0
     */
    effective_annual_interest_rate?: string;
    /**
     * @description The startup fee for the payment product.
     *
     * @example 9500
     */
    origination_fee: number;
    /**
     * @description The notification fee for the payment product.
     *
     * @example 3900
     */
    notification_fee: number;
    /**
     * @description Minimum order amount for this product. The product option will be
     * excluded in payments where the order amount is less than the minimum
     * amount.
     *
     * @example 20000
     */
    minimum_amount?: number;
    loan_example: {
      /**
       * @description The amount loaned in the example.
       *
       * @example 2500000
       */
      amount: number;
      /**
       * @description Years of payment in the example.
       *
       * @example 1
       */
      years: number;
      /**
       * @description The total amount paid back in the example.
       *
       * @example 2772300
       */
      total_amount: number;
      /**
       * @description The cost of the loan in the example.
       *
       * @example 272300
       */
      cost: number;
      /**
       * Format: ^([0-9]*[.])?[0-9]+$
       * @description The effective annual interest rate in the example
       *
       * @example 21.38
       */
      effective_annual_interest_rate: string;
    };
    /** @description Url for a custom branding image */
    branding_image_url?: string;
  };
  InstabankInvoiceProduct: {
    /** @example 632 */
    product_code: string;
    /**
     * @description Number of days before the payment is due.
     * @example 10
     */
    due_in_days: number;
    /**
     * @description Minimum order amount for this product. The product option will be
     * excluded in payments where the order amount is less than the minimum
     * amount.
     *
     * @example 20000
     */
    minimum_amount?: number;
    /**
     * @description The fee for the payment product
     *
     * @example 9500
     */
    invoice_fee: number;
    /**
     * @description The limit for when instabank will require a full applicant during payment.
     *
     * @example 7500000
     */
    require_applicant_amount: number;
    /** @description Url for a custom branding image */
    branding_image_url?: string;
  };
  /** @description Payment product configuration */
  InstabankInstallmentProduct: {
    /**
     * @description Minimum order amount for this product. The product option will be
     * excluded in payments where the order amount is less than the minimum
     * amount.
     *
     * @example 20000
     */
    minimum_amount?: number;
    /** @example 633 */
    product_code: string;
    /**
     * @description Number of months
     *
     * @example 36
     */
    credit_time: number;
    /**
     * @description The startup fee for the payment product
     *
     * @example 9500
     */
    origination_fee: number;
    /**
     * @description The notification fee for the payment product
     *
     * @example 3900
     */
    notification_fee: number;
    /**
     * Format: ^([0-9]*[.])?[0-9]+$
     * @description The interest rate for the payment product.
     *
     * @example 0.0
     */
    annual_interest_rate: string;
    /**
     * @description The effective annual interest rate for the payment product
     *
     * @example 54.69
     */
    effective_annual_interest_rate?: string;
    /**
     * @description The total amount to pay
     * @example 309400
     */
    total_amount?: number;
    /**
     * @description The amount to pay pr month
     * @example 100000
     */
    monthly_amount?: number;
    /**
     * @description The amount to pay in the first invoice. Origantion fee is added
     * to the first invoice.
     *
     * @example 109500
     */
    first_monthly_amount?: number;
    /**
     * @description The limit for when instabank will require a full applicant during payment.
     *
     * @example 2500000
     */
    require_applicant_amount?: number;
    loan_example?: {
      /**
       * @description The amount loaned in the example.
       *
       * @example 2500000
       */
      amount: number;
      /**
       * @description Years of payment in the example.
       *
       * @example 1
       */
      years: number;
      /**
       * @description The total amount paid back in the example.
       *
       * @example 2772300
       */
      total_amount: number;
      /**
       * @description The cost of the loan in the example.
       *
       * @example 272300
       */
      cost: number;
      /**
       * Format: ^([0-9]*[.])?[0-9]+$
       * @description The effective annual interest rate in the example
       *
       * @example 21.38
       */
      effective_annual_interest_rate: string;
    };
    /** @description Url for a custom branding image */
    branding_image_url?: string;
  };
  /** @description Payment product configuration */
  InstabankPostponementProduct: {
    /**
     * @description Minimum order amount for this product. The product option will be
     * excluded in payments where the order amount is less than the minimum
     * amount.
     *
     * @example 20000
     */
    minimum_amount?: number;
    /** @example 633 */
    product_code: string;
    /**
     * @description Number of months
     *
     * @example 36
     */
    postponement_months: number;
    /**
     * @description The startup fee for the payment product
     *
     * @example 9500
     */
    origination_fee: number;
    /**
     * @description The notification fee for the payment product
     *
     * @example 3900
     */
    notification_fee?: number;
    /**
     * Format: ^([0-9]*[.])?[0-9]+$
     * @description The interest rate for the payment product.
     *
     * @example 0.0
     */
    annual_interest_rate: string;
    /**
     * @description The effective annual interest rate for the payment product
     *
     * @example 54.69
     */
    effective_annual_interest_rate?: string;
    /**
     * @description The total amount to pay
     * @example 309400
     */
    total_amount?: number;
    /**
     * @description The limit for when instabank will require a full applicant during payment.
     *
     * @example 2500000
     */
    require_applicant_amount?: number;
    loan_example?: {
      /**
       * @description The amount loaned in the example.
       *
       * @example 2500000
       */
      amount: number;
      /**
       * @description Years of payment in the example.
       *
       * @example 1
       */
      years: number;
      /**
       * @description The total amount paid back in the example.
       *
       * @example 2772300
       */
      total_amount: number;
      /**
       * @description The cost of the loan in the example.
       *
       * @example 272300
       */
      cost: number;
      /**
       * Format: ^([0-9]*[.])?[0-9]+$
       * @description The effective annual interest rate in the example
       *
       * @example 21.38
       */
      effective_annual_interest_rate: string;
    };
    /** @description Url for a custom branding image */
    branding_image_url?: string;
  };
  InstabankConfiguration: {
    /** @description finance payment */
    finance?: {
      /** @description enable finance payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      product?: unknown & definitions["InstabankFinanceProduct"];
    };
    /** @description invoice payment */
    invoice?: {
      /** @description enable invoice payment (only for amounts greater than 500 NOK) */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      require_applicant?: boolean;
      product?: unknown & definitions["InstabankInvoiceProduct"];
    };
    /** @description Fixed Part Payment */
    installment?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Instabank Installment Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      products?: definitions["InstabankInstallmentProduct"][];
    };
    /** @description Postpone payment */
    postponement?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Instabank Postponement Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      products?: definitions["InstabankPostponementProduct"][];
    };
  };
  /** @description Netaxept configuration */
  NetaxeptConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {string}
     */
    type?: "payment_type";
    creditcard?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Credit Card Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      /**
       * @description Use Netaxept terminal instead of Dintero Checkout
       *
       * See https://shop.nets.eu/web/partners/register
       */
      terminal?: {
        /** @enum {string} */
        terminal: "/Terminal/default.aspx" | "/terminal/mobile/default.aspx";
        /** @description Name of the terminal template to use, created in Netaxept Admin */
        terminal_design?: string;
        /** @description Set hosted payment window to single page */
        terminal_single_page: boolean;
        terminal_layout?: string;
      };
    };
  };
  PayExConfiguration: {
    /** @description A textual description max 40 characters of the purchase. */
    dynamic_descriptor?: string;
    swish?: {
      /** @description enable Payex Swish Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    creditcard?: {
      /** @description enable Credit Card Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      /**
       * @description generate payment token to use for future payments
       *
       * The generated payment token will be made available from
       * the transaction details.
       *
       * @default false
       */
      generate_payment_token?: boolean;
      /**
       * @description generate recurrence payment token to use for future payments
       *
       * The generated recurrence payment token will be made available from
       * the transaction details.
       *
       * @default false
       */
      generate_recurrence_token?: boolean;
      /**
       * @description Disable the CVC field for payments where payment token is used.
       * > To use this feature it has to be enabled on the contract with Swedbank Pay.
       */
      no_cvc?: boolean;
    };
    mobilepay?: {
      /** @description enable Payex MobilePay Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    vipps?: {
      /** @description enable Payex Vipps Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    applepay?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable PayEx Apple Pay payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    clicktopay?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable PayEx Click to Pay payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    googlepay?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable PayEx Google Pay payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
  };
  VippsConfiguration: {
    /** @description enable vipps payment */
    enabled: boolean;
    payability?: definitions["SessionPayability"];
    /**
     * @description A short reference / descriptor that can be displayed to
     * the end user
     */
    dynamic_descriptor?: string;
  };
  CollectorB2BAddress: {
    /** @description ACME Inc */
    business_name: string;
    /** @description The organization number of the customer. For Norway, the length is 9. For Sweden, it's either 10 or 12 digits. */
    organization_number: string;
    /** @description Gaustadalleen 21 */
    address_line: string;
    /** @description More details about address. */
    address_line_2?: string;
    /** @description CO-Address if applicable. */
    co_address?: string;
    /**
     * @description The zip code / postal code of the address.
     * @example 0349
     */
    postal_code: string;
    /**
     * @description The name of the postal code
     * @example Oslo
     */
    postal_place: string;
    /**
     * Format: iso3166-alpha2
     * @description Country of the location
     * @example NO
     */
    country: string;
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /** @description The email address of a person or an organisation */
    email: string;
    /** @description The customer's reference */
    customer_reference?: string;
    /** @description For companies that needs to specify a cost center. */
    cost_center?: string;
    /** @example John */
    first_name?: string;
    /** @example Doe */
    last_name?: string;
    /**
     * @description The unique identification of the address from the available addresses for the business
     *
     * @example address_1
     */
    address_id?: string;
  };
  /** @description Collector configuration */
  CollectorConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {undefined}
     */
    type?: "payment_type";
    /** @description A textual description max 40 characters of the purchase. */
    dynamic_descriptor?: string;
    /** @description Invoice / Part Payment */
    invoice?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Collector Bank Invoice Payment */
      enabled: boolean;
      countries?: string[];
      options?: {
        /**
         * @description Create the collector transaction with status `ON_HOLD` and let
         * the Collector callback update the transaction state from `ON_HOLD`
         * to `AUTHORIZED` or `FAILED`.
         *
         * A callback will be sent to the `callback_url` when the transaction
         * changes state from `ON_HOLD` to any new state.
         *
         * This will override the payment option `enable_on_hold` and gateway config `options.enable_on_hold`-setting.
         */
        enable_on_hold?: boolean;
      };
      payability?: definitions["SessionPayability"];
    };
    /** @description Invoice / Part Payment */
    invoice_b2b?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      payability?: definitions["SessionPayability"];
      /** @description enable Collector Bank Invoice Payment B2B */
      enabled: boolean;
      countries?: string[];
      options?: {
        /**
         * @description For `collector.invoice_b2b`. By default, the shipping_address B2B payments will be restricted to
         * the registered addresses of a company.
         *
         * Setting this on the session will override the `collector_b2b_address_enforcement` in `payment_options`
         * on the checkout configuration.
         *
         * @default false
         */
        disable_collector_b2b_address_enforcement?: boolean;
        /**
         * @description Create the collector transaction with status `ON_HOLD` and let
         * the Collector callback update the transaction state from `ON_HOLD`
         * to `AUTHORIZED` or `FAILED`.
         *
         * A callback will be sent to the `callback_url` when the transaction
         * changes state from `ON_HOLD` to any new state.
         *
         * This will override the gateway's `options.enable_on_hold`-setting.
         */
        enable_on_hold?: boolean;
      };
    };
    /** @description Invoice for pre-approved B2B-customers */
    invoice_b2b_preapproved?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      payability?: definitions["SessionPayability"];
      /** @description enable Collector Bank Invoice Payment B2B */
      enabled: boolean;
      countries?: string[];
      /** @description All Collector B2B accounts configured for the customer's phone number at the merchant. */
      accounts?: {
        billing_address?: definitions["CollectorB2BAddress"];
        /** @description Token to represent the company */
        company_id?: string;
      }[];
    };
    finance?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Collector Bank Finance Payment */
      enabled: boolean;
      countries?: string[];
      payability?: definitions["SessionPayability"];
    };
    /** @description Fixed Part Payment */
    installment?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @default payment_product_type
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Collector Bank Installment Payment */
      enabled: boolean;
      countries?: string[];
      options?: {
        /**
         * @description Create the collector transaction with status `ON_HOLD` and let
         * the Collector callback update the transaction state from `ON_HOLD`
         * to `AUTHORIZED` or `FAILED`.
         *
         * A callback will be sent to the `callback_url` when the transaction
         * changes state from `ON_HOLD` to any new state.
         *
         * This will override the gateway's `options.enable_on_hold`-setting.
         */
        enable_on_hold?: boolean;
      };
      payability?: definitions["SessionPayability"];
    };
  };
  /** @description Klarna configuration */
  KlarnaConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {string}
     */
    type?: "payment_type";
    klarna?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Klarna Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
    billie?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Klarna B2B Payment with Billie */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
  };
  SantanderConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {undefined}
     */
    type?: "payment_type";
    debit_account?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {undefined}
       */
      type?: "payment_product_type";
      /** @description enable Santander Finance Debit Account */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
      /** @description The name of the chain */
      branding_name?: string;
      /** @description Debit accounts belonging to the customer's phone number */
      accounts?: {
        /** @description Token to represent the account number */
        account_number_token?: string;
        /** @description Representation of the account number for display purposes */
        masked_account_number?: string;
      }[];
    };
  };
  /** @description Swish configuration */
  SwishConfiguration: {
    /**
     * @description Denotes what kind of config parameter this is
     * @enum {string}
     */
    type?: "payment_type";
    swish?: {
      /**
       * @description Denotes what kind of config parameter this is
       * @enum {string}
       */
      type?: "payment_product_type";
      /** @description enable Swish Payment */
      enabled: boolean;
      payability?: definitions["SessionPayability"];
    };
  };
  /** @description Payout configuration */
  PayoutConfiguration: {
    /**
     * @description Use the order store id to control what `payout_destination_id` should
     * be use
     *
     * A session created with the option set must have a store id that resolves
     * to a payout_destination_id or have payout_destination_id set
     *
     * A session where both `order.store.id` and `order.payout_destination_id`
     * will not be updated with match from `dynamic_payout_destination`
     */
    dynamic_payout_destination_ids?: {
      /** @enum {string} */
      type: "order_store_id";
      /** @example STORE_123 */
      order_store_id: string;
      /** @example PD_123 */
      order_payout_destination_id: string;
    }[];
    /** @description The payment products where payout is enabled */
    payment_products?: {
      /**
       * @description Payment product
       * @enum {string}
       */
      payment_product: "bambora" | "collector" | "payex" | "klarna";
    }[];
  };
  PaymentConfiguration: definitions["AutoCaptureConfiguration"] & {
    /**
     * @description `channel` enables special behaviour for various scenarios.
     *
     * The majority of web integrations will not need to set this property.
     *
     * ### in_app
     *
     * The `in_app` channel is intended for payments done from
     * mobile devices where `url.return_url` can be set to the
     * application's appswitch URL.
     *
     * #### Session deeplink URL
     *
     * Creating a session with `channel=in_app` will return an
     * appswitch deeplink URL if the enabled payment options in
     * the session supports it
     *
     * Appswitch deeplink is currently only supported for sessions
     * that has only Vipps enabled, via Vipps or Swedbank (payex) or
     * Mobilepay enable via Swedbank (payex)
     *
     *   - configuration.vipps.enabled
     *   - configuration.payex.vipps.enabled
     *   - configuration.payex.mobilepay.enabled
     *
     * > `in_app` is currently not supported when express is enabled
     *
     * > `in_app` with deeplink URL is not supported if `publish` is enabled
     *
     * ### in_store
     *
     * The `in_store` channel is intended for payments done
     * in physical stores.
     *
     * Depending on the payment_type, choosing `in_store` will
     * change the behaviour of the payment.
     *
     * @enum {string}
     */
    channel?: "in_app" | "in_store";
    publish?: definitions["PublishConfiguration"];
    active_payment_types?: {
      /**
       * @description Use this flag as wildcard to include all active payment types
       * configured for a given currency when creating a payment session.
       */
      enabled?: boolean;
    };
    /**
     * @description Configure the default payment type, the selected payment when
     * loading the checkout window. The value must be an enabled payment type.
     *
     * @enum {string}
     */
    default_payment_type?:
      | "bambora.creditcard"
      | "bambora.vipps"
      | "dintero.zero"
      | "dintero_psp.creditcard"
      | "instabank.finance"
      | "instabank.invoice"
      | "instabank.installment"
      | "instabank.postponement"
      | "vipps"
      | "payex.creditcard"
      | "payex.mobilepay"
      | "payex.swish"
      | "payex.vipps"
      | "payex.applepay"
      | "payex.clicktopay"
      | "payex.googlepay"
      | "collector.finance"
      | "collector.invoice"
      | "collector.invoice_b2b"
      | "collector.invoice_b2b_preapproved"
      | "collector.installment_b2b_preapproved"
      | "collector.installment"
      | "santander.debit_account"
      | "swish.swish"
      | "netaxept.creditcard"
      | "klarna.klarna"
      | "klarna.billie";
    bambora?: definitions["BamboraConfiguration"];
    dintero?: definitions["DinteroConfiguration"];
    dintero_psp?: definitions["DinteroPspConfiguration"];
    instabank?: definitions["InstabankConfiguration"];
    netaxept?: definitions["NetaxeptConfiguration"];
    payex?: definitions["PayExConfiguration"];
    vipps?: definitions["VippsConfiguration"];
    collector?: definitions["CollectorConfiguration"];
    klarna?: definitions["KlarnaConfiguration"];
    santander?: definitions["SantanderConfiguration"];
    swish?: definitions["SwishConfiguration"];
    payout?: definitions["PayoutConfiguration"];
  };
  DiscountsConfiguration: {
    /** @description Configuration for discounts calculations */
    discounts?: {
      /** @enum {string} */
      type?: "discounts";
      express_discount_codes?: {
        payability?: definitions["SessionPayability"];
        /**
         * @description The discounts will be given by the configured express callback url.
         *
         * The callback URL will be invoked when the session is updated
         * with a discount code, and the response used to update the discounts
         * on the order items and the shipping options.
         */
        enabled: boolean;
      };
      /** @description Configure discounts calculation on the session order. */
      order?: {
        /**
         * @description Enable discount calculation on order
         * items eligible for discount
         *
         * - A session that has the `customer.customer_id` set will have
         *   its discounts calculated when the session is created.
         *
         * - A session with no customer_id will only have the discounts
         *   calculated when the customer is identified by the checkout
         *   page.
         *
         * - The autorized amount will be the net amount from the
         *   original session amount specified when the session was
         *   created.
         *
         * @default false
         */
        enabled: boolean;
      };
    };
  };
  SessionThemeConfiguration: {
    /** @description Customize the appearance of the checkout. */
    theme?: {
      /**
       * @description Color on backdrop shown in desktop mode
       *
       * Color, supported formats are
       * - hex: `#ff0000`
       * - rgb: `rgb(255,0,0)`
       * - rgba: `rgba(255,0,0,0.5)`
       */
      backdrop?: string;
      /**
       * @description Primary color used on pay button and other buttons.
       *
       * Color, supported formats are
       * - hex: `#ff0000`
       * - rgb: `rgb(255,0,0)`
       * - rgba: `rgba(255,0,0,0.5)`
       */
      primary?: string;
      /**
       * @description **Deprecated** - will be ignored.
       *
       * Default text color.
       *
       * Color, supported formats are
       * - hex: `#ff0000`
       * - rgb: `rgb(255,0,0)`
       * - rgba: `rgba(255,0,0,0.5)`
       */
      text?: string;
      /**
       * @description **Deprecated** - will be ignored.
       *
       * Color used for warnings.
       *
       * Color, supported formats are
       * - hex: `#ff0000`
       * - rgb: `rgb(255,0,0)`
       * - rgba: `rgba(255,0,0,0.5)`
       */
      warning?: string;
      /**
       * @description **Deprecated** - will be ignored.
       *
       * Color used for errors.
       *
       * Color, supported formats are
       * - hex: `#ff0000`
       * - rgb: `rgb(255,0,0)`
       * - rgba: `rgba(255,0,0,0.5)`
       */
      error?: string;
      /**
       * @description **Deprecated** - will be ignored.
       *
       * Fontstack used by the checkout.
       *
       * Default value `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol'`
       */
      "font-family"?: string;
    };
  };
  CountryConfiguration: {
    /** @description Country preferences */
    countries?: {
      /**
       * Format: iso3166-alpha2
       * @description Country to use as default in address and phone country code
       */
      preferred_country?: string;
      /**
       * @description List of countries where the customer is allowed to set their address.
       * If empty, all countries are allowed, except for the ones in `deny_countries`.
       *
       * A country can not be in both `allow_countries` and `deny_countries`.
       */
      allow_countries?: string[];
      /**
       * @description List of countries where the customer is not allowed to set their address.
       *
       * A country can not be in both `allow_countries` and `deny_countries`.
       */
      deny_countries?: string[];
    };
  };
  /**
   * @description Configure merchant information used in the
   * checkout.
   */
  Merchant: {
    name: string;
    /** Format: uri */
    logo_url: string;
    website?: string;
    merchant_category_code?: string;
    /** Format: iso3166-alpha2 */
    country?: string;
  };
  SessionExpressUpdate: {
    /**
     * @description Shipping options that will be presented to the end user after the
     * end user has submitted a shipping address.
     *
     * To dynamically update the shipping_options when the _`order.shipping_address`_ is
     * changed by the end user in the checkout, use the
     * _`url.shipping_address_callback_url`_.
     *
     *  If the merchant is not able to ship the order to the end users shipping address, use an empty array.
     *
     *  If there is only one option, a free delivery, the order still has to contain one option with a _`price.amount`_ of 0.
     */
    shipping_options: definitions["ShippingOption"][];
    /**
     * @default shipping_required
     * @enum {string}
     */
    shipping_mode?: "shipping_required" | "shipping_not_required";
  };
  SessionExpress: {
    /**
     * @description ### Present only for _Express Checkout_ sessions.
     *
     * An _Express Checkout_ session is a session where the end user will submit a
     * shipping address and then select a shipping option before the before a
     * payment method is selected and the payment is initiated.
     *
     * Endpoints used in the _Express Checkout_ flow.
     * 1. [Set shipping address](/#operation/checkout_sid_json_order_shipping_address_put)
     * 2. [Set shipping option](/#operation/checkout_sid_json_order_items_shipping_option_put)
     */
    express?: definitions["SessionExpressUpdate"] & {
      /** @description Enable discount codes for Express Checkout */
      discount_codes?: {
        /** @description Limit how many discount codes can be added by the customer */
        max_count?: number;
        /**
         * Format: uri
         * @description URL that Checkout will POST to when the user has submitted/changed
         * the discount codes for an express session.
         *
         * Dintero will not attempt a retry after a failed delivery attempt.
         * Following situations is considered as failed delivery
         *
         * - HTTP status codes that are not 200.
         * - A request timeout (60 seconds)
         * - Any connection error such as connection timeout, bad certificate, etc
         *
         * The response from the callback will be used to update the order amount,
         * items discount_lines and shipping options.
         *
         * See [POST example/discount_codes_callback_url](#operation/example_discount_codes_callback_url)
         * for details about the request and response.
         *
         * @example https://example.com/order/00128110/discount_codes_updated
         */
        callback_url?: string;
      };
      /**
       * Format: uri
       * @description URL that Checkout will POST to when the end user has submitted/changed
       * a shipping address for an express-session.
       *
       * Dintero will not attempt a retry after a failed delivery attempt.
       * Following situations is considered as failed delivery
       *
       * - HTTP status codes that are not 200.
       * - A request timeout (60 seconds)
       * - Any connection error such as connection timeout, bad certificate, etc
       *
       * The response from the callback will be used to update the shipping options.
       *
       * See [POST example/shipping_address_callback_url](#operation/example_shipping_address_callback_url)
       * for details about the request and response.
       *
       * @example https://example.com/order/00128110/address_updated
       */
      shipping_address_callback_url?: string;
      /**
       * @description Limit the lind of customers that can be submitted via the address form in the express checkout.
       *
       * @default [
       *   "b2c",
       *   "b2b"
       * ]
       */
      customer_types?: ("b2c" | "b2b")[];
    };
  };
  SessionProfile: definitions["SessionBase"] &
    definitions["SessionCustomerTokens"] & {
      /** @description Override configuration for the profile. */
      configuration?: definitions["PaymentConfiguration"] &
        definitions["DiscountsConfiguration"] &
        definitions["SessionThemeConfiguration"] &
        definitions["CountryConfiguration"];
      /** @description configuration profile */
      profile_id: string;
      merchant?: definitions["Merchant"];
    } & definitions["SessionExpress"];
  /** @description Enable customer gift cards in session */
  SessionCustomerGiftcards: {
    customer?: {
      gift_cards?: {
        /**
         * @description Preload checkout with Wallets cards and let the customer
         * use it during checkout by providing PIN to activate the
         * card (e.g. use Wallets card as giftcard)
         *
         * - The `dintero.wallets` must be enabled in the session
         *   configuration to activate the use of the provided gift card
         *   tokens
         */
        "dintero.wallets"?: {
          card_id: string;
        }[];
      };
    };
  };
  Metadata: {
    /**
     * @description Additional metadata about the resource
     * @example {
     *   "system_x_id": "XAB1239",
     *   "number_x": 1921
     * }
     */
    metadata?: { [key: string]: unknown };
  };
  Id: {
    /** @description An ID that uniquely identifies the resource */
    id?: string;
    /**
     * Format: date-time
     * @description The date-time when the resource was created
     */
    created_at?: string;
  };
  SessionOptions: definitions["SessionBase"] &
    definitions["SessionExpress"] & {
      configuration: definitions["PaymentConfiguration"] &
        definitions["DiscountsConfiguration"] &
        definitions["SessionThemeConfiguration"] &
        definitions["CountryConfiguration"];
    };
  SystemRequestHeaders: {
    /**
     * @description The name of the ecommerce solution
     * @example woocommerce
     */
    "dintero-system-name"?: string;
    /**
     * @description The version number of the ecommerce solution
     * @example 5.0.0
     */
    "dintero-system-version"?: string;
    /**
     * @description The name of the ecommerce plugin
     * @example Dintero.Checkout.WooCommerce
     */
    "dintero-system-plugin-name"?: string;
    /**
     * @description The version number of the ecommerce plugin
     * @example 2021.03.02
     */
    "dintero-system-plugin-version"?: string;
    /**
     * @description The user-agent that performed the request
     * @example Mozilla: Mozilla/5.0
     */
    "user-agent"?: string;
  };
  /**
   * @description Initiated by the merchant or used to generate a token
   *
   * @enum {string}
   */
  PaymentOperationIntent:
    | "unscheduled_purchase"
    | "recurring_purchase"
    | "generate_payment_token";
  RequestHeaders: definitions["SystemRequestHeaders"] & {
    /**
     * @description The instance of the checkout that performed the request
     * @example abcd-14134556135
     */
    "dintero-checkout-instance-id"?: string;
  };
  CollectorB2BPaymentOperationAddress: {
    /** @description ACME Inc */
    business_name: string;
    /** @description The organization number of the customer. For Norway, the length is 9. For Sweden, it's either 10 or 12 digits. */
    organization_number: string;
    /** @description Gaustadalleen 21 */
    address_line: string;
    /**
     * @description The zip code / postal code of the address.
     * @example 0349
     */
    postal_code: string;
    /**
     * @description The name of the postal code
     * @example Oslo
     */
    postal_place: string;
    /**
     * Format: iso3166-alpha2
     * @description Country of the location
     * @example NO
     */
    country: string;
    /**
     * @description The unique identification of the address from the available addresses for the business
     *
     * @example address_1
     */
    address_id?: string;
  };
  /** @description Collector payment product */
  CollectorProduct: {
    /**
     * @description Id for the payment product
     *
     * @example IF_3_001
     */
    id: string;
    /**
     * @example interest_free
     * @enum {string}
     */
    type: "interest_free" | "annuity";
    /**
     * @description Number of months
     *
     * @example 3
     */
    credit_time: number;
    /**
     * @description The fee for a "Buy now – pay later" Payment product
     *
     * @example 0
     */
    campaign_fee: number;
    /**
     * @description The startup fee for the payment product
     *
     * @example 9500
     */
    origination_fee: number;
    /**
     * @description The notification fee for the payment product
     *
     * @example 3900
     */
    notification_fee: number;
    /**
     * @description The interest rate for the payment product.
     *
     * @example 0.0
     */
    annual_interest_rate?: string;
    /**
     * @description The effective annual interest rate for the payment product
     *
     * @example 54.69
     */
    effective_annual_interest_rate?: string;
    /**
     * @description The total amount to pay
     * @example 309400
     */
    total_amount: number;
    /**
     * @description The amount to pay pr month
     * @example 100000
     */
    monthly_amount: number;
    /**
     * @description The amount to pay in the first invoice. Origantion fee is added
     * to the first invoice.
     *
     * @example 109500
     */
    first_monthly_amount: number;
  };
  /** @description Options for myDintero */
  MyDinteroUserCreation: {
    /** @description Actions to perform on the customer */
    actions: "create_user"[];
    /** @description Terms and conditions accepted */
    terms: {
      /**
       * Format: uuid
       * @description id of the myDintero terms and conditions
       */
      id: string;
      /**
       * Format: uri
       * @description Url to the terms and conditions accepted by the customer
       *
       * @example https://example.com/toc
       */
      url: string;
    };
  };
  SessionMeta: {
    /** @description The ID of the Checkout */
    id?: string;
    /**
     * Format: date-time
     * @description Time when the Checkout was created
     */
    created_at?: string;
    /**
     * Format: date-time
     * @description Last time when the Checkout was updated
     */
    updated_at?: string;
    /**
     * Format: date-time
     * @description The session expiration time after which the
     * Checkout page wouldn't be available
     */
    expires_at?: string;
    /**
     * @description The IP of the customer upon visiting the page.
     * If the page is visited multiple times, the
     * field is always updated with the last known value.
     */
    customer_ip?: string;
    /**
     * @description The full user agent of the device the customer
     * used when visiting the checkout page
     */
    user_agent?: string;
    initiating_system_request_headers?: definitions["SystemRequestHeaders"];
    payment_operation?: definitions["PaymentOperationIntent"];
    /**
     * @description Checkout process events
     *
     * @example [
     *   {
     *     "id": "769952fe-86c9-4185-a1ce-aeb46da3509c",
     *     "name": "INITIATED",
     *     "created_at": "2019-05-09T09:13:40.306Z",
     *     "request_id": "b97b6312-f8b3-11ed-be56-0242ac120002"
     *   },
     *   {
     *     "name": "VISITED",
     *     "created_at": "2019-05-09T09:13:50.548Z"
     *   },
     *   {
     *     "name": "PAY_FAILED",
     *     "created_at": "2019-05-09T09:14:10.548Z",
     *     "details": {
     *       "error": "Rejected",
     *       "payment_product_type": "instabank.finance"
     *     }
     *   },
     *   {
     *     "name": "FAILED",
     *     "created_at": "2019-05-09T09:16:11.786Z"
     *   }
     * ]
     */
    events?: {
      /** Format: date-time */
      created_at?: string;
      id?: string;
      request_id?: string;
      /** @enum {string} */
      name?:
        | "INITIATED"
        | "VISITED"
        | "COMPLETED"
        | "AUTHORIZED"
        | "DECLINED"
        | "PAY_LOCK_START"
        | "PAY_LOCK_META"
        | "PAY_LOCK_END"
        | "PAY_FAILED"
        | "ON_HOLD_CALLBACK_SENT"
        | "AUTH_CALLBACK_SENT"
        | "FAILED"
        | "UNKNOWN"
        | "PAYMENT_TOKEN_FLOW_START"
        | "UPDATE_SESSION"
        | "CANCELLED"
        | "SET_BILLING_ADDRESS"
        | "SET_DISCOUNT_CODES"
        | "SET_SHIPPING_ADDRESS"
        | "SET_SHIPPING_OPTION"
        | "SET_GIFT_CARD"
        | "PUSH_NOTIFICATION_SENT"
        | "SECRET_CONFIRMATION_CODE_SENT"
        | "SET_MY_DINTERO";
      request_headers?: definitions["RequestHeaders"];
      details?: {
        error?: string;
        payment_product_type?: string;
        amount?: number;
        shipping_option?: definitions["SplitShippingOption"];
        shipping_address?: definitions["OrderAddress"];
        bambora?: {
          session_token?: string;
          session_url?: string;
          wallet_session_id?: string;
        };
        klarna?: {
          client_token: string;
          session_id: string;
        };
        "payex:payment:id"?: string;
        "collector:invoice_b2b:addresses"?: definitions["CollectorB2BPaymentOperationAddress"][];
        "collector:installment:products"?: definitions["CollectorProduct"][];
        my_dintero?: definitions["MyDinteroUserCreation"];
        organization_number?: string;
        previous_order?: definitions["SessionOrder"];
        updated_order?: definitions["SessionOrder"];
        previous_express?: definitions["SessionExpress"];
        updated_express?: definitions["SessionExpress"];
        gift_card?: {
          card_id?: string;
          card_amount?: number;
          masked_card_token?: string;
          currency?: string;
        };
      };
    }[];
    /** @description Transaction which has been created using the checkout. */
    transaction_id?: string;
  };
  Session: definitions["SessionOptions"] & definitions["SessionMeta"];
  Giftcard: {
    /** @enum {string} */
    type: "dintero.wallets";
    card_id: string;
    masked_card_token: string;
    /** @description Non-negative, minor units. Total amount for the gift card */
    amount: number;
  };
  SessionRead: {
    order?: {
      /**
       * @description The gift cards selected, the part of `order.amount` that will be
       * authorized using gift cards
       */
      gift_cards?: definitions["Giftcard"][];
    };
    customer?: {
      my_dintero?: definitions["MyDinteroUserCreation"];
      gift_cards?: {
        /**
         * @description Preload checkout with Wallets cards and let the customer
         * use it during checkout by providing PIN to activate the
         * card (e.g. use Wallets card as giftcard)
         *
         * - The `dintero.wallets` must be enabled in the session
         *   configuration to activate the use of the provided gift card
         *   tokens
         */
        "dintero.wallets"?: {
          card_id: string;
          masked_card_token?: string;
        }[];
      };
      tokens?: {
        "payex.creditcard"?: {
          /**
           * @description Id included if the payex.creditcard was created with
           * payment_token set.
           *
           * @example 2134a260d196b1d65e59b259dc43f619d7f0f3c6
           */
          payment_token_id?: string;
        };
      };
    };
    /** @description metadata about the session */
    metadata?: {
      /** @description Profile Id used when session was created */
      "session:profile_id"?: string;
    };
    configuration?: {
      merchant?: {
        /** @example null */
        id?: string;
        /** Format: uri */
        logo_url?: string;
        /** @example TKP tech AS */
        name?: string;
      };
    };
  };
  SessionCancelled: {
    cancelled_by?: string;
    /**
     * Format: date-time
     * @description The date-time when the resource was cancelled
     */
    cancelled_at?: string;
  };
  Error: {
    error: {
      /** @description The code used to identify the error/warning */
      code?: string;
      /** @description The nested error(s) encountered during validation */
      errors?: { [key: string]: unknown }[];
      /** @description The human readable description of the error/warning */
      message: string;
    };
  };
  UpdateSessionOptions: {
    order: definitions["SessionOrderUpdate"];
    express?: definitions["SessionExpressUpdate"];
    /**
     * @description Remove lock after updating
     * @default true
     */
    remove_lock?: boolean;
  };
  QROptions: {
    /** @enum {string} */
    format?: "png";
    /**
     * @description Size of the QR code. The code is a square, so width and height
     * are the same
     *
     * @default 300
     */
    size?: number;
  };
  QRCode: {
    /**
     * Format: data:[<mime type>][;charset=<charset>][;base64],<encoded data>
     * @description A base64 encoded image of the QR code
     */
    qr?: string;
  };
  SessionPaymentToken: {
    order: {
      /**
       * Format: iso4217-code
       * @description The three-character ISO-4217 currency. https://en.wikipedia.org/wiki/ISO_4217
       * @example NOK
       */
      currency: string;
      /**
       * @description A reference by the merchant to identify the corresponding
       * order for the Checkout Session
       */
      merchant_reference: string;
      /**
       * @description A reference by the merchant to identify the corresponding
       * order for the Checkout Session
       */
      merchant_reference_2?: string;
      store?: definitions["Store"];
    };
    url: definitions["SessionUrls"];
    /** @description configuration profile to use for branding */
    profile_id?: string;
    customer?: definitions["SessionCustomer"];
    /** Format: date-time */
    expires_at?: string;
    configuration?: definitions["SessionThemeConfiguration"];
  };
  TokenProvider: {
    /** @description The payment product type corresponding to create token for */
    payment_product_type: string;
  };
  Payment: {
    /** @description The payment product type corresponding to this transaction */
    payment_product_type: string;
  };
  PaymentResponse: {
    /** @description the payment was accepted */
    success: boolean;
    actions: {
      /**
       * @description action source
       * @example DINTERO
       */
      source?: string;
      /**
       * @description status
       * @example 200
       */
      code?: string;
      /** @enum {string} */
      type?: "success" | "error";
    }[];
    /**
     * @description redirect url to complete payment, will not be included
     * if the payment failed with `Rejected` error as payment
     * can be completed by choosing alternative payment option.
     */
    redirect_url?: string;
    /**
     * @description poll_url to check the status of the payment.
     * Will be included if the payment is dependent on
     * 3rd party apps, such as Swish.
     */
    poll_url?: unknown;
    /** @example Rejected */
    error?: string;
    error_details?: {
      /**
       * @description description of the error
       *
       * @example wrong_ssn
       */
      code?: string;
      /**
       * @description Describes if the error is retriable
       *
       * @enum {string}
       */
      category?: "permanent" | "temporary" | "unknown";
      /** @description The field that might be the reason for the error */
      field?: string;
    }[];
  };
  PaySessionBase: {
    url?: {
      callback_url?: definitions["CallbackUrl"];
    };
    customer?: definitions["SessionCustomer"];
    order: definitions["SessionOrder"];
    /** Format: date-time */
    expires_at?: string;
  };
  PaySessionOptions: definitions["PaySessionBase"] & {
    configuration?: definitions["AutoCaptureConfiguration"];
  };
  PayPayment: {
    /** @description The payment product type corresponding to this transaction */
    payment_product_type: string;
  };
  SessionPayResult: {
    session_id?: string;
    success: boolean;
    actions?: {
      /** @example PAYEX */
      source?: string;
      /** @example AUTHORIZED */
      code?: string;
      /** @example success */
      type?: string;
    }[];
  };
  /**
   * @description Overall settlement status after the events
   *
   * @enum {string}
   */
  SettlementStatus:
    | "NOT_SETTLED"
    | "PENDING_SETTLEMENT"
    | "PARTIALLY_SETTLED"
    | "SETTLED";
  TransactionSettlementsEvent: {
    /** @description Id of the settlement this was paid in */
    settlement_id: string;
    /** @description The providers reference for the settlement */
    provider_reference: string;
    /** @description Id for matching to transaction event */
    event_correlation_id?: string;
    /** @description The amount paid out in this settlement */
    amount: number;
    /** @description Amount captured in this settlement */
    capture?: number;
    /** @description Amount refunded in this settlement */
    refund?: number;
    /** @description Fee of the capture in this settlement */
    fee?: number;
  };
  TransactionSettlementsRead: {
    /** @description One item per payout to the merchants bank account */
    events: definitions["TransactionSettlementsEvent"][];
    /** @enum {string} */
    settlement_status?:
      | "NOT_SETTLED"
      | "PENDING_SETTLEMENT"
      | "PARTIALLY_SETTLED"
      | "SETTLED";
  };
  TransactionEvent: {
    id?: string;
    /** @description The transaction state after this event */
    transaction_status?: string;
    /** @description The gift cards that was used as part of this event */
    gift_cards?: (definitions["Giftcard"] & {
      /** @description The external transaction ID */
      transaction_id: string;
    })[];
    /**
     * @description the event type
     * @example CAPTURE
     * @enum {string}
     */
    event?:
      | "INITIALIZE"
      | "AUTHORIZE"
      | "CAPTURE"
      | "REFUND"
      | "VOID"
      | "INITIATE_REFUND"
      | "INITIATE_CAPTURE"
      | "SETTLEMENT";
    /** @description The event operation completed with success */
    success?: boolean;
    /**
     * @description Correction of the transaction status and event after
     * a failed operation
     */
    correction?: {
      /** @description List of event ids added to correct the transaction status */
      event_ids?: string[];
      /** @description status the transaction was corrected to */
      status: string;
      /**
       * @description Monetary amount in smallest unit for the currency
       *
       * @example 50000
       */
      remaining_capture_amount: number;
      /**
       * @description Monetary amount in smallest unit for the currency
       *
       * @example 50000
       */
      remaining_refund_amount: number;
      /**
       * @description Monetary amount in smallest unit for the currency
       *
       * @example 50000
       */
      remaining_void_amount: number;
    };
    /** @description The event error is only used when the success is `false`. */
    error?: {
      /** @description The code used to identify the error/warning */
      code?: string;
      /** @description The human readable description of the error/warning */
      message: string;
    };
    /** @description Amount captured or refunded */
    amount?: number;
    /** @description Best-effort calculation of the VAT amount in this transaction */
    calculated_vat_amount?: number;
    /** @description The applicable event items */
    items?: ({
      /** @description Metadata about discounts given */
      discount_lines?: definitions["DiscountItem"][];
    } & definitions["OrderItem"])[];
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uuid
     * @example 05c91a5b-9c3d-4214-a7e1-e472dbe22eb9
     */
    request_id?: string;
    /** @description Additional details about the event */
    metadata?: { [key: string]: unknown };
    /**
     * Format: uuid
     * @description The event correlation to existing event. The property will
     * be set if the event is an CAPTURE or REFUND of correlated
     * INITIATE_CAPTURE or INITIATE_REFUND event.
     *
     * @example 05c91a5b-9c3d-4214-a7e1-e472dbe22eb9
     */
    correlation_request_id?: string;
    /**
     * @description Reference for the transaction event provided by the merchant.
     *
     * - For captures, this is `capture_reference`
     * - For refunds, this is `refund_reference`
     *
     * When relevant, it will be visible on the Dintero settlement report.
     */
    event_reference?: string;
    request_headers?: definitions["RequestHeaders"];
    settlements?: definitions["TransactionSettlementsRead"];
  };
  Transaction: {
    /** @example P00000000.465UfBENeLpkBvwmqfTC4k */
    id?: string;
    /** @description The payment product corresponding to this transaction */
    payment_product: string;
    /**
     * @description Non-negative, minor units. Total amount of the transaction
     *
     * @example 72200
     */
    amount: number;
    /**
     * Format: iso4217-code
     * @description ISO 4217 transaction currency
     * @example NOK
     */
    currency: string;
    /**
     * @description An id that identifies the seller, value will be included in
     * the settlement reports
     */
    payout_destination_id?: string;
    /** @description A reference specified by the merchant to identify the transaction */
    merchant_reference?: string;
    /** @description A reference specified by the merchant to identify the transaction, can be updated after the transaction has been created */
    merchant_reference_2?: string;
    /**
     * @description A short reference / descriptor that will show
     * up on the customers bank statement
     */
    dynamic_descriptor?: string;
    payment_operation?: definitions["PaymentOperationIntent"];
    settlement_status?: definitions["SettlementStatus"];
    customer?: {
      /** @description Customer id */
      customer_id?: string;
      /**
       * @description Customer email address
       *
       * @example john.doe@example.com
       */
      email?: string;
      /**
       * @description Customer phone number, ITU/E.123 format with
       * international prefix (+PPNNNNNNNNN...)
       *
       * @example +4799999999
       */
      phone_number?: string;
      my_dintero?: definitions["MyDinteroUserCreation"];
    };
    /**
     * @description The IP address of the customer
     * @example 127.0.0.1
     */
    customer_ip?: string;
    /**
     * @description The full user agent string of the device the customer used
     * to submit the transaction
     *
     * @example Mozilla/5.0 ...
     */
    user_agent?: string;
    initiating_system_request_headers?: definitions["SystemRequestHeaders"];
    shipping_address?: definitions["OrderAddress"];
    shipping_option?: definitions["SplitShippingOption"];
    billing_address?: definitions["OrderAddress"];
    store?: definitions["Store"];
    /**
     * @description The current status of the transaction
     * @example CAPTURED
     */
    status?: string;
    /** @description The gift cards that used to partially or fully authorize the transaction */
    gift_cards?: definitions["Giftcard"][];
    /**
     * @description The applicable transaction items
     *
     * @example [
     *   {
     *     "amount": 2000,
     *     "quantity": 2,
     *     "line_id": "1",
     *     "description": "Forsvinnignspølse",
     *     "vat": 20,
     *     "id": "10"
     *   },
     *   {
     *     "amount": 6600,
     *     "quantity": 2,
     *     "line_id": "2",
     *     "description": "Vissvossafår på neppebrød",
     *     "vat": 20,
     *     "id": "6",
     *     "eligible_for_discount": true,
     *     "is_changed": true,
     *     "gross_amount": 10000,
     *     "discount_lines": [
     *       {
     *         "amount": 4400,
     *         "discount_type": "customer",
     *         "discount_id": "ed960ace-eb16-4e2e-ae52-b27647ccae8d",
     *         "description": "Vossafestpris",
     *         "line_id": 1
     *       }
     *     ]
     *   },
     *   {
     *     "amount": 59700,
     *     "quantity": 3,
     *     "line_id": "3",
     *     "description": "Luftboller",
     *     "vat": 20,
     *     "id": "1"
     *   }
     * ]
     */
    items?: (definitions["OrderItem"] & definitions["OrderDiscountItem"])[];
    url?: {
      /**
       * Format: uri
       * @description URL the customer is redirected after checkout completes
       * (successfully or failed)
       */
      redirect_url?: string;
      /**
       * Format: uri
       * @description URL the customer is redirected to for authentication.
       */
      approval_url?: string;
      /**
       * Format: uri
       * @description URL that Checkout will call when the session payment is complete
       * and the transaction has been authorized
       */
      callback_url?: string;
    };
    /**
     * @description All events recorded on the transaction
     *
     * @example [
     *   {
     *     "event": "INITIATE",
     *     "transaction_status": "INITIATED",
     *     "created_at": "2019-01-18T13:13:37.175Z",
     *     "success": true,
     *     "request_id": "a3dcc23125bc4363b9dae29ed25a4eb1"
     *   },
     *   {
     *     "event": "AUTHORIZE",
     *     "transaction_status": "AUTHORIZED",
     *     "created_at": "2019-01-18T13:13:37.540Z",
     *     "success": true,
     *     "request_id": "f5f64165e5b3404e9af63586c184c3e9"
     *   },
     *   {
     *     "event": "CAPTURE",
     *     "transaction_status": "PARTIALLY_CAPTURED",
     *     "created_at": "2019-01-18T15:37:00.879Z",
     *     "created_by": "99115ac5-2d10-4be4-8594-bbf5e3aa7dfc",
     *     "amount": 59700,
     *     "splits": [
     *       {
     *         "payout_destination_id": "P000000001",
     *         "amount": 29700
     *       },
     *       {
     *         "payout_destination_id": "P000000002",
     *         "amount": 30000
     *       }
     *     ],
     *     "fee_split": {
     *       "type": "proportional",
     *       "destinations": [
     *         "P000000001"
     *       ]
     *     },
     *     "items": [
     *       {
     *         "amount": 59700,
     *         "quantity": 3,
     *         "line_id": "3"
     *       }
     *     ],
     *     "success": true,
     *     "request_id": "27c71936004e48649c6dd437d314d90c"
     *   },
     *   {
     *     "event": "CAPTURE",
     *     "transaction_status": "CAPTURED",
     *     "created_at": "2019-01-18T21:24:31.669Z",
     *     "created_by": "a33aef94-a17d-447a-a1dd-81055892b59d",
     *     "amount": 8600,
     *     "items": [
     *       {
     *         "amount": 2000,
     *         "quantity": 2,
     *         "line_id": "1"
     *       },
     *       {
     *         "amount": 6600,
     *         "quantity": 2,
     *         "line_id": "2"
     *       }
     *     ],
     *     "success": true,
     *     "request_id": "c3e60b98a1d1466c97151318be621cf9"
     *   }
     * ]
     */
    events?: definitions["TransactionEvent"][];
    /**
     * @description The session id for the transaction
     * @example P00000000.465U8CUzaPVpneu1wt8Wei
     */
    session_id?: string;
    session?: definitions["Session"];
    /**
     * Format: date-time
     * @description When the transaction was last modified.
     */
    updated_at?: string;
    /**
     * Format: date-time
     * @description When the transaction was created
     */
    created_at?: string;
    /** @description Additional details about the transaction */
    metadata?: {
      merchant_name?: string;
      /** @description Profile Id used when session was created */
      "session:profile_id"?: string;
      /**
       * @description How settlement payout will be done by Dintero
       *
       * - `payout_account`: Payout directly to merchant
       * - `payout_splits`: Payout is splitted to one or more sellers
       * - `payout_destination_id`: Payout is done to a single seller
       *
       * @enum {string}
       */
      payout?: "payout_account" | "payout_splits" | "payout_destination_id";
      /** @description Id that will be referenced on the settlement report */
      payout_correlation_id?: string;
    };
    checkboxes?: definitions["CheckboxConfiguration"];
  };
  PaymentOperation: {
    /** @enum {string} */
    content_type?: "application/json" | "application/javascript" | "text/html";
    /**
     * @description The HTTP method to use when performing the operation
     *
     * @enum {string}
     */
    method?: "GET" | "POST";
    rel: string;
  };
  PaymentOperations: {
    /**
     * @description Set of operation available, which operation available will
     * depend on the current state of the session.
     *
     * @example [
     *   {
     *     "method": "GET",
     *     "href": "string",
     *     "rel": "view-payment",
     *     "content_type": "application/javascript"
     *   },
     *   {
     *     "method": "POST",
     *     "href": "https://checkout.dintero.com/v1/view/{session_id}/session/pay",
     *     "rel": "pay-collector-installment",
     *     "product": {
     *       "id": "IF_3_001",
     *       "type": "interest_free",
     *       "credit_time": 3,
     *       "campaign_fee": 0,
     *       "origination_fee": 9500,
     *       "notification_fee": 3900,
     *       "annual_interest_rate": "0.0",
     *       "effective_annual_interest_rate": "54.69",
     *       "total_amount": 309400,
     *       "monthly_amount": 100000,
     *       "first_monthly_amount": 109500
     *     },
     *     "content_type": "application/json"
     *   },
     *   {
     *     "method": "POST",
     *     "href": "https://checkout.dintero.com/v1/view/{session_id}/session/pay",
     *     "rel": "pay-collector-invoice-b2b",
     *     "shipping_address": {
     *       "id": "address_1",
     *       "business_name": "Dintero AS",
     *       "address_line": "Street road 1",
     *       "postal_place": "OSLO",
     *       "postal_code": 565,
     *       "country": "NO"
     *     },
     *     "content_type": "application/json"
     *   },
     *   {
     *     "method": "POST",
     *     "href": "https://checkout.dintero.com/view/{session_id}/sessions/publish/scc",
     *     "rel": "publish-secret-confirmation-code",
     *     "content_type": "application/json"
     *   },
     *   {
     *     "method": "GET",
     *     "href": "https://v1.checkout.bambora.com/fb49265d30aa4f1bb327b943c4d43b14",
     *     "session": {
     *       "token": "fb49265d30aa4f1bb327b943c4d43b14"
     *     },
     *     "rel": "pay-bambora-creditcard",
     *     "content_type": "text/html"
     *   },
     *   {
     *     "method": "POST",
     *     "href": "https://checkout.dintero.com/v1/view/{session_id}/session/pay",
     *     "client_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9",
     *     "rel": "pay-klarna",
     *     "content_type": "application/json"
     *   }
     * ]
     */
    operations?: definitions["PaymentOperation"][];
  };
  SessionEventVersion: {
    /**
     * @description String that represents the state of the session.
     *
     * @example 22596363b3de40b06f981fb85d82312e8c0ed511
     */
    version?: string;
  };
  SessionOperations: {
    /**
     * @description Set of operation available, which operation available will
     * depend on the current state of the session.
     *
     * @example [
     *   {
     *     "method": "POST",
     *     "href": "https://checkout.api.dintero.com/v1/view/P00000000.465UfBENeLpkBvwmqfTC4k/payment/payex.creditcard",
     *     "rel": "view-payex-creditcard",
     *     "content_type": "application/json"
     *   },
     *   {
     *     "method": "POST",
     *     "href": "https://checkout.api.dintero.com/v1/view/P00000000.465UfBENeLpkBvwmqfTC4k/payment/collector.installment",
     *     "rel": "view-collector-installment",
     *     "content_type": "application/json"
     *   }
     * ]
     */
    operations?: {
      /**
       * @description The HTTP method to use when performing the operation
       *
       * @enum {string}
       */
      method?: "POST" | "GET";
      /**
       * @description The target URI to perform the operation against.
       *
       * @example https://checkout.api.dintero.com/v1/view/P00000000.465UfBENeLpkBvwmqfTC4k/payment/payex.creditcard
       */
      href?: string;
      /**
       * @description The name of the relation the operation has to the current resource
       *
       * - `view-payex-creditcard`: Contains the href that is used to
       *   get the URL for the JavaScript that is used to embed the
       *   credit card UI directly on the Checkout site.
       * - `view-payex-swish`: Contains the href that is used to
       *   get the URL for the JavaScript that is used to embed the
       *   Swish UI directly on the Checkout site.
       * - `view-collector-installment`: Contains the href that is used
       *   to get the producsts available for the collector installment
       *
       * @enum {string}
       */
      rel?:
        | "view-collector-installment"
        | "view-collector-invoice"
        | "view-collector-invoice-b2b"
        | "view-collector-invoice-b2b-preapproved"
        | "view-payex-creditcard"
        | "view-payex-mobilepay"
        | "view-payex-swish";
      /**
       * @description The Content-Type to used when performing the operation.
       *
       * @example application/json
       */
      content_type?: string;
    }[];
  };
  /** @description If the session is locked, and metadata about the lock. */
  SessionLock: {
    pay_lock?: {
      /**
       * @description The id of the pay lock
       * @example 7ffdbd47-a7c8-476b-b06b-39e0a3f2a4c6
       */
      pay_lock_id?: string;
    };
  };
  /** @description Session not found error */
  SessionNotFound: {
    error: {
      /** @description The code used to identify the error/warning */
      code?: string;
      /** @description The nested error(s) encountered during validation */
      errors?: { [key: string]: unknown }[];
      /** @description The human readable description of the error/warning */
      message: string;
      /**
       * @description Optional not found reason
       * @enum {string}
       */
      cause?:
        | "CANCELLED"
        | "FAILED"
        | "AUTHORIZED"
        | "ON_HOLD"
        | "PAYMENT_INITIATED"
        | "EXPIRED"
        | "DECLINED";
      session_details?: {
        /** @description A reference by the merchant to identify the corresponding order for the Checkout Session */
        merchant_reference: string;
        /** @description Transaction which has been created using the checkout. */
        transaction_id?: string;
        /** @description URL to page where Checkout will redirect the customer to after the Checkout process has ended. */
        return_url: string;
        merchant?: {
          /** Format: uri */
          logo_url?: string;
          /** @example TKP tech AS */
          name?: string;
        };
      };
    };
  };
  CheckboxSimple: {
    /** @description ID of the checkbox that should be updated */
    id: string;
    /** @description If the checkbox is checked or unchecked */
    checked: boolean;
  };
  /** @description The checkboxes that should be updated */
  CheckboxUpdate: definitions["CheckboxSimple"][];
  ViewSessionUpdateAddress: {
    shipping_address?: definitions["OrderAddress"];
    billing_address?: definitions["OrderAddress"];
    my_dintero?: definitions["MyDinteroUserCreation"];
    checkboxes?: definitions["CheckboxUpdate"];
  };
  ViewSessionUpdateDiscountCodes: {
    discount_codes?: string[];
  };
  ViewSessionUpdateGiftcards: {
    gift_cards: {
      /** @enum {string} */
      type: "dintero.wallets.card_id" | "dintero.wallets.card_token";
      /** @description PIN to verify the value */
      pin: string;
      /**
       * @description The `card_id` or `card_token`. The `card_id` value must be found
       * in the `customer.gift_cards`
       */
      value: string;
    }[];
  };
  /** @description Order updated with discount given by discount_code. */
  DiscountCodesOrderUpdate: {
    discount_codes?: string[];
    /**
     * @description The amount to authorize/capture including VAT and discounts.
     * In smallest unit for the currency, e.g. cents
     *
     * @example 72200
     */
    amount: number;
    /**
     * @description Items with discount lines.
     *
     *  - The list must include all items in the session order
     *  - **Required** if the session order has any items.
     *
     * @example [
     *   {
     *     "amount": 2000,
     *     "quantity": 2,
     *     "line_id": "1",
     *     "description": "Forsvinnignspølse",
     *     "vat": 20,
     *     "id": "10"
     *   },
     *   {
     *     "amount": 6600,
     *     "quantity": 2,
     *     "line_id": "2",
     *     "description": "Vissvossafår på neppebrød",
     *     "vat": 20,
     *     "id": "6",
     *     "eligible_for_discount": true,
     *     "is_changed": true,
     *     "gross_amount": 10000,
     *     "discount_lines": [
     *       {
     *         "amount": 4400,
     *         "discount_type": "external",
     *         "discount_id": "ed960ace-eb16-4e2e-ae52-b27647ccae8d",
     *         "description": "Vossafestpris",
     *         "line_id": 1
     *       }
     *     ]
     *   },
     *   {
     *     "amount": 59700,
     *     "quantity": 3,
     *     "line_id": "3",
     *     "description": "Luftboller",
     *     "vat": 20,
     *     "id": "1"
     *   }
     * ]
     */
    items?: (definitions["OrderItem"] & {
      discount_lines?: definitions["DiscountItem"][];
    })[];
  };
  /** @description Updates to session order. If the amount is not equal to sum of items.amount and the shipping_option.amount from the request are not equal a correction item will be added to the items. */
  ShippingAddressCallbackSessionOrderUpdate: {
    /**
     * @description The amount to authorize/capture including VAT and discounts.
     * In smallest unit for the currency, e.g. cents
     *
     * @example 29990
     */
    amount: number;
    /**
     * Format: iso4217-code
     * @description The three-character ISO-4217 currency. https://en.wikipedia.org/wiki/ISO_4217
     * @example NOK
     */
    currency?: string;
    /**
     * @description The VAT of the `amount` parameter.
     * Only used for display purposes.
     *
     * In smallest unit for the currency, e.g. cents
     *
     * @example 6000
     */
    vat_amount?: number;
    /**
     * @description Details about the order items.
     *
     * #### Instabank
     * `required` if Instabank payment is configured in and partial_payment is false.
     * All items must include a unique `line_id`, quantity and amount
     *
     * #### Collector Bank
     * `required` if Collector Bank payment is configured in and partial_payment is false.
     * All items must include a unique `line_id`, quantity and amount
     */
    items?: (definitions["OrderItem"] & definitions["OrderDiscountItem"])[];
    discount_codes?: string[];
  };
  TransactionSettlementsWrite: {
    /** @description One item per payout to the merchants bank account */
    events: definitions["TransactionSettlementsEvent"][];
  };
  ApiKey: {
    name: string;
  };
  ApiKeyRead: definitions["Id"] &
    definitions["ApiKey"] & {
      /** Format: date-time */
      updated_at?: string;
      /** Format: date-time */
      expires_at?: string;
      deleted_by?: string;
      /** Format: date-time */
      deleted_at?: string;
    };
  ApiKeyValue: {
    /** Format: jwt */
    access_token?: string;
  };
  /** @description configuration for Bambora GW */
  BamboraGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uri
     * @example https://api.v1.checkout.bambora.com
     */
    checkout_api_url: string;
    /**
     * Format: uri
     * @example https://merchant-v1.api-eu.bambora.com
     */
    merchant_api_url: string;
    /**
     * Format: uri
     * @example https://transaction-v1.api-eu.bambora.com
     */
    transaction_api_url: string;
    /**
     * Format: uri
     * @example https://wallet-v1.api-eu.bambora.com
     */
    wallet_api_url: string;
    /**
     * Format: uri
     * @example https://tokenize-v1.api-eu.bambora.com
     */
    token_api_url: string;
    token_scope?: string;
    merchant_number: string;
  };
  /** @description configuration for Instabank GW */
  InstabankGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /** Format: uri */
    url?: string;
    /**
     * @description Company identification number
     * @example 12345678911
     */
    organization_number: string;
    /** @description Instabank Product Codes */
    payment_product_codes: {
      "instabank.finance": definitions["InstabankFinanceProduct"];
      "instabank.invoice": definitions["InstabankInvoiceProduct"];
      "instabank.installment"?: definitions["InstabankInstallmentProduct"][];
      "instabank.postponement"?: definitions["InstabankPostponementProduct"][];
    };
  };
  /** @description configuration for Klarna GW */
  KlarnaGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uri
     * @description The base URIs of the Klarna APIs:
     *
     * - **test**: https://api.playground.klarna.com
     * - **prod**: https://api.klarna.com
     *
     * @example https://api.klarna.com
     */
    url: string;
    /**
     * @description The Merchant ID (MID) - a unique number that identifies the store,
     * combined with a random string
     *
     * @example PK27631_9dfg28uy0p43
     */
    username: string;
    /**
     * @description The Merchant ID (MID) without the random string suffix
     *
     * @example PK27631
     */
    merchant_id: string;
  };
  /** @description configuration for PayEx GW */
  PayExGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uri
     * @description The base URIs of the eCommerce APIs:
     *
     * - **test**: https://api.externalintegration.payex.com
     * - **prod**: https://api.payex.com
     *
     * @example https://api.payex.com
     */
    url: string;
    /**
     * @description Unique id that identifies the payee for the account (like merchant) set
     * by PayEx.
     */
    payee_id: string;
    /**
     * @description The subsite field can be used to perform split settlements on
     * payments. The subsites must be resolved with PayEx reconciliation
     * before being used.
     *
     * @example 12345789
     */
    subsite?: string;
  };
  /** @description Override configuration */
  PayExGwOverrideRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uri
     * @description The base URIs of the eCommerce APIs:
     *
     * - **test**: https://api.externalintegration.payex.com
     * - **prod**: https://api.payex.com
     *
     * @example https://api.payex.com
     */
    url?: string;
    /**
     * @description Unique id that identifies the payee for the account (like merchant) set
     * by PayEx.
     */
    payee_id?: string;
    /**
     * @description The subsite field can be used to perform split settlements on
     * payments. The subsites must be resolved with PayEx reconciliation
     * before being used.
     *
     * @example 12345789
     */
    subsite?: string;
  };
  GwVersion: {
    /**
     * Format: date-time
     * @description The version is valid given the transaction/session `created_at`
     */
    valid_after: string;
    /**
     * Format: date-time
     * @description The version is valid given the transaction/session `created_at`
     */
    valid_before: string;
  };
  /** @description configuration for Vipps GW */
  VippsGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /** Format: uri */
    url: string;
    client_id: string;
    /** @example 123456 */
    merchant_serial_number: string;
  };
  /** @description Override for sales location for Santander GW */
  VippsGwStoreOverrideRead: {
    client_id: string;
    /** @example 123456 */
    merchant_serial_number: string;
    ocp_apim_subscription_key_access_token: string;
    ocp_apim_subscription_key_ecom: string;
  };
  /** @description configuration for Collector Bank GW */
  CollectorGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /** Format: uri */
    url: string;
    /** @description Merchant's username at Collector Bank */
    username: string;
    /** @description Default store_id for gateway */
    store_id: number;
    /**
     * Format: iso-3166-1
     * @description Default country for gateway
     */
    country: string;
    /** @description configuration options for the gateway. */
    options?: {
      /**
       * @description Create the collector transaction with status `ON_HOLD` and let
       * the Collector callback update the transaction state from `ON_HOLD`
       * to `AUTHORIZED` or `FAILED`.
       *
       * A callback will be sent to the `callback_url` when the transaction
       * changes state from `ON_HOLD` to any new state.
       *
       * @default false
       */
      enable_on_hold?: boolean;
      /**
       * @description The field(s) used to populate the settlement reference.
       * The `store_id` in this context is `order.store.id` from session, not to be confused with a store_id from Collector stores.
       *
       * @default account_id
       * @enum {string}
       */
      settlement_reference_fields?: "account_id" | "account_id.store_id";
    };
    /** @description Configured stores in the Collector Partner Portal */
    stores?: {
      store_id?: number;
      /** Format: iso-3166-1 */
      country?: string;
      /**
       * @description The three-character ISO-4217 currency.
       * https://en.wikipedia.org/wiki/ISO_4217
       *
       * @example NOK
       */
      currency?: string;
      /**
       * @description The type of customers this store id is used for
       * @enum {string}
       */
      segment?: "B2C" | "B2B";
    }[];
  };
  /** @description Override for sales location for Collector GW */
  CollectorGwStoreOverrideRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /** Format: uri */
    url: string;
    /** @description Merchant's username at Collector Bank */
    username: string;
    /** @description Default store_id for gateway */
    store_id: number;
    /**
     * Format: iso-3166-1
     * @description Default country for gateway
     */
    country: string;
    /** @description configuration options for the gateway. */
    options?: {
      /**
       * @description Create the collector transaction with status `ON_HOLD` and let
       * the Collector callback update the transaction state from `ON_HOLD`
       * to `AUTHORIZED` or `FAILED`.
       *
       * A callback will be sent to the `callback_url` when the transaction
       * changes state from `ON_HOLD` to any new state.
       *
       * @default false
       */
      enable_on_hold?: boolean;
      /**
       * @description The field(s) used to populate the settlement reference.
       * The `store_id` in this context is `order.store.id` from session, not to be confused with a store_id from Collector stores.
       *
       * @default account_id
       * @enum {string}
       */
      settlement_reference_fields?: "account_id" | "account_id.store_id";
    };
    /** @description Configured stores in the Collector Partner Portal */
    stores?: {
      store_id?: number;
      /** Format: iso-3166-1 */
      country?: string;
      /**
       * @description The three-character ISO-4217 currency.
       * https://en.wikipedia.org/wiki/ISO_4217
       *
       * @example NOK
       */
      currency?: string;
      /**
       * @description The type of customers this store id is used for
       * @enum {string}
       */
      segment?: "B2C" | "B2B";
    }[];
  };
  /** @description configuration for Santander GW */
  SantanderGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uri
     * @description URL for the SOAP service
     */
    url: string;
    /** @description Email-address to the store. Must correspond with email stored in Santander's system. */
    store_email: string;
    /**
     * @description The name to brand debit_accounts with
     * @example Bygger'n
     */
    branding_name?: string;
  };
  /** @description Override for sales location for Santander GW */
  SantanderGwStoreOverrideRead: {
    /** @description Email-address to the store. Must correspond with email stored in Santander's system. */
    store_email: string;
  };
  /** @description configuration for Dintero PSP GW */
  DinteroPspGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    visa_net_client_id: string;
    acquirer_merchant_id: string;
    /** @example 123456 */
    vipps_merchant_serial_number?: string;
    visa_token_client_app_id?: string;
    /** @example 10000000-20000000000 */
    visa_token_relationship_id?: string;
  };
  /** @description configuration for Netaxept GW */
  NetaxeptGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /**
     * Format: uri
     * @description The base URIs of the eCommerce APIs:
     *
     * - **test**: https://test.epayment.nets.eu
     * - **prod**: https://epayment.nets.eu
     *
     * @example https://epayment.nets.eu
     */
    url: string;
    /** @description Unique id that identifies the merchant */
    merchant_id: string;
  };
  /** @description configuration for Swish GW */
  SwishGwRead: {
    /** Format: date-time */
    created_at?: string;
    created_by?: string;
    /** Format: uri */
    url: string;
    /** @description The merchant's Swish number */
    swish_number: string;
  };
  /** @description Override for sales location for Swish GW */
  SwishGwStoreOverrideRead: {
    /** @description The merchant's Swish number */
    swish_number: string;
  };
  CredentialResponse: {
    /** @description The unique name that identifies the credential */
    name: string;
    /** Format: date-time */
    created_at: string;
    created_by: string;
    updated_by?: string;
    /** Format: date-time */
    updated_at: string;
    /** @example 1 */
    version: number;
  };
  PayExGwCredential: definitions["CredentialResponse"] & {
    data: {
      payee_id: string;
      /** Format: uri */
      url: string;
      subsite?: string;
    };
  };
  KlarnaGwCredential: definitions["CredentialResponse"] & {
    data: {
      username: string;
      /** Format: uri */
      url: string;
    };
  };
  /** @description configuration options for the gateway. */
  CollectorCredentialOptions: {
    customer_client?: {
      customers_client_id?: string;
      customers_client_secret?: string;
      customers_client_audience?: string;
    };
    /**
     * @description Create the collector transaction with status `ON_HOLD` and let
     * the Collector callback update the transaction state from `ON_HOLD`
     * to `AUTHORIZED` or `FAILED`.
     *
     * A callback will be sent to the `callback_url` when the transaction
     * changes state from `ON_HOLD` to any new state.
     *
     * @default false
     */
    enable_on_hold?: boolean;
    /**
     * @description The field(s) used to populate the settlement reference.
     * The `store_id` in this context is `order.store.id` from session, not to be confused with a store_id from Collector stores.
     *
     * @default account_id
     * @enum {string}
     */
    settlement_reference_fields?: "account_id" | "account_id.store_id";
  };
  CollectorGwCredential: definitions["CredentialResponse"] & {
    data: {
      /** Format: uri */
      url: string;
      /** @description Merchant's username at Collector Bank */
      username: string;
      password?: string;
      /** @description store_id for gateway credential */
      store_id: number;
      /**
       * Format: iso-3166-1
       * @description country for gateway credential
       */
      country: string;
      options?: definitions["CollectorCredentialOptions"];
    };
  };
  CheckoutConfig: {
    /** @description The user/client created the resource */
    created_by?: string;
    /**
     * Format: date-time
     * @description Time when the resource was last updated
     */
    updated_at?: string;
    /** @description Configure payment gateways */
    gateways?: {
      bambora?: definitions["BamboraGwRead"];
      instabank?: definitions["InstabankGwRead"];
      klarna?: definitions["KlarnaGwRead"];
      payex?: definitions["PayExGwRead"] & {
        /** @description Alternative versions of the configuration */
        versions?: {
          [key: string]: definitions["PayExGwOverrideRead"] &
            definitions["GwVersion"];
        };
        /** @description Configuration overrides by store id */
        overrides?: {
          [key: string]: {
            override: definitions["PayExGwOverrideRead"];
            /** @description Alternative versions of the override */
            versions?: {
              [key: string]: definitions["PayExGwOverrideRead"] &
                definitions["GwVersion"];
            };
          };
        };
      };
      vipps?: definitions["VippsGwRead"] & {
        overrides?: {
          [key: string]: {
            override: definitions["VippsGwStoreOverrideRead"];
          };
        };
      };
      collector?: definitions["CollectorGwRead"] & {
        overrides?: {
          [key: string]: {
            override: definitions["CollectorGwStoreOverrideRead"];
          };
        };
      };
      santander?: definitions["SantanderGwRead"] & {
        overrides?: {
          [key: string]: {
            override: definitions["SantanderGwStoreOverrideRead"];
          };
        };
      };
      dintero_psp?: definitions["DinteroPspGwRead"];
      netaxept?: definitions["NetaxeptGwRead"] & {
        overrides?: {
          [key: string]: {
            override: definitions["NetaxeptGwRead"];
          };
        };
      };
      swish?: definitions["SwishGwRead"] & {
        overrides?: {
          [key: string]: {
            override: definitions["SwishGwStoreOverrideRead"];
          };
        };
      };
    };
    credentials?: {
      payex?: definitions["PayExGwCredential"][];
      klarna?: definitions["KlarnaGwCredential"][];
      collector?: definitions["CollectorGwCredential"][];
    };
  };
  CheckoutConfigWrite: {
    /** @description Configure merchant and payment options */
    configuration: {
      /**
       * @description Payout configuration
       *
       * NB: Only Dintero admin users can change the payout configuration.
       */
      payout?: {
        /** @description The payment products where payout is enabled */
        payment_products: {
          /**
           * @description Payment product
           * @enum {string}
           */
          payment_product: "bambora" | "collector" | "payex" | "klarna";
        }[];
      };
      /**
       * @description Payment options enabled for the account, the
       * payment option currencies set must be unique given
       * the `type`
       */
      payment_options: {
        /** @enum {string} */
        type:
          | "bambora.creditcard"
          | "bambora.mobilepay"
          | "bambora.vipps"
          | "collector.finance"
          | "collector.installment"
          | "collector.invoice"
          | "collector.invoice_b2b"
          | "collector.invoice_b2b_preapproved"
          | "collector.installment_b2b_preapproved"
          | "dintero.zero"
          | "dintero.wallets"
          | "dintero_psp.creditcard"
          | "instabank.finance"
          | "instabank.installment"
          | "instabank.invoice"
          | "instabank.postponement"
          | "netaxept.creditcard"
          | "payex.creditcard"
          | "payex.mobilepay"
          | "payex.swish"
          | "payex.vipps"
          | "payex.applepay"
          | "payex.clicktopay"
          | "payex.googlepay"
          | "santander.debit_account"
          | "swish.swish"
          | "vipps"
          | "klarna.klarna"
          | "klarna.billie";
        /** @description configuration details for the payment option */
        details?: {
          /**
           * @description The token scope to use when generating a token,
           * the value override the configured gateway `token_scope`
           */
          bambora_token_scope?: string;
          /** @description Specify the API version to use when handling the payment type */
          gateway_api_versions?: ("payex.v2" | "payex.v3")[];
          /**
           * @description For `collector.invoice_b2b`. By default, the shipping_address B2B payments will be restricted to
           * the registered addresses of a company.
           *
           * @default false
           */
          disable_collector_b2b_address_enforcement?: boolean;
          /**
           * @description Create the collector transaction with status `ON_HOLD` and let
           * the Collector callback update the transaction state from `ON_HOLD`
           * to `AUTHORIZED` or `FAILED`.
           *
           * A callback will be sent to the `callback_url` when the transaction
           * changes state from `ON_HOLD` to any new state.
           *
           * This will override the gateway config `options.enable_on_hold`-setting.
           */
          enable_on_hold?: boolean;
        };
        /** @description Accepted currencies for payment option */
        currencies: string[];
      }[];
      merchant: definitions["Merchant"];
    };
  };
  SessionPayPollStatus: {
    keep_polling?: boolean;
    /**
     * @description redirect url to complete payment, will not be included
     * if the payment failed with `Rejected` error as payment
     * can be completed by choosing alternative payment option.
     */
    redirect_url?: string;
    /**
     * @description poll_url to check the status of the payment.
     * Will be included if the payment is dependent on
     * 3rd party apps, such as Swish.
     */
    poll_url?: string;
  };
  BamboraGwWrite: definitions["BamboraGwRead"] & {
    access_token: string;
    secret_token: string;
    md5_key: string;
  };
  /**
   * @description Use the credential to configure gateway and/or gateway overrides.
   *
   * The new configuration will be used when new payment sessions is
   * created.
   *
   * New credential will be created from the old configuration and they
   * will be used when updating existing transactions
   */
  PromoteCredential: {
    /** @enum {string} */
    type: "default" | "override";
    /**
     * @description The `store_id` in case type is `override`, otherwise, when the
     * type is `default` the value must be set to empty value
     */
    value: string;
  };
  CollectorCredential: {
    /** @description The unique id that identifies the credential (store_id) */
    name: string;
    description?: string;
    data: {
      /** Format: uri */
      url: string;
      /** @description Merchant's username at Collector Bank */
      username: string;
      password: string;
      /** @description store_id for gateway credential */
      store_id: number;
      /**
       * Format: iso-3166-1
       * @description country for gateway credential
       */
      country: string;
      options?: definitions["CollectorCredentialOptions"];
    };
    /**
     * @description Use the credential to configure gateway and/or gateway overrides
     * Will create new credential from existing gateway / override so existing
     * transactions created with the old configuration can continue to work
     */
    promote?: (definitions["PromoteCredential"] & {
      /**
       * @description Configure the collector gateway / override with aditional stores
       * that can be used with the new credential
       */
      stores?: {
        /** @description store_id for gateway credential */
        store_id: number;
        /**
         * Format: iso-3166-1
         * @description country for gateway credential
         */
        country: string;
        /**
         * @description The type of customers this store id is used for
         * @enum {string}
         */
        segment: "B2C" | "B2B";
      }[];
    })[];
  };
  CollectorGwStoreOverrideWrite: definitions["CollectorGwStoreOverrideRead"] & {
    password: string;
    options?: {
      customer_client?: {
        customers_client_id?: string;
        customers_client_secret?: string;
        customers_client_audience?: string;
      };
    };
  };
  CollectorGwWrite: definitions["CollectorGwRead"] & {
    password: string;
    options?: {
      customer_client?: {
        customers_client_id?: string;
        customers_client_secret?: string;
        customers_client_audience?: string;
      };
    };
  };
  GatewayStatusResponse: {
    /**
     * @description The id of the override that the status should be checked for. If empty, checks the root gateway config.
     *
     * @example STORE_1
     */
    override_id?: string;
  };
  InstabankGwWrite: definitions["InstabankGwRead"];
  KlarnaGwWrite: definitions["KlarnaGwRead"] & {
    /**
     * @description A string which is associated with your Merchant ID and is used to
     * authorize use of Klarna's APIs
     */
    password: string;
  };
  KlarnaCredential: {
    /** @description The unique id that identifies the credential (username) */
    name: string;
    description?: string;
    data: definitions["KlarnaGwWrite"];
    /**
     * @description Use the credential to configure gateway
     * Will create new credential from existing gateway so existing
     * transactions created with the old configuration can continue to work
     */
    promote?: {
      /** @enum {string} */
      type: "default";
      /**
       * @description When the type is `default` the value must be set to empty value
       *
       * @enum {string}
       */
      value?: "";
    }[];
  };
  NetaxeptGwWrite: definitions["NetaxeptGwRead"] & {
    token: string;
  };
  /** @description Override for sale location for Netaxept gateway */
  NetaxeptGwStoreOverride: definitions["NetaxeptGwWrite"];
  PayExGwWrite: definitions["PayExGwRead"] & {
    payee_id: string;
    token: string;
  };
  PayExCredential: {
    /** @description The unique id that identifies the credential (payee_id) */
    name: string;
    description?: string;
    data: definitions["PayExGwWrite"];
    /**
     * @description Use the credential to configure gateway and/or gateway overrides
     * Will create new credential from existing gateway / override so existing
     * transactions created with the old configuration can continue to work
     */
    promote?: definitions["PromoteCredential"][];
  };
  /** @description Override for sales location for PayEx GW */
  PayExGwStoreOverride: definitions["PayExGwWrite"];
  GwVersionWrite: {
    /**
     * @description Configure version to support multiple configurations.
     * Multiple configurations is needed if the merchant aggrement is
     * changed and there are existing transactions created with the
     * previous aggrement that still need to be updated.
     */
    version?: {
      /** @description Version id, allowing existing version to be updated. */
      id: string;
    } & definitions["GwVersion"];
  };
  SantanderGwStoreOverrideWrite: definitions["SantanderGwStoreOverrideRead"] & {
    store_token: string;
  };
  SantanderGwWrite: definitions["SantanderGwRead"] & {
    store_token: string;
    /** @description Certificate stored as base64-encoded string */
    cert?: string;
    /** @description Certificate password */
    cert_password?: string;
    customers_client_id: string;
    customers_client_secret: string;
    customers_client_audience: string;
  };
  SwishGwStoreOverrideWrite: definitions["SwishGwStoreOverrideRead"];
  SwishGwWrite: definitions["SwishGwRead"] & {
    /**
     * @description Base 64 encoded string of the certificate. Can be in PEM or P12 format.
     * If PEM, key and ca are required.
     */
    cert: string;
    /** @description Base 64 encoded string of the public key */
    key?: string;
    /** @description The passphrase for the certificate */
    passphrase: string;
    /** @description Base 64 encoded string of the CA of the certificate */
    ca?: string;
  };
  VippsGwStoreOverrideWrite: definitions["VippsGwStoreOverrideRead"] & {
    client_secret: string;
  };
  VippsGwWrite: definitions["VippsGwRead"] & {
    client_secret: string;
    ocp_apim_subscription_key_access_token: string;
    ocp_apim_subscription_key_ecom: string;
  };
  ProfileConfiguration: {
    url?: {
      /**
       * Format: uri
       * @description URL to a webpage with the merchant's Terms of Service. Will be linked to from the checkout.
       *
       * @example https://example.com/terms.html
       */
      merchant_terms_url?: string;
    };
    /**
     * @description The profile_id you have defined for the profile.
     * (must not have trailing or leading spaces)
     * An auto-generated profile_id will be created if no
     * profile_id is provided.
     */
    profile_id?: string;
    merchant?: definitions["Merchant"];
    configuration: definitions["PaymentConfiguration"] &
      definitions["DiscountsConfiguration"] &
      definitions["SessionThemeConfiguration"] &
      definitions["CountryConfiguration"];
    /** @description description of the profile */
    description: string;
    checkboxes?: definitions["CheckboxConfiguration"];
  };
  ProfileConfigurationResponse: {
    /** @description The user/client created the resource */
    created_by: string;
    /**
     * Format: date-time
     * @description Time when the resource was created
     */
    created_at: string;
    /**
     * Format: date-time
     * @description Time when the resource was last updated
     */
    updated_at: string;
    /** @description The user/client deleted the resource */
    deleted_by?: string;
    /**
     * Format: date-time
     * @description Time when the resource was deleted
     */
    deleted_at?: string;
  };
  SignatureV0: definitions["Id"] & {
    created_by?: string;
    /**
     * @description Secret used when creating Dintero-Signature header of
     * server-to-serer callbacks
     */
    signature?: {
      /** @enum {string} */
      type?: "v0-hmac-sha256";
      secret?: string;
    };
  };
  /** @description Swish payment callback */
  SwishPaymentCallback: {
    /** @description Payment request id */
    id: string;
    payeePaymentReference?: string;
    paymentReference?: unknown;
    amount?: unknown;
    datePaid?: unknown;
    /** @enum {string} */
    status: "CREATED" | "PAID" | "DECLINED" | "ERROR";
  };
  /** @description Swish payment callback */
  SwishRefundCallback: {
    /** @description Refund id */
    id: string;
    /** @description Used to identify the payment */
    originalPaymentReference: string;
    amount?: unknown;
    datePaid?: unknown;
    /** @enum {string} */
    status: "VALIDATED" | "DEBITED" | "PAID" | "ERROR";
  };
  PayExCallback: {
    paymentOrder?: {
      /** @example /psp/paymentorders/11111111-1111-1111-1111-111111111111 */
      id: string;
      /**
       * @description CreditCard, Swish, Vipps
       * @example swish
       */
      instrument?: string;
    };
    payment: {
      /**
       * @description - Payment Instrument: CreditCard, Swish, Vipps, MobilePay
       *
       * @example /psp/<payment instrument>/payments/22222222-2222-2222-2222-22222222222
       */
      id: string;
      /** @example 222222222 */
      number?: number;
    };
    transaction?: {
      /**
       * @description - Payment Instrument: CreditCard, Swish, Vipps, MobilePay
       * - Transaction Type: Authorizations, Captures, Cancellations, Reversals
       *
       * @example /psp/<payment instrument>/payments/22222222-2222-2222-2222-222222222222/<transaction type>/33333333-3333-3333-3333-333333333333
       */
      id: string;
      /** @example 333333333 */
      number?: number;
    };
  };
  PayExV3Callback: {
    paymentOrder?: {
      /** @example /psp/paymentorders/11111111-1111-1111-1111-111111111111 */
      id: string;
      /**
       * @description CreditCard, Apple Pay, Click to Pay, Swish, Vipps, MobilePay, Google Pay
       * @example swish
       */
      instrument?: string;
    };
    payment: {
      /**
       * @description - Payment Instrument: CreditCard, Apple Pay, Click to Pay, Swish, Vipps, MobilePay, Google Pay
       *
       * @example /psp/<payment instrument>/payments/22222222-2222-2222-2222-22222222222
       */
      id: string;
      /** @example 222222222 */
      number?: number;
    };
    transaction?: {
      /**
       * @description - Payment Instrument: CreditCard, Apple Pay, Click to Pay, Swish, Vipps, MobilePay, Google Pay
       * - Transaction Type: Authorizations, Captures, Cancellations, Reversals
       *
       * @example /psp/<payment instrument>/payments/22222222-2222-2222-2222-222222222222/<transaction type>/33333333-3333-3333-3333-333333333333
       */
      id: string;
      /** @example 333333333 */
      number?: number;
    };
  };
  VippsCallback: {
    merchantSerialNumber: unknown;
    orderId: string;
    transactionInfo: {
      amount?: number;
      /** @enum {string} */
      status?:
        | "RESERVED"
        | "SALE"
        | "RESERVE_FAILED"
        | "SALE_FAILED"
        | "CANCELLED"
        | "REJECTED";
      /** Format: date-time */
      timeStamp?: string;
      transactionId?: string;
    };
  };
  CollectorPaymentDetails: {
    /** @description The payment product type corresponding to this transaction */
    payment_product_type: string;
  };
  CollectorDetails: {
    /** @description The social security number of the customer. For Norway, the length is 11. For Sweden, it's either 10 or 12 digits. */
    social_security_number: string;
  };
  CollectorAddress: {
    /** @example John */
    first_name: string;
    /** @example Doe */
    last_name: string;
    /** @description Gaustadalleen 21 */
    address_line: string;
    /** @description More details about address. */
    address_line_2?: string;
    /** @description Name of the company */
    business_name?: string;
    /** @description CO-Address if applicable. */
    co_address?: string;
    /**
     * @description The zip code / postal code of the address.
     * @example 0349
     */
    postal_code: string;
    /**
     * @description The name of the postal code
     * @example Oslo
     */
    postal_place: string;
    /**
     * Format: iso3166-alpha2
     * @description Country of the location
     * @example NO
     */
    country: string;
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /** @description The email address of a person or an organisation */
    email: string;
  };
  SantanderDetails: {
    /** @description Token to represent the account number */
    account_number_token: number;
    /** @description Optional query parameter. SMS-confirm-code. To verify the identity of the payee. */
    scc?: string;
  };
  SantanderPaymentDetails: {
    /** @description The payment product type corresponding to this transaction */
    payment_product_type: string;
  };
  InstabankDetails: {
    /** @description The email address of a person or an organisation */
    email: string;
    /** @description The social security number of the customer. Only supported for NO. */
    social_security_number: string;
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /**
     * @description income received by person from all source in smallest unit for the
     * currency. e.g. $1.5 = 150. **Required**.
     */
    total_income: number;
    /**
     * @description Customer consent for marketing in different channels
     * @default false
     */
    marketing_consent?: boolean;
  };
  InstabankPaymentDetails: {
    /** @description The payment product type corresponding to this transaction */
    payment_product_type: string;
  };
  InstabankApplication: {
    /** @description The consumer owns their house */
    owns_house: boolean;
    /**
     * @description Monthly housing cost in smallest unit for the currency. e.g. $1.5 = 150
     * **Required** if `owns_house` is `false`
     */
    monthly_house_rental?: number;
    /** @enum {string} */
    marital_status: "married" | "cohabiting" | "divorced" | "single";
    /**
     * @description **Deprecated** in favour of the top-level `total_income`.
     *
     * income received by person from all source in smallest unit for the
     * currency. e.g. $1.5 = 150.
     */
    total_income?: number;
    /** @description amount of money in smallest unit for the currency. */
    mortgage_debt?: number;
    /**
     * @description amount of money in smallest unit for the currency.
     * (credit card, consumer finances)
     */
    consumer_debt?: number;
    /** @description amount of money in smallest unit for the currency. */
    student_debt?: number;
    /**
     * @description amount of money in smallest unit for the currency.
     * (car, boat, MC)
     */
    other_secured_debt?: number;
    /** @description number of children below the age of 18 in the household */
    number_of_children: number;
    debt: {
      /** @enum {string} */
      debt_type?: "mortgage_debt" | "student_debt" | "other_secured_debt";
      /** @description amount of money in smallest unit for the currency. */
      amount?: number;
      /** @description interest rate */
      interest?: number;
      /** @description remaining duration of loan in months */
      remaining_duration_months?: number;
    }[];
  };
  SwishTransactionEventMetadata: {
    "swish:payment_request:get_payment_url"?: string;
    "swish:id"?: string;
    "swish:originalPaymentReference"?: string;
    "swish:paymentReference"?: string;
    "swish:amount"?: string;
    "swish:dateCreated"?: string;
    "swish:datePaid"?: string;
    "swish:status"?: string;
    "swish:errorCode"?: string;
    "swish:errorMessage"?: string;
  };
  KlarnaAddress: {
    /** @example John */
    first_name: string;
    /** @example Doe */
    last_name: string;
    /**
     * @description Street address.
     * @example Gaustadalleen 21
     */
    address_line: string;
    /** @description More details about address. */
    address_line_2?: string;
    /** @description Name of the company */
    business_name?: string;
    /**
     * @description The zip code / postal code of the address.
     * @example 0349
     */
    postal_code: string;
    /**
     * @description The name of the postal code
     * @example Oslo
     */
    postal_place: string;
    /**
     * Format: iso3166-alpha2
     * @description Country of the location
     * @example NO
     */
    country: string;
    /**
     * @description mobile number of a person / company, ITU/E.123 format with
     * international prefix (+PPNNNNNNNNN...)
     */
    phone_number: string;
    /** @description The email address of a person or an organisation */
    email: string;
  };
}

export interface parameters {
  /**
   * @description Feature toggles that will change how the API works.
   *
   * These feature toggles are usually the preferred way to use the API, but they break the current API.
   *
   * - strict-session-amounts: `order.amount` must equal the sum of amounts in `order.items` + `order.shipping_option.amount` when creating sessions
   *
   * @default []
   */
  FeatureToggles: "strict-session-amounts"[];
  /**
   * @description The name of the ecommerce solution
   *
   * Example: `woocommerce`
   */
  DinteroSystemName: string;
  /**
   * @description The version number of the ecommerce solution
   *
   * Example: `5.4`
   */
  DinteroSystemVersion: string;
  /**
   * @description The name of the ecommerce plugin
   *
   * Example: `Dintero.Checkout.WooCommerce`
   */
  DinteroSystemPluginName: string;
  /**
   * @description The version number of the ecommerce plugin
   *
   * Example: `2.3.4`
   */
  DinteroSystemPluginVersion: string;
  /**
   * @description A limit on the number of objects to be returned. Limit can range
   * between 1 and 100 items, and the default is 10 items.
   *
   * @default 10
   */
  Limit: number;
  /**
   * Format: checkout-id
   * @description cursor for use in pagination. starting_after is an object ID
   * that defines your place in the list. For instance, if you make
   * a list request and receive 100 objects, ending with `obj_foo`,
   * your subsequent call can include `starting_after=obj_foo`
   * in order to fetch the next page of the list.
   */
  StartingAfter: string;
  /** @description List of ids that should be included in the result. ?id=A&id=B&id=X */
  Ids: string[];
  /**
   * Format: checkout-id
   * @description The session ID
   */
  SessionId: string;
  /**
   * Format: checkout-id
   * @description The ID of the transaction
   */
  TransactionId: string;
}

export interface responses {
  /** checkout session created */
  SessionCreated: {
    schema: {
      /** @description The id of the checkout session */
      id?: string;
      /**
       * Format: uri
       * @description URL for the Checkout session
       *
       * @example https://checkout.api.dintero.com/v1/view/9ea1610a357dc8189081c4cb955f26f612d91367
       */
      url?: string;
      publish?: definitions["PublishConfiguration"];
      session?: definitions["Id"] &
        definitions["Session"] &
        definitions["SessionRead"] &
        definitions["SessionCancelled"];
    };
  };
  /** Bad / Invalid request */
  BadRequest: {
    schema: definitions["Error"];
  };
  /** Access forbidden, invalid JWT token was used */
  AccessForbidden: {
    schema: definitions["Error"];
  };
  /** Forbidden */
  Forbidden: {
    schema: definitions["Error"];
  };
  /** Unexpected Error */
  ServerError: {
    schema: definitions["Error"];
  };
  /** Resource was not found */
  NotFound: {
    schema: definitions["Error"];
  };
  /** Precondition failed */
  PreconditionFailed: {
    schema: definitions["Error"];
  };
  /** Redirect to session accept/cancel URL on payment completed */
  RedirectToSessionReturnUrl: unknown;
  /** Payment Operations */
  PaymentOperations: {
    schema: definitions["PaymentOperations"] &
      definitions["SessionEventVersion"];
  };
  /** Processor temporarily unavailable */
  ProcessorTemporarilyUnavailable: {
    schema: definitions["Error"];
  };
  /** Request accepted for processing. */
  TransactionOperationAccepted: {
    headers: {};
    schema: definitions["Transaction"];
  };
  /** Conflict */
  Conflict: {
    schema: definitions["Error"];
  };
}

export interface operations {
  /**
   * Create a corresponding Checkout Session for an order placed in your system
   * using predefined session profile
   *
   * #### Session with Instabank
   *
   * Note that `items` is a required property when creating a session with
   * Instabank configured.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  checkout_session_profile_post: {
    parameters: {
      body: {
        options: definitions["SessionProfile"] &
          definitions["SessionCustomerTokens"] &
          definitions["SessionCustomerGiftcards"] &
          definitions["Metadata"];
      };
      query: {
        /** Include all details about the session created */
        include_session?: boolean;
      };
      header: {
        /**
         * Feature toggles that will change how the API works.
         *
         * These feature toggles are usually the preferred way to use the API, but they break the current API.
         *
         * - strict-session-amounts: `order.amount` must equal the sum of amounts in `order.items` + `order.shipping_option.amount` when creating sessions
         */
        "Dintero-Feature-Toggles"?: parameters["FeatureToggles"];
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      200: responses["SessionCreated"];
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * List all Checkout sessions
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  checkout_sessions_get: {
    parameters: {
      query: {
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["Limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, ending with `obj_foo`,
         * your subsequent call can include `starting_after=obj_foo`
         * in order to fetch the next page of the list.
         */
        starting_after?: parameters["StartingAfter"];
        /** List of ids that should be included in the result. ?id=A&id=B&id=X */
        id?: parameters["Ids"];
        /**
         * Will try to match the search to either merchant_reference, merchant_reference_2,
         * or the customer name using the format `{first_name} {last_name}`.
         */
        search?: string;
        /** The id(s) of the transaction(s) that should be included in the result */
        transaction_id?: string[];
        /** Session created after (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "created_at.gte"?: string;
        /** Session created before a date (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "created_at.lte"?: string;
        /** The store_id that the session relates to. ?store_id=A&store_id=B&store_id=X. */
        store_id?: string[];
        /** The dintero-system-plugin-name that the session was created with. */
        "initiating_system.dintero_system_plugin_name"?: string[];
        /** Filter on `payment_operation`: `unscheduled_purchase`, `recurring_purchase`, `generate_payment_token` */
        payment_operation?: string;
      };
    };
    responses: {
      /** list checkout sessions */
      200: {
        schema: (definitions["Id"] &
          definitions["Session"] &
          definitions["SessionRead"] &
          definitions["SessionCancelled"])[];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Create a corresponding Checkout Session for an order placed in your system
   *
   * #### Session with Instabank
   *
   * Note that `items` is a required property when creating a session with
   * Instabank configured.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  checkout_session_post: {
    parameters: {
      body: {
        options: definitions["SessionOptions"] &
          definitions["SessionCustomerTokens"] &
          definitions["SessionCustomerGiftcards"] &
          definitions["Metadata"] & {
            merchant?: definitions["Merchant"];
          };
      };
      query: {
        /** Include all details about the session created */
        include_session?: boolean;
      };
      header: {
        /**
         * Feature toggles that will change how the API works.
         *
         * These feature toggles are usually the preferred way to use the API, but they break the current API.
         *
         * - strict-session-amounts: `order.amount` must equal the sum of amounts in `order.items` + `order.shipping_option.amount` when creating sessions
         */
        "Dintero-Feature-Toggles"?: parameters["FeatureToggles"];
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      200: responses["SessionCreated"];
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  checkout_session_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      query: {
        /**
         * Include aditional data that are by default excluded from the session details.
         *
         * - **`events.request_headers`** Include the event headers stored for each event
         * - **`initiating_system_request_headers`** Include the request headers from the initating system
         */
        includes?: (
          | "events.request_headers"
          | "initiating_system_request_headers"
        )[];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["Session"] &
          definitions["SessionRead"] &
          definitions["SessionCancelled"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Session must be locked for paying before updating.
   *
   * **Requirements**:
   * - `order.shipping_option` must be included in `express_shipping_options` if both are set.
   * - `order.amount` must be equal to the sum of `order.items` and `order.shipping_option`
   *
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  checkout_session_put: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      query: {
        /**
         * If `express.shipping_options` is set, there will not be a callback to `shipping_address_callback_url`,
         * unless `force_shipping_address_callback` is also set.
         *
         * If `express.shipping_options` is not set, there will be a callback to `shipping_address_callback_url`.
         */
        force_shipping_address_callback?: boolean;
        /**
         * Allow updating session without it having been locked first.
         *
         * Allowed for server-to-server when the checkout has not been rendered yet.
         */
        update_without_lock?: boolean;
      };
      body: {
        options: definitions["UpdateSessionOptions"];
      };
      header: {
        /**
         * Feature toggles that will change how the API works.
         *
         * These feature toggles are usually the preferred way to use the API, but they break the current API.
         *
         * - strict-session-amounts: `order.amount` must equal the sum of amounts in `order.items` + `order.shipping_option.amount` when creating sessions
         */
        "Dintero-Feature-Toggles"?: parameters["FeatureToggles"];
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["Session"] &
          definitions["SessionRead"] &
          definitions["SessionCancelled"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Cancel a session
   *
   * The session transaction will be voided in case where it is
   * initialized or authorized.
   *
   * Cancel is not allowed in case where the current transaction
   * state is not initialized or authorized.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  checkout_session_cancel_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["Session"] &
          definitions["SessionRead"] &
          definitions["SessionCancelled"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Generate a QR Code containing the URL for the Checkout Session.
   * The QR Code can be displayed in POS to enable Checkout payment.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  qr_sessions_sid_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      body: {
        options: definitions["QROptions"];
      };
    };
    responses: {
      /** QR Code */
      200: {
        schema: definitions["QRCode"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * This endpoint lets you create payment and recurrence tokens without reserving
   * or charging any amount.
   *
   * The URL returned by this endpoint opens a web site where the customer
   * can enter their payment details, e.g. card information.
   *
   * The payment details will be validated and a transaction with a
   * payment/recurrence token will be created on success containing the payment
   * token created from the customer payment details.
   *
   * - [GET /v1/transactions/{id}?includes=card.payment_token](#operation/transactions_id_get)
   * - [GET /v1/transactions/{id}?includes=card.recurrence_token](#operation/transactions_id_get)
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  checkout_payment_token_session_post: {
    parameters: {
      body: {
        options: {
          /** @description The session to create the payment token from */
          session: definitions["SessionPaymentToken"] & definitions["Metadata"];
          /** @description The type of token to fetch */
          token_provider: definitions["TokenProvider"];
        };
      };
      query: {
        /** Include all details about the session created */
        include_session?: boolean;
      };
      header: {
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      200: responses["SessionCreated"];
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * For Express Checkout sessions, the _`order.shipping_address`_ must be set on
   * the session, and a _`order.items.shipping_option` item is required if the
   * session has either an _`express.shipping_address_callback_url`_ or the
   * session has at least one option in _`express.shipping_options`_.
   */
  checkout_sid_pay_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /** Optional header. The put request is discarded and a 412 is returned if the header does not match the `updated_at` property or the `version` of the session. */
        "If-Unmodified-Since"?: string;
      };
      body: {
        payment: definitions["Payment"];
      };
    };
    responses: {
      /** response from payment */
      200: {
        schema: definitions["PaymentResponse"];
      };
      /** response from payment */
      202: {
        schema: definitions["PaymentResponse"];
      };
      400: responses["BadRequest"];
      412: responses["PreconditionFailed"];
    };
  };
  checkout_sid_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  /**
   * For merchant initiated payments, where the customer is not involved.
   *
   * Receives a session and pays it with the given card token.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  checkout_session_pay_post: {
    parameters: {
      header: {
        /**
         * - **`strict-merchant-reference`**: The `session.order.merchant_reference`
         *   must be unique. The pay request will fail with `400 BadRequest` error
         *   if `merchant_reference` is duplicated by existing session.
         * - **`strict-success-merchant-reference`**: The `session.order.merchant_reference`
         *   must be unique. The pay request will fail with `400 BadRequest` error
         *   if `merchant_reference` is duplicated by existing session that was successfully
         *   authorized. This flag is less strict than **`strict-merchant-reference`**, allowing
         *   for duplicates session if previous session failed
         */
        "Dintero-Feature-Toggles"?: (
          | "strict-merchant-reference"
          | "strict-success-merchant-reference"
        )[];
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
      body: {
        options: {
          /** @description The session to create the payment from */
          session?: definitions["PaySessionOptions"] &
            definitions["SessionCustomerTokens"] &
            definitions["Metadata"];
          /** @description Details to complete the payment */
          payment?: definitions["PayPayment"];
        };
      };
    };
    responses: {
      /** Transaction created */
      200: {
        schema: definitions["Transaction"] & definitions["SessionPayResult"];
      };
      /** Bad / Invalid request */
      400: {
        schema: definitions["Error"] & definitions["SessionPayResult"];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      /** Unexpected Error */
      500: {
        schema: definitions["Error"] & definitions["SessionPayResult"];
      };
      /** Request failed with 4XX error */
      default: {
        schema: definitions["Error"] & definitions["SessionPayResult"];
      };
    };
  };
  checkout_sid_html_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      query: {
        language?: string;
        ui?: "fullscreen" | "inline" | "modal";
        /** Optional query parameter. SMS-confirm-code. To verify the identity of the payee. */
        scc?: string;
      };
    };
    responses: {
      /** Checkout page */
      302: never;
    };
  };
  checkout_sid_payments_product_type_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        payment_product_type:
          | "bambora.creditcard"
          | "collector.installment"
          | "collector.invoice"
          | "collector.invoice_b2b"
          | "collector.invoice_b2b_preapproved"
          | "dintero_psp.creditcard"
          | "payex.creditcard"
          | "payex.mobilepay"
          | "payex.swish"
          | "payex.vipps"
          | "payex.applepay"
          | "payex.clicktopay"
          | "payex.googlepay"
          | "santander.debit_account"
          | "klarna.klarna"
          | "klarna.billie";
      };
      query: {
        /** Preferred language to use in the payment operation */
        language?: string;
        /** Preferred phone number to use in the payment operation */
        phone_number?: string;
        /** Preferred email to use in the payment operation */
        email?: string;
        /** The organization number that the payment is for. */
        organization_number?: string;
        /** The country to ship to. Required for `klarna` payment types. */
        country?: string;
      };
    };
    responses: {
      200: responses["PaymentOperations"];
      400: responses["BadRequest"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  checkout_sid_json_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["SessionOptions"] &
          definitions["SessionRead"] &
          definitions["SessionOperations"] &
          definitions["SessionLock"] &
          definitions["SessionEventVersion"];
      };
      /** Session not found error */
      404: {
        schema: definitions["SessionNotFound"];
      };
      500: responses["ServerError"];
    };
  };
  /** Abandon a checkout payment before completing payment. */
  view_sid_session_abandon_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: string;
      };
    };
    responses: {
      /** Rejected to session URL with status cancelled */
      302: never;
      404: responses["NotFound"];
    };
  };
  /**
   * When locked, the session can not be paid.
   * Locking the session is only available when express is enabled.
   */
  checkout_sid_lock: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
    responses: {
      /** Information about the lock */
      200: {
        schema: definitions["SessionLock"];
      };
      400: responses["BadRequest"];
      412: responses["PreconditionFailed"];
    };
  };
  /**
   * Changes the `order.shipping_address` and `order.billing_address` submitted by end user in the Express Checkout flow.
   *
   * If the _`express.shipping_address_callback_url`_ is set, the _`express.shipping_options`_
   * in the response will be updated to show the available shipping options for
   * the updated address.
   *
   * Also changes the checkboxes that are part of the session as they are
   * checked or unchecked by the end user in the Express Checkout flow.
   */
  checkout_sid_json_order_addresses_put: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /** Optional header. The put request is discarded and a 412 is returned if the header does not match the `updated_at` property of the session. */
        "If-Unmodified-Since"?: string;
      };
      body: {
        options: definitions["ViewSessionUpdateAddress"];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["SessionOptions"] &
          definitions["SessionRead"] &
          definitions["SessionOperations"] &
          definitions["SessionEventVersion"];
      };
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
      500: responses["ServerError"];
    };
  };
  /**
   * Changes the `order.discount_codes` submitted by end user in the Express Checkout flow.
   *
   * If the _`express.discount_codes_callback_url`_ is set, the session will be
   * updated with discount on the order and the shipping options.
   */
  checkout_sid_json_order_discount_codes_put: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /** Optional header. The put request is discarded and a 412 is returned if the header does not match the `updated_at` property of the session. */
        "If-Unmodified-Since"?: string;
      };
      body: {
        options: definitions["ViewSessionUpdateDiscountCodes"];
      };
    };
    responses: {
      /** Session updated with discounts */
      200: {
        schema: definitions["Id"] &
          definitions["SessionOptions"] &
          definitions["SessionRead"] &
          definitions["SessionOperations"] &
          definitions["SessionEventVersion"];
      };
      /** No discounts */
      204: never;
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
      500: responses["ServerError"];
    };
  };
  /**
   * Change the active `gift_cards` for the session. Updating with empty gift cards
   * removes all gift cards from the session
   */
  checkout_sid_json_order_gift_cards_put: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /** Optional header. The put request is discarded and a 412 is returned if the header does not match the `updated_at` property of the session. */
        "If-Unmodified-Since"?: string;
      };
      body: {
        options: definitions["ViewSessionUpdateGiftcards"];
      };
    };
    responses: {
      /** Session updated with gift cards */
      200: {
        schema: definitions["Id"] &
          definitions["SessionOptions"] &
          definitions["SessionRead"] &
          definitions["SessionOperations"] &
          definitions["SessionEventVersion"];
      };
      /** No gift cards used */
      204: never;
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
      500: responses["ServerError"];
    };
  };
  /**
   * **Deprecated** in favor of [PUT /v1/view/{session_id}/session/order/addresses](#operation/checkout_sid_json_order_addresses_put)
   *
   * Changes the order.shipping_address, submitted by end user in the Express Checkout flow.
   *
   * If the _`express.shipping_address_callback_url`_ is set, the _`express.shipping_options`_
   * in the response will be updated to show the available shipping options for
   * the updated address.
   */
  checkout_sid_json_order_shipping_address_put: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /** Optional header. The put request is discarded and a 412 is returned if the header does not match the `updated_at` property of the session. */
        "If-Unmodified-Since"?: string;
      };
      body: {
        options: definitions["OrderAddress"];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["SessionOptions"] &
          definitions["SessionRead"] &
          definitions["SessionOperations"] &
          definitions["SessionEventVersion"];
      };
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
      500: responses["ServerError"];
    };
  };
  /** Changes the selected shipping_option, submitted by end user in the  Express Checkout flow. */
  checkout_sid_json_order_items_shipping_option_put: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      header: {
        /** Optional header. The put request is discarded and a 412 is returned if the header does not match the `updated_at` property of the session. */
        "If-Unmodified-Since"?: string;
      };
      body: {
        options: definitions["SplitShippingOption"];
      };
    };
    responses: {
      /** checkout session */
      200: {
        schema: definitions["Id"] &
          definitions["SessionOptions"] &
          definitions["SessionRead"] &
          definitions["SessionOperations"] &
          definitions["SessionEventVersion"];
      };
      404: responses["NotFound"];
      412: responses["PreconditionFailed"];
      500: responses["ServerError"];
    };
  };
  /** Send a SMS with a payment verification code */
  checkout_sid_send_scc: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
    responses: {
      /** Verification code sent */
      200: unknown;
      /** Verification code resent */
      202: unknown;
      400: responses["BadRequest"];
    };
  };
  /**
   * This API endpoint on the merchant side allows Dintero to get
   * shipping_options and order with discounts based on the provided
   * session that had its `order.discount_codes` updated.
   */
  example_discount_codes_callback_url: {
    parameters: {
      body: {
        options: definitions["Id"] &
          definitions["Session"] &
          definitions["SessionRead"];
      };
    };
    responses: {
      /** Session Discount update */
      200: {
        schema: {
          order?: definitions["DiscountCodesOrderUpdate"];
          /**
           * @description Shipping options that will be presented to the end user after the
           * callback
           *
           * - If the merchant is not able to ship the order to the end users
           *   shipping address, use an empty array.
           * - If there is only one option, a free delivery, the order still
           *   has to contain one option with a _`price.amount`_ of 0.
           */
          shipping_options: definitions["SplitShippingOption"][];
        };
      };
    };
  };
  /**
   * This API endpoint on the merchant side allows Dintero to notify
   * the `session.url.callback_url` when the payment is completed
   *
   * > The `transaction_id` is optional if `report_error=true`
   */
  example_session_get_callback_url: {
    parameters: {
      header: {
        /**
         * Dintero signature that can be used to verify the payload from the
         * callback.
         *
         * Only include if a signature secret exist:
         *
         * - [POST /v1/admin/signature](#operation/admin_signature_post)
         */
        "Dintero-Signature"?: string;
      };
      query: {
        /** The Id for the transaction created */
        transaction_id: string;
        /** Session Id. Either `session_id` or `sid` is required. */
        session_id?: string;
        /** Session Id if `sid_parameter_name=sid`. Either `session_id` or `sid` is required. */
        sid?: string;
        /** The merchants reference */
        merchant_reference: string;
        /** ISO 8601 format for when the transaction was created */
        time: string;
        /** Error code */
        error?: string;
        /** Event applied to transaction */
        event?: string;
        /** Id for the event applied to transaction */
        event_id?: string;
        /** The method to use when delivering the callback */
        method?: string;
        /** Report error callback */
        report_error?: boolean;
        /** Delay before delivering the callback */
        delay_callback?: number;
        /** Deliver callback on othe transaction events */
        report_event?: string;
      };
    };
    responses: {
      /** Callback handled */
      200: {
        schema: { [key: string]: unknown };
      };
    };
  };
  /**
   * This API endpoint on the merchant side allows Dintero to notify
   * the `session.url.callback_url` when the payment is completed
   * > POST is only use if `callback_url` includes `method=POST` query parameter.
   *
   * > The `body` and `transaction_id` is optional if `report_error=true`
   */
  example_session_post_callback_url: {
    parameters: {
      header: {
        /**
         * Dintero signature that can be used to verify the payload from the
         * callback.
         *
         * Only include if a signature secret exist:
         *
         * - [POST /v1/admin/signature](#operation/admin_signature_post)
         */
        "Dintero-Signature"?: string;
      };
      query: {
        /** The Id for the transaction created */
        transaction_id: string;
        /** Session Id. Either `session_id` or `sid` is required. */
        session_id?: string;
        /** Session Id if `sid_parameter_name=sid`. Either `session_id` or `sid` is required. */
        sid?: string;
        /** The merchants reference */
        merchant_reference: string;
        /** ISO 8601 format for when the transaction was created */
        time: string;
        /** Error code */
        error?: string;
        /** Event applied to transaction */
        event?: string;
        /** Id for the event applied to transaction */
        event_id?: string;
        /** POST method used to deliver the callback */
        method: string;
        /** Report error callback */
        report_error?: boolean;
        /** Delay before delivering the callback */
        delay_callback?: number;
        /** Deliver callback on othe transaction events */
        report_event?: string;
        /** Aditional data included */
        includes: string;
      };
      body: {
        body?: definitions["Transaction"];
      };
    };
    responses: {
      /** Callback handled */
      200: {
        schema: { [key: string]: unknown };
      };
    };
  };
  /**
   * This API endpoint on the merchant side allows Dintero to get
   * shipping options based on the provided session after an address
   * update
   */
  example_shipping_address_callback_url: {
    parameters: {
      body: {
        options: definitions["Id"] &
          definitions["Session"] &
          definitions["SessionRead"];
      };
    };
    responses: {
      /** Session shipping options update */
      200: {
        schema: {
          /**
           * @description Shipping options that will be presented to the end user after the
           * callback
           *
           * - If the merchant is not able to ship the order to the end users
           *   shipping address, use an empty array.
           * - If there is only one option, a free delivery, the order still
           *   has to contain one option with a _`price.amount`_ of 0.
           */
          shipping_options: definitions["SplitShippingOption"][];
          order?: definitions["ShippingAddressCallbackSessionOrderUpdate"];
        };
      };
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  transactions_get: {
    parameters: {
      query: {
        /** List of ids that should be included in the result. ?id=A&id=B&id=X */
        id?: parameters["Ids"];
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["Limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, ending with `obj_foo`,
         * your subsequent call can include `starting_after=obj_foo`
         * in order to fetch the next page of the list.
         */
        starting_after?: parameters["StartingAfter"];
        /** The status of the transaction. */
        status?: (
          | "AUTHORIZATION_VOIDED"
          | "AUTHORIZED"
          | "CAPTURED"
          | "DECLINED"
          | "FAILED"
          | "INITIATED"
          | "ON_HOLD"
          | "PARTIALLY_CAPTURED"
          | "PARTIALLY_REFUNDED"
          | "PARTIALLY_CAPTURED_REFUNDED"
          | "REFUNDED"
          | "UNKNOWN"
        )[];
        /** The type of payment product used */
        payment_product?: string[];
        /** The payment product type */
        payment_product_type?: string[];
        /** The card brand for the payment */
        card_brand?: string[];
        /** The merchant reference used */
        merchant_reference?: string;
        /** The second merchant reference on the transaction */
        merchant_reference_2?: string;
        /** The session id(s) associated with the transactions. ?session_id=A&session_id=B&session_id=X. */
        session_id?: string[];
        /** The store_id that the transaction belongs to. ?store_id=A&store_id=B&store_id=X. */
        store_id?: string[];
        /** Filter by the `payout_correlation_id`. Different format between payment providers. ?payout_correlation_id=A,B */
        payout_correlation_id?: string[];
        /** The currency of the transaction. ?currency=NOK&currency=SEK. */
        currency?: string[];
        /** Exact transaction amount, amount authorized. */
        amount?: number;
        /** Lower limit for filtering on transaction amount, amount authorized. */
        "amount.gte"?: number;
        /** Upper limit for filtering on transaction amount, amount authorized. */
        "amount.lte"?: number;
        /** Transaction created after (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "created_at.gte"?: string;
        /** Transaction created before a date (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "created_at.lte"?: string;
        /** Transaction captured after date (This param is subject to change in the future) (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "captured_at.gte"?: string;
        /** Transaction captured before date (This param is subject to change in the future) (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "captured_at.lte"?: string;
        /** Transaction refunded after date (This param is subject to change in the future) (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "refunded_at.gte"?: string;
        /** Transaction refunded before date (This param is subject to change in the future) (ISO 8601. We recommend using a localised ISO 8601 datetime like `2017-07-21T17:32:28Z`. If a timezone is not specified we assume UTC) */
        "refunded_at.lte"?: string;
        /**
         * Will try to match the search to either transaction_id, session_id or merchant_reference, merchant_reference_2,
         * phone_number, email or the customer name using the format `{first_name} {last_name}`.
         */
        search?: string;
        /** Filter on `payment_operation` */
        payment_operation?: string;
        /** Filter transactions on the `customer.customer_id`. */
        customer_id?: string;
      };
    };
    responses: {
      /** Transactions */
      200: {
        schema: definitions["Transaction"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  transactions_id_get: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
      };
      query: {
        /**
         * Include aditional data that are by default excluded from the transaction details.
         *
         * - **`card.payment_token`**: Include the payment_token generated from the transaction.
         *   Only available for transaction with a session that enabled generate_payment_token.
         * - **`card.recurrence_token`**: Include the recurrence generated from the transaction.
         *   Only available for transaction with a session that enabled generate_recurrence_token.
         * - **`session`** Include the session that the transaction resulted from
         * - **`events.request_headers`** Include the event headers stored for each event
         * - **`initiating_system_request_headers`** Include the request headers from the initating system
         */
        includes?: (
          | "card.payment_token"
          | "card.recurrence_token"
          | "session"
          | "events.request_headers"
          | "initiating_system_request_headers"
        )[];
      };
    };
    responses: {
      /** Transaction */
      200: {
        schema: definitions["Transaction"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
      503: responses["ProcessorTemporarilyUnavailable"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  transactions_id_put: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
      };
      body: {
        data?: {
          /** @description A reference specified by the merchant to identify the transaction, can be updated after the transaction has been created */
          merchant_reference_2?: string;
        };
      };
    };
    responses: {
      /** Transaction */
      200: {
        schema: definitions["Transaction"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
      503: responses["ProcessorTemporarilyUnavailable"];
    };
  };
  /**
   * Captures a transaction that was created with the Checkout
   * endpoint with a `capture_now` value of `false`.
   *
   * #### Capture Instabank transaction
   *
   * Note that `items` is required when capturing a transaction
   * with `payment_product=instabank`. The items must include
   * the lines to Capture, with `line_id`, `quantity` and `amount`.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  transactions_id_capture_post: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
      };
      query: {
        /**
         * Include aditional data in the returned data that are by default excluded from the transaction details.
         *
         * - **`events.request_headers`** Include the event headers stored for each event **deprecated**
         * - **`initiating_system_request_headers`** Include the request headers from the initating system **deprecated**
         *
         * From 2023-09, `events.request_headers` and `initiating_system_request_headers` will be included by default
         */
        includes?: (
          | "events.request_headers"
          | "initiating_system_request_headers"
        )[];
      };
      body: {
        data?: {
          /**
           * Format: int32
           * @description The amount to be captured
           */
          amount: number;
          /**
           * @description A reference specified by the merchant to identify the
           * transaction
           */
          capture_reference?: string;
          /**
           * @description Info about the captured order items
           *
           * #### Instabank
           * `required` if the transaction `payment_product` is *instabank*.
           * The capture will then be applied to the items included.
           */
          items?: (definitions["OrderItem"] & {
            /** @description Metadata about discounts given */
            discount_lines?: definitions["DiscountItem"][];
            /**
             * @description the number of the line (or id), must be `unique` between
             * all items. `required` when Instabank payment is configured.
             *
             * @example 1
             */
            line_id: string;
            /**
             * Format: int32
             * @description The total monetary amount of the line item
             *
             * @example 29990
             */
            amount: number;
          })[];
        };
      };
      header: {
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      /** Capture created */
      200: {
        schema: definitions["Transaction"];
      };
      202: responses["TransactionOperationAccepted"];
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
      503: responses["Conflict"];
    };
  };
  /**
   * Extend authorization on transaction for greater time to capture.
   * NB: Currently only supported for Klarna.
   */
  transaction_tid_extend_authorization_post: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
      };
      body: {
        extends?: {
          /** @description The reason of the extension */
          reason?: string;
          /**
           * @description A reference specified by the merchant to identify the
           * transaction
           */
          reference?: string;
        };
      };
    };
    responses: {
      /** Transaction extended */
      200: {
        schema: definitions["Transaction"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      409: responses["Conflict"];
      500: responses["ServerError"];
    };
  };
  /**
   * Once a transaction has been successfully captured,
   * a refund operation is available. Like other operations,
   * refund can be partial or total
   *
   * #### Refund Instabank transaction
   *
   * Note that `items` is required when refunding a transaction
   * with `payment_product=instabank`. The items must include the
   * lines to Refund, with `line_id`, `quantity` and `amount`.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  transactions_id_refund_post: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
      };
      query: {
        /**
         * Include aditional data in the returned data that are by default excluded from the transaction details.
         *
         * - **`events.request_headers`** Include the event headers stored for each event **deprecated**
         * - **`initiating_system_request_headers`** Include the request headers from the initating system **deprecated**
         *
         * From 2023-09, `events.request_headers` and `initiating_system_request_headers` will be included by default
         */
        includes?: (
          | "events.request_headers"
          | "initiating_system_request_headers"
        )[];
      };
      body: {
        refunds: {
          /**
           * Format: int32
           * @description The amount to be refunded
           */
          amount: number;
          /** @description The reason of the refund */
          reason?: string;
          /**
           * @description A reference specified by the merchant to identify the
           * transaction
           */
          refund_reference?: string;
          /**
           * @description Info about the refunded order items
           *
           * #### Instabank
           * `required` if the transaction `payment_product` is *instabank*.
           * The refund will then be applied to the items included.
           */
          items?: (definitions["OrderItem"] & {
            /** @description Metadata about discounts given */
            discount_lines?: definitions["DiscountItem"][];
            /**
             * @description the number of the line (or id), must be `unique` between
             * all items. `required` when Instabank payment is configured.
             *
             * @example 1
             */
            line_id: string;
            /**
             * Format: int32
             * @description The total monetary amount of the line item
             *
             * @example 29990
             */
            amount: number;
          })[];
        };
      };
      header: {
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      /** Refund created */
      200: {
        schema: definitions["Transaction"];
      };
      202: responses["TransactionOperationAccepted"];
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
      503: responses["ProcessorTemporarilyUnavailable"];
    };
  };
  /**
   * At any moment before capture of a transaction, it is
   * possible to cancel an authorization. This operation is
   * called voiding and can be performed by doing a POST to
   * this endpoint
   *
   * #### Void on part capture
   *
   * Void after a part capture will cancel the difference between
   * the capture amount and the authorization amount.
   *
   * Void on part capture is only supported on following types:
   *   - `payex.creditcard`
   *   - `payex.mobilepay`
   *   - `payex.vipps`
   *   - `payex.applepay`
   *   - `payex.clicktopay`
   *   - `payex.googlepay`
   *   - `vipps`
   *   - `klarna.klarna`
   *   - `klarna.billie`
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  transactions_id_void_post: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
      };
      query: {
        /**
         * Include aditional data in the returned data that are by default excluded from the transaction details.
         *
         * - **`events.request_headers`** Include the event headers stored for each event **deprecated**
         * - **`initiating_system_request_headers`** Include the request headers from the initating system **deprecated**
         *
         * From 2023-09, `events.request_headers` and `initiating_system_request_headers` will be included by default
         */
        includes?: (
          | "events.request_headers"
          | "initiating_system_request_headers"
        )[];
      };
      header: {
        /**
         * The name of the ecommerce solution
         *
         * Example: `woocommerce`
         */
        "Dintero-System-Name"?: parameters["DinteroSystemName"];
        /**
         * The version number of the ecommerce solution
         *
         * Example: `5.4`
         */
        "Dintero-System-Version"?: parameters["DinteroSystemVersion"];
        /**
         * The name of the ecommerce plugin
         *
         * Example: `Dintero.Checkout.WooCommerce`
         */
        "Dintero-System-Plugin-Name"?: parameters["DinteroSystemPluginName"];
        /**
         * The version number of the ecommerce plugin
         *
         * Example: `2.3.4`
         */
        "Dintero-System-Plugin-Version"?: parameters["DinteroSystemPluginVersion"];
      };
    };
    responses: {
      /** Transaction voided */
      200: {
        schema: definitions["Transaction"];
      };
      202: responses["TransactionOperationAccepted"];
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
      503: responses["ProcessorTemporarilyUnavailable"];
    };
  };
  /**
   * Add settlement events to list of transactions
   *
   * scopes:
   * - admin:checkout
   */
  transactions_events_settlements_post: {
    parameters: {
      body: {
        data: {
          /** @description Each transaction can have multiple settlements */
          transactions: {
            /**
             * @description The transaction id
             *
             * @example P00000000.465UfBENeLpkBvwmqfTC4k
             */
            id: string;
            settlements: definitions["TransactionSettlementsWrite"];
          }[];
        };
      };
    };
    responses: {
      /** Transactions updated */
      200: {
        schema: definitions["Transaction"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_api_keys_get: {
    parameters: {
      query: {
        /** include deleted api-keys in the response */
        include_deleted?: boolean;
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["Limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, ending with `obj_foo`,
         * your subsequent call can include `starting_after=obj_foo`
         * in order to fetch the next page of the list.
         */
        starting_after?: parameters["StartingAfter"];
      };
    };
    responses: {
      /** api keys */
      200: {
        schema: definitions["ApiKeyRead"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_api_keys_post: {
    parameters: {
      body: {
        configuration: definitions["ApiKey"] &
          definitions["ApiKeyValue"] & {
            /** @description specify the api-key */
            api_key?: string;
          };
      };
    };
    responses: {
      /** api-key */
      200: {
        schema: definitions["ApiKeyRead"] & {
          api_key?: string;
        };
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_parameters_api_key_delete: {
    parameters: {
      path: {
        api_key_id: string;
      };
    };
    responses: {
      /** api-key */
      200: {
        schema: definitions["ApiKeyRead"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_api_keys_api_key_id_rotate_post: {
    parameters: {
      path: {
        api_key_id: string;
      };
    };
    responses: {
      /** api-key */
      200: {
        schema: definitions["ApiKeyRead"] & {
          api_key?: string;
        };
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  admin_checkout_id_get: {
    parameters: {
      query: {
        /**
         * Include aditional data that are by default excluded from the checkout details.
         *
         * - **`credentials`**: Include credentials details for gateways.
         *   Only available with `admin:checkout` scope.
         */
        includes?: "credentials"[];
      };
    };
    responses: {
      /** Payment configuration */
      200: {
        schema: definitions["Id"] &
          definitions["CheckoutConfig"] &
          definitions["CheckoutConfigWrite"];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_checkout_id_put: {
    parameters: {
      body: {
        configuration: definitions["CheckoutConfigWrite"];
      };
    };
    responses: {
      /** Payment configuration */
      200: {
        schema: definitions["Id"] &
          definitions["CheckoutConfig"] &
          definitions["CheckoutConfigWrite"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  checkout_sid_netaxept_html_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
      query: {
        /** Indicates which language is used in the Netaxept hosted payment window */
        language?:
          | "no_NO"
          | "sv_SE"
          | "da_DK"
          | "fi_FI"
          | "en_GB"
          | "de_DE"
          | "fr_FR"
          | "ru_RU"
          | "pl_PL"
          | "nl_NL"
          | "es_ES"
          | "it_IT"
          | "pt_PT"
          | "et_EE"
          | "lv_LV"
          | "lt_LT";
      };
    };
    responses: {
      /** Netaxept hosted payment window */
      302: never;
    };
  };
  checkout_sid_payex_payment_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        payment_id: string;
      };
      query: {
        /** Resolve payment status from PayEx */
        query_gateway?: boolean;
      };
    };
    responses: {
      /** PayEx payment completed, go to next step. */
      200: {
        schema: definitions["SessionPayPollStatus"];
      };
      /** PayEx payment not completed, keep polling. */
      202: {
        schema: definitions["SessionPayPollStatus"];
      };
      /** PayEx payment not found. */
      404: unknown;
    };
  };
  /**
   * Get status about the Swish session. Will check if the session contains a transaction_id,
   * and if the transaction is paid with the given Swish payment_request_id.
   */
  checkout_sid_swish_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        payment_request_id: string;
      };
    };
    responses: {
      /** Swish payment completed, go to next step. */
      200: {
        schema: definitions["SessionPayPollStatus"];
      };
      /** Swish payment not completed, keep polling. */
      202: {
        schema: definitions["SessionPayPollStatus"];
      };
      /** Swish payment not found. */
      404: unknown;
    };
  };
  checkout_sid_html_vipps_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
    responses: {
      /** Checkout page */
      302: never;
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_bambora_put: {
    parameters: {
      body: {
        configuration: {
          bambora: definitions["BamboraGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_gateways_collector_credentials_put: {
    parameters: {
      query: {
        /** Overwrite an existing credentials */
        overwrite?: boolean;
        validate_credential?: boolean;
      };
      body: {
        credential: definitions["CollectorCredential"];
      };
    };
    responses: {
      /** Updated */
      200: {
        schema: definitions["CredentialResponse"];
      };
      /** Created */
      201: {
        schema: definitions["CredentialResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      409: responses["Conflict"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_override_collector_put: {
    parameters: {
      body: {
        configuration?: {
          store_id: string;
          /** @description Override properties for given store. Will delete override if null. */
          override?: definitions["CollectorGwStoreOverrideWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_collector_put: {
    parameters: {
      body: {
        configuration: {
          collector: definitions["CollectorGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * verify the gateway configuration
   *
   * scopes:
   * - admin:checkout
   */
  admin_checkout_gw_type_status_post: {
    parameters: {
      path: {
        gateway:
          | "bambora"
          | "collector"
          | "instabank"
          | "netaxept"
          | "payex"
          | "santander"
          | "swish"
          | "vipps";
      };
      body: {
        payload?: definitions["GatewayStatusResponse"];
      };
    };
    responses: {
      /** Gateway status */
      200: {
        schema: {
          /** @description the gateway status */
          status?: number;
        };
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_instabank_put: {
    parameters: {
      body: {
        configuration: {
          instabank: definitions["InstabankGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_gateways_klarna_credentials_put: {
    parameters: {
      query: {
        /** Overwrite an existing credential */
        overwrite?: boolean;
        validate_credential?: boolean;
      };
      body: {
        credential: definitions["KlarnaCredential"];
      };
    };
    responses: {
      /** Updated */
      200: {
        schema: definitions["CredentialResponse"];
      };
      /** Created */
      201: {
        schema: definitions["CredentialResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      409: responses["Conflict"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_klarna_put: {
    parameters: {
      body: {
        configuration: {
          klarna: definitions["KlarnaGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_override_netaxept_put: {
    parameters: {
      body: {
        configuration?: {
          store_id: string;
          /** @description Override properties for given store. Will delete override if null. */
          override?: definitions["NetaxeptGwStoreOverride"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_netaxept_put: {
    parameters: {
      body: {
        configuration: {
          netaxept: definitions["NetaxeptGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_gateways_payex_credentials_put: {
    parameters: {
      query: {
        /** Overwrite an existing credential */
        overwrite?: boolean;
        validate_credential?: boolean;
      };
      body: {
        credential: definitions["PayExCredential"];
      };
    };
    responses: {
      /** Updated */
      200: {
        schema: definitions["CredentialResponse"];
      };
      /** Created */
      201: {
        schema: definitions["CredentialResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      409: responses["Conflict"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_override_payex_put: {
    parameters: {
      query: {
        /** keep existing override versions when updating the overridej */
        keep_versions?: boolean;
      };
      body: {
        configuration?: {
          store_id: string;
          /** @description Override properties for given store. Will delete override if null. */
          override?: definitions["PayExGwStoreOverride"] &
            definitions["GwVersionWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_payex_put: {
    parameters: {
      query: {
        /** keep existing overrides when updating the gateway */
        keep_overrides?: boolean;
        /** keep existing overrides when updating the gateway */
        keep_versions?: boolean;
      };
      body: {
        configuration: {
          payex: definitions["PayExGwWrite"] & definitions["GwVersionWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_override_santander_put: {
    parameters: {
      body: {
        configuration?: {
          store_id: string;
          /** @description Override properties for given store. Will delete override if null. */
          override?: definitions["SantanderGwStoreOverrideWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_santander_put: {
    parameters: {
      body: {
        configuration: {
          santander: definitions["SantanderGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_override_swish_put: {
    parameters: {
      body: {
        configuration?: {
          store_id: string;
          /** @description Override properties for given store. Will delete override if null. */
          override?: definitions["SwishGwStoreOverrideWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_swish_put: {
    parameters: {
      query: {
        /** keep existing overrides when updating the gateway */
        keep_overrides?: boolean;
      };
      body: {
        configuration: {
          swish: definitions["SwishGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_override_vipps_put: {
    parameters: {
      body: {
        configuration?: {
          store_id: string;
          /** @description Override properties for given store. Will delete override if null. */
          override?: definitions["VippsGwStoreOverrideWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_vipps_put: {
    parameters: {
      body: {
        configuration: {
          vipps: definitions["VippsGwWrite"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:dintero
   */
  admin_checkout_id_gw_psp_put: {
    parameters: {
      body: {
        configuration: {
          dintero_psp: definitions["DinteroPspGwRead"];
        };
      };
    };
    responses: {
      /** Gateway updated */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  admin_session_profile_details_get: {
    parameters: {
      path: {
        profile_id: string;
      };
    };
    responses: {
      /** Session profile */
      200: {
        schema: definitions["Id"] &
          definitions["ProfileConfiguration"] &
          definitions["ProfileConfigurationResponse"];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_session_profile_details_put: {
    parameters: {
      path: {
        profile_id: string;
      };
      body: {
        configuration: definitions["ProfileConfiguration"];
      };
    };
    responses: {
      /** Session profile */
      200: {
        schema: definitions["ProfileConfiguration"];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_session_profile_details_delete: {
    parameters: {
      path: {
        profile_id: string;
      };
    };
    responses: {
      /** Session profile */
      200: {
        schema: definitions["Id"] &
          definitions["ProfileConfiguration"] &
          definitions["ProfileConfigurationResponse"];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   */
  admin_session_profile_get: {
    parameters: {
      query: {
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["Limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, ending with `obj_foo`,
         * your subsequent call can include `starting_after=obj_foo`
         * in order to fetch the next page of the list.
         */
        starting_after?: parameters["StartingAfter"];
      };
    };
    responses: {
      /** Payment configuration */
      200: {
        schema: (definitions["Id"] &
          definitions["ProfileConfiguration"] &
          definitions["ProfileConfigurationResponse"])[];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  admin_session_profile_post: {
    parameters: {
      body: {
        configuration: definitions["ProfileConfiguration"];
      };
    };
    responses: {
      /** Session profile */
      200: {
        schema: definitions["Id"] &
          definitions["ProfileConfiguration"] &
          definitions["ProfileConfigurationResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get the current signature secret Dintero uses when create the
   * `Dintero-Signature` header included in requests it sends to your
   * endpoints.
   *
   * scopes:
   * - admin:checkout
   * - read:checkout
   */
  admin_signature_get: {
    responses: {
      /** signature secret */
      200: {
        schema: definitions["SignatureV0"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Dintero can optionally sign all request it sends to your endpoints.
   *
   * We do so by including a signature in the request `Dintero-Signature`
   * header. This allows you to verify that the request was done by
   * Dintero, not by a third party.
   *
   * *`v0-hmac-sha256`*
   *
   * ```
   * <timestamp>\n<account_id>\n<method>\n<hostname>\n<pathname>\n<query>
   * ```
   *
   * ```
   * secret: 123
   * timestamp: 1582236537
   * account_id: P00000000
   * method: GET
   * url: https://example.com/callback?B=123&A=992
   *
   * Dintero-Signature: t=1582236537,
   *     v0-hmac-sha256=6bed2ab1b919d460ef7465a20dc6c97260dca73fab6647106ca525f0908df64a
   * ```
   *
   * > The timestamp (`t`) in the Dintero-Signature, is included in the signature payload to
   * > mitigate `replay attach`. If your signature is valid but the timestamp is too old, you
   * > can have your application reject the request. We recommend that your application have
   * > a tolerance of five minutes between the timestamp and the current time.
   *
   * > *NOTE:* The query parameters must be sorted.
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  admin_signature_post: {
    responses: {
      /** signature secret */
      200: {
        schema: definitions["SignatureV0"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /** Endpoint that returns an svg that can be used to show the world your payment options. [Go to the documentation for the checkout branding endpoints.](/docs/checkout-branding) */
  branding_logoframe: {
    parameters: {
      path: {
        /** logos for payment types separated by underscore eg. `visa_mastercard_vipps_swish_instabank` */
        logos: string;
        /** Image variant, multi-colors or mono-colored. */
        variant: "colors" | "mono";
        /** rgb hex color without the \# character or an rbg() or rgba() color code. */
        color: string;
        /** width of image */
        width: string;
        /** Template for branding image */
        template: "dintero_top_frame.svg" | "logos.svg";
      };
    };
    responses: {
      /** An svg image */
      200: unknown;
      /** Not found */
      404: unknown;
    };
  };
  /** Endpoint that returns an svg that can be used to show the world your payment options. [Go to the documentation for the checkout branding endpoints.](/docs/checkout-branding) */
  branding_profile: {
    parameters: {
      path: {
        /** Profile Id like `P00112233.abc123def321aAabBb9z9cccDdd` */
        profile_id: string;
        /** Image variant, multi-colors or mono-colored. */
        variant: "colors" | "mono";
        /** rgb hex color without the \# character or an rbg() or rgba() color code */
        color: string;
        /** width of image */
        width: string;
        /** Template for branding image */
        template: "dintero_top_frame.svg" | "logos.svg";
      };
    };
    responses: {
      /** svg image */
      200: unknown;
      /** Not found */
      404: unknown;
    };
  };
  checkout_sid_collector_callback_post: {
    parameters: {
      query: {
        InvoiceNo: string;
        OrderNo: string;
        InvoiceStatus: number;
      };
    };
    responses: {
      /** callback handled */
      202: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Perform a credit check
   *
   * scopes:
   * - admin:checkout
   * - write:checkout
   */
  creditchecks_post: {
    parameters: {
      body: {
        options?: {
          store?: {
            /** @description Identifiying store where the customer will use credit */
            id?: string;
          };
          /**
           * @description * synchronous - (default) the answer will come directly in the response
           *
           * @enum {string}
           */
          check_type?: "synchronous";
          credit_providers: "collector"[];
          /**
           * @description reward amount for the the ref used,
           * monetary amount in smallest unit for the currency
           *
           * @example 10000
           */
          amount: number;
          /**
           * Format: iso4217-code
           * @description The three-character ISO-4217 currency. https://en.wikipedia.org/wiki/ISO_4217
           * @example NOK
           */
          currency: string;
          applicant: {
            billing_address?: definitions["OrderAddress"];
          };
        };
      };
    };
    responses: {
      /** credit check result */
      200: {
        schema: {
          /**
           * Format: uuid
           * @description Unique identifier of credit check
           */
          id?: string;
          /** Format: date */
          created_at?: string;
          /** @description The amount applied for */
          amount?: number;
          results?: {
            /** @enum {string} */
            credit_provider?: "collector";
            /** @enum {string} */
            status?: "approved" | "rejected";
          }[];
        };
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  checkout_collector_idp_signin_test_get: {
    parameters: {
      query: {
        code?: string;
        error?: string;
        error_description?: string;
      };
    };
    responses: {
      /** Result from authorization */
      200: unknown;
    };
  };
  checkout_collector_idp_signin_get: {
    parameters: {
      query: {
        code?: string;
        error?: string;
        error_description?: string;
      };
    };
    responses: {
      /** Result from authorization */
      200: unknown;
    };
  };
  checkout_netaxept_webhooks_post: {
    parameters: {
      body: {
        /** Content of webhook event */
        data: {
          TransactionId?: string;
        };
      };
    };
    responses: {
      /** webhook handled */
      200: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  checkout_swish_payment_callback_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        callback_ref: string;
      };
      body: {
        /** Content of payment callback */
        data: definitions["SwishPaymentCallback"];
      };
    };
    responses: {
      /** webhook handled */
      200: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  checkout_swish_refund_callback_post: {
    parameters: {
      path: {
        /** The ID of the transaction */
        id: parameters["TransactionId"];
        callback_ref: string;
      };
      body: {
        /** Content of refund callback */
        data: definitions["SwishRefundCallback"];
      };
    };
    responses: {
      /** callback handled */
      200: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Handle async update of transaction.
   *
   * scopes:
   * - admin:checkout
   */
  events_transaction_post: {
    parameters: {
      path: {
        /**
         * **retry_auto_capture**
         *
         * Retry the capture of a transaction that was created
         * by a session with auto-capture enabled. A success is
         * return if the transaction new state is captured.
         *
         * **cancel_unknown**
         *
         * Cancel a transaction that failed the athorization check
         * done before the redirect to the merchant.
         *
         * **sync_status**
         *
         * Sync the status of a transaction that is not in sync with
         * the status in the payment gateway
         *
         * **poll_initiated**
         *
         * Poll the status of a transaction with status `INITIATED` from
         * the payment gateway. Trigger callback on transaction if the payment
         * gateway status is no longer `INITIATED`
         * > Intended for cases where expected callback from payment gateway
         * > was never received
         *
         * **retry_refund**
         *
         * Retry refund of a transaction with status `CAPTURED` that
         * was created from a session that is cancelled.
         */
        intent:
          | "cancel_unknown"
          | "retry_auto_capture"
          | "retry_refund"
          | "sync_status"
          | "poll_initiated";
      };
      body: {
        data: {
          /**
           * @description The transaction id
           *
           * @example P00000000.465UfBENeLpkBvwmqfTC4k
           */
          id: string;
          transaction: definitions["Transaction"];
        };
      };
    };
    responses: {
      /** Transaction updated */
      200: {
        schema: definitions["Transaction"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  checkout_bambora_callback_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        callback_ref: string;
      };
      query: {
        txnid?: string;
        orderid?: string;
        reference?: string;
        amount?: string;
        currency?: string;
        date?: string;
        time?: string;
        feeid?: string;
        txnfee?: string;
        paymenttype?: string;
        walletname?: string;
        cardno?: string;
        expmonth?: string;
        expyear?: string;
        subscriptionid?: string;
        tokenid?: string;
        eci?: string;
        issuercountry?: string;
        hash?: string;
      };
    };
    responses: {
      /** callback handled */
      200: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  checkout_sid_bambora_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
      query: {
        action?: "accept" | "cancel" | "decline";
        txnid?: string;
        orderid?: string;
        reference?: string;
        amount?: string;
        currency?: string;
        date?: string;
        time?: string;
        feeid?: string;
        txnfee?: string;
        paymenttype?: string;
        walletname?: string;
        cardno?: string;
        expmonth?: string;
        expyear?: string;
        subscriptionid?: string;
        tokenid?: string;
        eci?: string;
        issuercountry?: string;
        hash?: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  checkout_sid_collector_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
    responses: {
      /** Redirect to session URL on payment completed */
      302: never;
      404: responses["NotFound"];
    };
  };
  checkout_sid_dintero_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        /** Signed redirect reference prefixed by the payment product type */
        redirect_ref: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  checkout_sid_dintero_psp_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        /** Signed redirect reference prefixed by the payment product type */
        redirect_ref: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  checkout_sid_klarna_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        /** Signed redirect reference prefixed by the payment product type */
        redirect_ref: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  checkout_sid_netaxept_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
      query: {
        transactionId?: string;
        responseCode?: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  /**
   * Creates a transaction from the session with status determined
   * by the payment status provided by Payex.
   */
  checkout_sid_callback_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        payment_product_type:
          | "payex.creditcard"
          | "payex.mobilepay"
          | "payex.swish"
          | "payex.vipps";
      };
      query: {
        token?: string;
      };
      body: {
        callback: definitions["PayExCallback"];
      };
    };
    responses: {
      /** callback handled */
      202: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  checkout_sid_payex_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        action: "complete" | "cancel";
        payment_product_type:
          | "payex.creditcard"
          | "payex.mobilepay"
          | "payex.swish"
          | "payex.vipps";
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  /**
   * Creates a transaction from the session with status determined
   * by the payment status provided by Payex.
   */
  checkout_payex_v3_callback_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        /** Signed callback reference prefixed by the payment product type */
        callback_ref: string;
      };
      body: {
        callback: definitions["PayExV3Callback"];
      };
    };
    responses: {
      /** callback handled */
      200: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  checkout_sid_payex_v3_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        /** Signed redirect reference prefixed by the payment product type */
        redirect_ref: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  checkout_sid_santander_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
      };
    };
    responses: {
      /** Redirect to session URL on payment completed */
      302: never;
      404: responses["NotFound"];
    };
  };
  checkout_sid_swish_redirect_get: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        redirect_ref: string;
      };
    };
    responses: {
      302: responses["RedirectToSessionReturnUrl"];
      404: responses["NotFound"];
    };
  };
  checkout_sid_vipps_payments_orderid_post: {
    parameters: {
      path: {
        /** The session ID */
        session_id: parameters["SessionId"];
        order_id: string;
      };
      body: {
        callback: definitions["VippsCallback"];
      };
    };
    responses: {
      /** callback handled */
      202: unknown;
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
}

export interface external {}
