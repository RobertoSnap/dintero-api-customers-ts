/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/accounts/{aid}/customers/change_password": {
    /**
     * Specify the email address of the user whose password you
     * would like to reset. If the call is successful, the user
     * will receive an email prompting them to change their password.
     * The caller must have scope `write:accounts:/auth/users` to perform a
     * change password request.
     * scopes:
     * - write:accounts:/auth/users
     */
    post: operations["aid_customers_change_password"];
  };
  "/accounts/{aid}/customers/login": {
    /**
     * Login a customer user, the caller must have scope
     * `write:accounts:/auth/users`.
     * If MFA is enabled on account, use
     * `write:accounts:/auth/users/no-mfa` to skip MFA.
     * scopes:
     * - write:accounts:/auth/users
     * - write:accounts:/auth/users/no-mfa
     */
    post: operations["aid_customers_login_post"];
  };
  "/accounts/{aid}/customers/mfa_login": {
    /**
     * Initiate a Multi-Factor Authentication for a customer user, the caller must
     * have scope `write:accounts:/auth/users` to perform a login.
     * Post the `ident_type`, along with the `ident` and `secret`.
     * The server will return a challenge response specifying the
     * `challenge_type` that will have to be completed to when getting an access
     * token from the `POST /v1/accounts/{oid}/auth/token` endpoint.
     * scopes:
     * - write:accounts:/auth/users
     */
    post: operations["aid_customers_mfa_login_post"];
  };
  "/accounts/{aid}/customers/mfa_login_recovery": {
    /**
     * Initiate a Multi-Factor Authentication recovery login for a customer user
     * that has forgotten/lost their `secret`.
     * Specify the ident_type and the ident (email or phone_number) of the user. If
     * the call is successful, the user will get an email with an one time recovery
     * code that has to be submitted to the mfa_recovery endpoint.
     * When a valid one time recovery has been posted the server response with a
     * regular MFA challenge.
     * Once authenticated the password or pin can be changed by updating the
     * customer.
     * scopes:
     *   - write:accounts:/auth/users
     */
    post: operations["aid_customers_mfa_login_initiate_recovery_post"];
  };
  "/accounts/{aid}/customers/settings": {
    /**
     * Get customers settings
     *
     * scopes:
     * - admin:customers
     * - read:customers
     * - public:customers
     */
    get: operations["aid_customers_atributes_get"];
    /**
     * Update customers settings
     *
     * scopes:
     * - admin:customers
     * - write:customers
     */
    put: operations["aid_customers_atributes_put"];
  };
  "/accounts/{aid}/customers/tags": {
    /**
     * Get all customer tags (also known as groups).
     * scopes:
     * - admin:customers
     * - read:customers
     */
    get: operations["aid_customers_tags_get"];
    /**
     * Create a tag
     * scopes:
     * - admin:customers
     * - write:customers
     */
    post: operations["aid_customers_tags_post"];
  };
  "/accounts/{aid}/customers/tags/{tag_id}": {
    /**
     * Delete a tag.
     * A deleted tag is removed from customer tags
     * scopes:
     * - admin:customers
     * - write:customers
     */
    delete: operations["aid_customers_tags_tid_delete"];
  };
  "/accounts/{aid}/customers/terms": {
    /**
     * Get all customer terms and conditions
     * scopes:
     * - admin:customers
     * - read:customers
     * - public:customers
     */
    get: operations["aid_customers_terms_get"];
    /**
     * Create customer terms and conditions
     * scopes:
     * - admin:customers
     * - write:customers
     */
    post: operations["aid_customers_terms_post"];
  };
  "/accounts/{aid}/customers/terms/{tid}": {
    /**
     * Get single terms and conditions
     * scopes:
     * - admin:customers
     * - read:customers
     * - public:customers
     */
    get: operations["aid_customers_terms_tid_post"];
    /**
     * Delete the customer term
     * scopes:
     * - admin:customers
     * - write:customers
     */
    delete: operations["aid_customers_terms_tid_delete"];
  };
  "/accounts/{aid}/customers/tokens/events": {
    /**
     * Get the token events
     * scopes:
     * - admin:customers
     * - read:customers
     */
    get: operations["aid_customers_tokens_events_get"];
    /**
     * Find details about a token, inclusive details about
     * any customer the token belongs to and any token events recorded
     * Include event in the request to update the status of the token
     * scopes:
     * - admin:customers
     * - write:customers
     */
    post: operations["aid_customers_tokens_events_post"];
    /**
     * Delete the connection between token (type/value) and
     * list of events.
     * Include an event in the request to store the reason
     * for the request
     * scopes:
     * - admin:customers
     * - write:customers
     */
    delete: operations["aid_customers_tokens_events_delete"];
  };
  "/accounts/{aid}/customers/users": {
    /**
     * Get all customers, limited by parameters. The result will
     * match all parameters with `AND`.
     * Search is done by prefix match, and `+` in phone_number/email
     * must be URL encoded, (+4799999999 => %2B4799999999)
     *
     * Users with type `contact` are by default excluded from the result,
     * use `type=contact` or `type=any` to include contact users
     *
     * The response from a request that match contact users will include the
     * users that are linked from the contact
     *
     * scopes:
     * - admin:customers
     * - read:customers
     */
    get: operations["aid_customers_get"];
    /**
     * Create a new customer, `customer_id`, `email` and `phone_number` must
     * be unique if specified.
     * scopes:
     * - admin:customers
     * - write:customers
     * - create:customers:/users
     */
    post: operations["aid_customers_post"];
    /**
     * Check if there is users that match the parameters. The result will
     * match all parameters with `AND`.
     * This endpoint must be enabled from [PUT /customers/settings](#operation/aid_customers_atributes_put)
     * scopes:
     * - admin:customers
     * - read:customers
     * - public:customers
     */
    head: operations["aid_customers_head"];
  };
  "/accounts/{aid}/customers/users/{customer_id}": {
    /**
     * Customer details
     * scopes:
     * - admin:customers
     * - read:customers
     * - user:customers
     * - user:customers:/customer/details
     */
    get: operations["aid_customers_cid_get"];
    /**
     * Update customer properties, properties not included in the body
     * will remain unchanged.
     * scopes:
     * - admin:customers
     * - write:customers
     * - user:customers
     */
    put: operations["aid_customers_cid_put"];
    /**
     * Delete single customer
     * scopes:
     * - admin:customers
     * - write:customers
     * - user:customers
     */
    delete: operations["aid_customers_cid_delete"];
  };
  "/accounts/{aid}/customers/users/{customer_id}/change_customer_id": {
    /**
     * Update customer_id for an customer
     * **warning**: Any external resources "owned" by the user, i.e
     * receipts, discounts etc. will not be updated with the new
     * customer_id.
     * A new metadata property `dintero_change_customer_id_{timestamp}.{hash}`
     * will be added everytime the customer_id is changed
     * Following data will be included in the metadata property
     *  - created_at
     *  - created_by
     *  - old
     *  - new
     * scopes:
     * - admin:customers
     * - admin:accounts
     */
    post: operations["aid_customers_cid_change_customer_id_post"];
  };
  "/accounts/{aid}/customers/users/{customer_id}/communication": {
    /**
     * Get the status of customer email / phone_number communication
     * scopes:
     * - admin:customers
     * - read:customers
     * - user:customers
     */
    get: operations["aid_customers_cid_verify_get"];
  };
  "/accounts/{aid}/customers/users/{customer_id}/communication/{operation}/{field}": {
    /**
     * Verify customer email/phone_number field. Consist of
     * to steps:
     *   - send verification code to the customer (sms or email)
     *   - verify the email/phone_number by posting verification code sent to customer
     * scopes:
     * - admin:customers
     * - write:customers
     * - user:customers
     */
    post: operations["aid_customers_cid_verify_post"];
  };
  "/accounts/{aid}/customers/users/{customer_id}/tags": {
    /**
     * Get tags for a customer
     * scopes:
     * - admin:customers
     * - read:customers
     * - user:customers
     */
    get: operations["aid_customers_cid_tags_get"];
    /**
     * Update Customer Tags
     * scopes:
     * - admin:customers
     * - write:customers
     * - user:customers
     */
    put: operations["aid_customers_cid_tags_put"];
  };
  "/accounts/{aid}/customers/users/{customer_id}/tokens": {
    /**
     * Get all tokens for a Customer
     * scopes:
     * - admin:customers
     * - read:customers
     * - user:customers
     */
    get: operations["aid_customers_cid_tokens_get"];
    /**
     * Create a new customer token
     * scopes:
     * - admin:customers
     * - write:customers
     * - user:customers
     */
    post: operations["aid_customers_cid_tokens_post"];
  };
  "/accounts/{aid}/customers/users/{customer_id}/tokens/{tid}": {
    /**
     * Delete Token
     *
     * scopes:
     * - admin:customers
     * - write:customers
     * - user:customers
     */
    delete: operations["aid_customers_cid_tokens_tid_delete"];
  };
  "/accounts/{aid}/locations": {
    /**
     * Get all sales locations, the starting_after have to be set to location_id
     * scopes:
     * - admin:locations
     * - read:locations
     */
    get: operations["aid_locations_get"];
    /**
     * Create a sales location
     * scopes:
     * - admin:locations
     * - write:locations
     */
    post: operations["aid_location_post"];
  };
  "/accounts/{aid}/locations/{lid}": {
    /**
     * Get single sales location
     * scopes:
     * - admin:locations
     * - read:locations
     */
    get: operations["aid_locations_lid_get"];
    /**
     * Update location properties
     * scopes:
     * - admin:locations
     * - write:locations
     */
    put: operations["aid_location_lid_put"];
    /**
     * Delete single location
     * scopes:
     * - admin:locations
     * - write:locations
     */
    delete: operations["aid_location_lid_delete"];
  };
  "/accounts/{aid}/search/external/organizations/{country}/{organization_number}": {
    /**
     * scopes:
     * - public
     */
    get: operations["aid_get_external_organizations"];
  };
  "/accounts/{aid}/search/external/postal_place/{country}/{postal_code}": {
    /**
     * Get postal place by country and postal code.
     *
     * scopes:
     * - public
     */
    get: operations["aid_search_external_postal_place"];
  };
  "/accounts/{aid}/search/external/address/{country}/validate": {
    /**
     * Validate the given address and return close matching alternative
     * suggestions if the provided address was most likely wrong.
     *
     * scopes:
     * - public
     */
    post: operations["aid_search_external_validate_address"];
  };
  "/accounts/{aid}/customers/company/departments": {
    /**
     * List all departments register by company customers
     *
     * scopes:
     * - admin:customers
     * - read:customers
     * - public:customers
     */
    get: operations["aid_company_departments_get"];
  };
  "/accounts/{aid}/search/external/organizations/no": {
    /**
     * Proxy queries to the Norwegian organization registry aka.
     * "enhetsregisteret".
     *
     * scopes:
     * - public
     */
    get: operations["aid_search_external_organizations_no"];
  };
}

export interface definitions {
  /** @description HMAC-SHA-256 */
  "HMAC-SHA256": definitions["AutoTokenType"] & {
    /** @description Use the secret to compute HMAC SHA256 digest of the source value. */
    secret: string;
  };
  /** @description SHA-256 */
  SHA256: definitions["AutoTokenType"];
  Error: {
    error: {
      /** @description The code used to identify the error/warning */
      code?: string;
      /** @description The nested error(s) encountered during validation */
      errors?: { [key: string]: unknown }[];
      /** @description The human readable description of the error/warning */
      message: string;
    };
  };
  Auth: {
    /** @description **Required** if `ident_type` and `ident` is not set */
    email?: string;
    /**
     * @description **Required** if `email` is not set
     *
     * @enum {string}
     */
    ident_type?: "phone_number" | "email";
    /**
     * @description Email or phone_number, depending on the `ident_type`.
     *
     * **Required** if `email` is not set.
     */
    ident?: string;
    /**
     * @description The unique identifier of the target API you want to access.
     * The audience must be a grant associated with the client used
     * when calling this resource.
     */
    audience: string;
    /**
     * @description user type to login, required as users with different
     * type can share email
     *
     * @enum {string}
     */
    type: "customer" | "company";
  };
  AccessToken: {
    /**
     * @description A JWT access token
     * @example eyJhbGci...t7P4
     */
    access_token: string;
    /** @enum {string} */
    token_type: "Bearer";
    /**
     * @description The lifetime in seconds of the access token.  For
     * example, the value "3600" denotes that the access token will
     * expire in one hour from the time the response was generated.
     *
     * @example 86400
     */
    expires_in: number;
    /**
     * @description Token that can be used to request new tokens when the existing
     * Access Token expire.
     *
     * You can only get a Refresh Token if the Access Token used in the
     * request has scope:
     *
     *  - `create:accounts:auth:refresh_token`
     *
     * and the `grant-type` is one of:
     *
     *  - `authorization_code`
     *  - `password`
     *
     * **NOTE**:
     *  - A Single-Page Application should not ever receive a Refresh Token,
     *    this information is sensitive and should not be exposed client-side
     *    in a browser.
     *  - Refresh token must be stored securely by an application since
     *    they allow a user to remain authenticated essentially forever.
     */
    refresh_token?: string;
  };
  MFAAuth: {
    /** @enum {string} */
    ident_type: "phone_number" | "email";
    /** @description Email or phone_number, depending on the `ident_type`. */
    ident: string;
    /**
     * @description The unique identifier of the target API you want to access.
     * The audience must be a grant associated with the client used
     * when calling this resource.
     */
    audience: string;
    /**
     * @description user type to login, required as users with different
     * type can share email
     *
     * @enum {string}
     */
    type: "customer" | "company";
  };
  MultiFactorAuthenticationChallenge: {
    /**
     * @example [
     *   {
     *     "rel": "mfa_challenge",
     *     "href": "https://test.dintero.com/v1/accounts/T11223351/auth/mfa/challenge"
     *   },
     *   {
     *     "rel": "mfa_oob",
     *     "href": "https://test.dintero.com/v1/accounts/T11223351/auth/token"
     *   }
     * ]
     */
    links: {
      /** @enum {string} */
      rel: "mfa_challenge" | "mfa_oob";
      href: string;
    }[];
    /** @description MFA challenge token */
    mfa_token: string;
    /**
     * @description MFA challenge types
     *
     * - `oob` (out of band) means that the user will get an out of band message
     *   containing a `binding_code` that will have to be submitted along with the
     *   `mfa_token` when answering the mfa challenge
     *
     * @enum {string}
     */
    challenge_type: "oob";
    /**
     * @description The channel to use for OOB
     *
     * @enum {string}
     */
    oob_channel?: "sms" | "email";
  };
  MultiFactorAuthenticationRecoveryChallenge: {
    links: {
      /** @enum {string} */
      rel: "mfa_oob";
      href: string;
    }[];
    /** @enum {string} */
    binding_method?: "prompt";
    /** @example bkaiew...akas */
    oob_code: string;
    mfa_token: string;
    /**
     * @description MFA challenge types
     *
     * - `oob` (out of band) means that the user will get an out of band message
     *   containing a `recovery_code` that will have to be submitted along with the
     *   `recovery_token` when answering the MFA recovery challenge.
     *
     * @enum {string}
     */
    challenge_type: "oob";
  };
  /** @description enable mfa login */
  CustomersMfaSettings: {
    /**
     * @description Use this setting to enable mfa for customers login.
     * When mfa is enabled the mfa_login endpoint has to be used for logging in.
     *
     * @default false
     */
    enabled: boolean;
    /** @description mfa login */
    login: {
      /** @enum {string} */
      challenge_type: "oob";
      /** @enum {string} */
      oob_channel: "sms" | "email";
    };
    /** @description mfa login recovery */
    login_recovery: {
      /** @enum {string} */
      challenge_type: "oob";
      /** @enum {string} */
      oob_channel: "sms" | "email";
    };
  };
  AutoTokenType: {
    /** @enum {string} */
    type: "SHA256" | "HMAC-SHA256";
  };
  /** @description Customer settings for the account */
  CustomersSettings: {
    /** @description customers user configurations */
    users?: {
      /** @description Enable endpoint [HEAD /customers/users endpoint](#operation/aid_customers_head) */
      head?: {
        /** @default false */
        enabled: boolean;
      };
      /** @description Configuration validation of user phone_number */
      phone_number_validation?: {
        /**
         * @description Allow multiple users to share the same phone number. Passwordless login
         * with OTP sent via SMS is not supported when enabled.
         *
         * @default false
         */
        allow_duplicates: boolean;
      };
      /**
       * @description Format used when generating a customer_id when new user is created.
       *
       * - **uuid**: customer_id generated will be a random UUID
       * - **sequence**: customer_id generated will be serial. The initial start
       *   value will be the current maximum + 1 of existing customer_ids.
       *
       * >  **Note**: New customers should not be created with customer_id set when
       *   `sequence` format is used as it can introduce conflicts later when
       *   creating user without specifying customer_id
       *
       * @default uuid
       * @enum {string}
       */
      customer_id_format: "uuid" | "sequence";
      mfa?: definitions["CustomersMfaSettings"];
      /** @description Enable verifications on user updates. */
      verifications?: {
        /**
         * @description Require verification to update user phone_number
         *
         * @enum {string}
         */
        phone_number?: "sms";
      };
    };
    /** @description Automatically generate tokens for these properties on the customer */
    auto_tokens?: {
      phone_number?: definitions["AutoTokenType"][];
      email?: definitions["AutoTokenType"][];
    };
    /** @description tokens configuration */
    tokens?: {
      /** @description configure the expire behaviour of token events */
      event_expiry?: {
        /**
         * @description the event status to configure TTL on
         *
         * @example OPT_OUT
         */
        status: string;
        /**
         * @description Time-To-Live (TTL) for for the token event status in seconds
         *
         * @example 15780000
         */
        time_to_live: number;
      }[];
    };
    /** @description user attributes */
    attributes?: {
      /** @description name of the attribute */
      name: string;
      /**
       * @description type of the attribute value
       * @enum {string}
       */
      type:
        | "string"
        | "integer"
        | "real"
        | "boolean"
        | "phonenumber"
        | "email"
        | "date"
        | "date-time";
      /**
       * @description agreement (true/false) to enter multiple values
       *
       * @default false
       */
      multiple_values?: boolean;
      /**
       * @description agreement (true/false) for visibility for customers
       *
       * @default false
       */
      private?: boolean;
    }[];
  };
  Entity: {
    /**
     * Format: uuid
     * @description An UUID that uniquely identifies the resource
     */
    id?: string;
    /**
     * Format: date-time
     * @description The date-time when the resource was created
     */
    created_at?: string;
    /**
     * @description The ID of the user/client created the resource
     *
     * @example 1c92f7e1-2897-4d46-bdcc-c127a914fb4e
     */
    created_by?: string;
    /**
     * Format: date-time
     * @description The date-time when the resource was last updated
     */
    updated_at?: string;
    /**
     * @description The ID of the user/client created the resource
     *
     * @example 1c92f7e1-2897-4d46-bdcc-c127a914fb4e
     */
    deleted_by?: string;
    /** Format: date-time */
    deleted_at?: string;
  };
  CustomerTag: definitions["Entity"] & {
    /**
     * @description tag value
     * @example VIP
     */
    tag: string;
    /**
     * @description A set of key/value pairs that you can attach to
     * a tag.
     */
    metadata?: { [key: string]: unknown };
  };
  TermsAndConditions: definitions["Entity"] & {
    terms: string;
  };
  /**
   * @description Record event data about a token
   * An event can be created before the customer exist and
   * before the token has been added to the customer
   */
  TokenEvent: {
    /** Format: date-time */
    expires_at?: string;
    /** Format: date-time */
    created_at?: string;
    /**
     * @description context about the event
     * @example customer declined signup in store
     */
    event: string;
    /**
     * @description State to set on given token type and value
     *
     * @example OPT_OUT
     */
    status?: string;
    /**
     * @description Additional metadata about the event
     *
     * @example {
     *   "store_id": "SID1234"
     * }
     */
    metadata?: { [key: string]: unknown };
  };
  /** @description Lookup by token type and value */
  TokenTypeValue: {
    type: string;
    /** @description identifies how or who is resposible for the token value */
    value: string;
  };
  CustomerData: {
    /**
     * @description A set of key/value pairs that you can attach to a
     * customer object. It can be useful for storing additional
     * information about the customer in a structured format.
     * You can unset an individual key by setting its value to
     * null and then saving. To clear all keys, set metadata to null
     *
     * @example {
     *   "dob_year": 1985
     * }
     */
    metadata?: { [key: string]: unknown };
  };
  Address: {
    /** @example Sommerkroveien 34 */
    address_line: string;
    /** @example PB 123 */
    address_line_2?: string;
    /** @example 0349 */
    postal_code?: string;
    /** @example Oslo */
    postal_place: string;
    /**
     * Format: iso-3166-1
     * @description ISO 3166-1 country code
     *
     * @example NO
     */
    country: string;
  };
  /** @description Customer's addresses */
  CustomerAddress: definitions["Address"] & {
    /** @example 59.942112 */
    latitude?: number;
    /** @example 10.716991 */
    longitude?: number;
    /**
     * @description The address type
     * @enum {string}
     */
    type?: "custom" | "home" | "other" | "work";
    /**
     * @description If the address `type` is `custom`, this
     * property contains the custom value
     */
    custom_type?: string;
    /**
     * @description Comment about the address
     *
     * @example 5th floor, use doorbell.
     */
    comment?: string;
  };
  CustomerTerm: {
    /** Format: uuid */
    id?: string;
    /** Format: date-time */
    accepted_at?: string;
  };
  BasicUser: {
    /** @example John */
    first_name?: unknown;
    /** @example Doe */
    last_name?: unknown;
    /**
     * @description customer email,
     * case insensitive duplication control prevents
     * multiple user with same `type` to have equal email
     *
     * customer@example.com is equal to CUStOMer@EXAMPLE.com
     *
     * @example customer@example.com
     */
    email?: unknown;
    /**
     * Format: ^\+?[1-9]\d{1,14}$
     * @description A phone number in E.164 number formatting.
     *
     * @example +4799999999
     */
    phone_number?: unknown;
    /** @description Custom attributes */
    attributes?: { [key: string]: unknown };
    /** @description Status of the customer */
    status?: unknown;
    /** @description customer favorite store */
    favorite_store?: unknown;
    /** @description The source that recruited the customer */
    enrolled_by?: {
      /**
       * @description Enrollment type, e.g. `url`, `store`, `qr_code`, any string
       *
       * @example url
       */
      type?: string;
      /** @example https://facebook.com */
      value: unknown;
    };
    /** @description Customers consent for marketing in different channels */
    marketing_consent?: {
      sms?: {
        /** @example true */
        consent?: boolean;
        /**
         * Format: date-time
         * @description The date-time when the resource was last updated:
         *
         * @example 2018-01-12T13:42:00Z
         */
        updated_at?: string;
      };
      email?: {
        /** @example true */
        consent?: boolean;
        /**
         * Format: date-time
         * @description The date-time when the resource was last updated:
         *
         * @example 2018-01-12T13:42:00Z
         */
        updated_at?: string;
      };
    };
    /**
     * @description Describe type of an user.
     *
     * - `company` property is required when using the type `company`
     * - `company` property is only supported for users with type `other`
     *   or `company`
     * - Creating or updating user with type `employee` or `other` requires
     *   `admin:customers` or `write:customers` scope.
     * - User login is only available for users with type `customer` or `company`
     *
     * @default customer
     * @enum {string}
     */
    type?: "customer" | "company" | "contact" | "employee" | "other";
    addresses?: definitions["CustomerAddress"][];
    term?: definitions["CustomerTerm"];
    /** @description Company details, supported when type is Company */
    company?: {
      /**
       * @description Companys identification number
       * @example 123456789MVA
       */
      organization_number?: string;
      /** @example TKP tech AS */
      bussiness_name: string;
      /**
       * @description companys department
       * @example sales department
       */
      department?: string;
      /** @example computer industry */
      industry?: string;
      website?: string;
      number_of_employees?: string;
    };
    /** @example male */
    gender?: unknown;
    /**
     * Format: date
     * @example 1990-09-20
     */
    date_of_birth?: unknown;
    /** @description The users that it is a contact for, supported when type is `contact` */
    contact_for?: {
      /** @description The customer id that it is a contact for */
      customer_id: string;
    }[];
  };
  Customer: definitions["CustomerData"] &
    definitions["Entity"] &
    definitions["BasicUser"] & {
      /**
       * @default customer
       * @enum {string}
       */
      type: "customer" | "company" | "contact" | "employee" | "other";
    };
  CustomerResponse: definitions["Customer"] & {
    /**
     * @description The customer id you have defined for the customer.
     * (must not have trailing or leading spaces)
     * An auto-generated customer_id will be created if no
     * customer_id is provided.
     */
    customer_id: string;
  };
  CustomerToken: definitions["Entity"] & {
    /**
     * @description The token id you have defined for the token.
     * (must not have trailing or leading spaces)
     */
    token_id?: string;
    /**
     * @description identifies how or who is resposible for the token value
     *
     * @example sha1:email
     */
    type: string;
    /** @example a1b79ef1a62d94ffa86b3f3d846df0ee3993af92 */
    value: string;
    /**
     * @description Additional metadata about the token or the entity the
     * token was created from
     *
     * @example {
     *   "exp_month": 10,
     *   "exp_year": 20,
     *   "mask_pan": "**** **** **** 3477"
     * }
     */
    metadata?: { [key: string]: unknown };
  };
  TokenDetail: {
    /**
     * @description Auto-generated ID identifying the token type/value. Will be random
     * until the token type/value has been added to a customer or a token
     * event has been registered.
     */
    id?: string;
    /** @description The customer (if any) that the token belongs to */
    customer?: definitions["CustomerResponse"];
    /** @description The token (if any) that is found given token type and value */
    token?: definitions["CustomerToken"];
    /**
     * @description Aggregated status from events registered or customer resolved.
     *
     * The status will be set to `customer.status` and fallback to
     * the status of the latest event.
     *
     * The status will be set to `UNKNOWN` if no `customer.status` and
     * event status is registered.
     *
     * The status will be set to the previous event status (or UNKNOWN)
     * if the event has expired
     *
     * @default UNKNOWN
     * @example OPT_OUT
     */
    status?: string;
    /** @description Events recorded given token type and value */
    events?: definitions["TokenEvent"][];
  };
  Communication: definitions["Entity"] & {
    communication?: {
      email?: {
        /**
         * Format: date-time
         * @description email verified by verification code
         */
        verified_at?: string;
        allowed?: boolean;
      };
      phone_number?: {
        /**
         * Format: date-time
         * @description phone_number verified by verification code
         */
        verified_at?: string;
        allowed?: boolean;
      };
    };
  };
  SalesLocation: definitions["Entity"] & {
    /**
     * @description The id you have defined for the sales location.
     * (must not have trailing or leading spaces). An
     * auto-generated location_id will be created if no location_id
     * is provided
     *
     * @example S01923
     */
    location_id?: string;
    /**
     * @description The location's trade name which is shown to its customers (receipt/signs)
     * @example TKP Store
     */
    name?: string;
    /**
     * @description The location's timezone (IANA Timezone)
     * @example Europe/Oslo
     */
    timezone?: string;
    /**
     * @description The location's status
     * @example Active
     */
    status?: string;
    /**
     * @description Language code of the localized company info, as defined by
     * <a href="https://tools.ietf.org/html/bcp47">BCP 47</a>
     * (IETF BCP 47, "Tags for Identifying Languages").
     */
    language_code?: string;
    /**
     * @description The three-character ISO-4217 currency.
     * https://en.wikipedia.org/wiki/ISO_4217
     *
     * @example NOK
     */
    currency?: string;
    /**
     * Format: ^\+?[1-9]\d{1,14}$
     * @description A phone number in E.164 number formatting.
     *
     * @example +4799999999
     */
    phone_number?: string;
    /** @example SuperChain */
    chain?: string;
    /** @example saleslocation@example.com */
    email?: string;
    /**
     * Format: iso-18245
     * @description A four-digit Merchant Category Code (MCC) for the store
     * [ISO 18245:2003](https://www.iso.org/standard/33365.html)
     *
     * @example 5814
     */
    mcc?: string;
    /** @description Company Global Location Number */
    gln?: string;
    /**
     * @description Company identification number
     * @example 123456789MVA
     */
    organization_number?: string;
    /**
     * @description The location's legal name
     * @example TKP technology AS
     */
    business_name?: string;
    /**
     * @description The location is part of a franchise.
     * @example Subway
     */
    franchise?: string;
    /** @description The location type (Physical, Mobile) */
    type?: string;
    /** @description The location's website */
    website_url?: string;
    address?: definitions["Address"] & {
      latitude?: number;
      longitude?: number;
    };
  };
  SalesLocationResponse: {
    /** Format: ^[PT]{1}\d{8}$ */
    account_id?: string;
  } & definitions["SalesLocation"];
  GetExternalOrganizationResult: {
    /**
     * @description Company identification number
     * @example 123456789MVA
     */
    organization_number: string;
    /**
     * @description The location's legal name
     * @example TKP technology AS
     */
    business_name: string;
    business_address?: definitions["Address"];
    registry_address?: definitions["Address"];
    /**
     * @description head_office, branch or other type of office
     * @example [
     *   "head_office",
     *   "branch"
     * ]
     */
    office_type?: string;
  };
  PostalPlaceResult: {
    /**
     * @description ISO 3166-1 country code
     *
     * @example NO
     */
    country: string;
    /** @example 0349 */
    postal_code: string;
    /** @example Oslo */
    postal_place: string;
  };
  AddressValidationResult: {
    /**
     * @description If the address was valid or not.
     *
     * @example false
     */
    valid: boolean;
    /** @description Close matching alternative addresses. */
    alternatives: (definitions["Address"] & unknown)[];
  };
  SearchExternalOrganizationNorwayResult: {
    /**
     * @example enhetsregisteret
     * @enum {string}
     */
    response_from: "enhetsregisteret";
    /**
     * @description Organization code from https://data.brreg.no/enhetsregisteret/api/organisasjonsformer
     *
     * @example AS
     */
    organization_type: string;
    /**
     * Format: ^\+?[1-9]\d{1,14}$
     * @description A phone number in E.164 number formatting.
     *
     * @example +4799999999
     */
    phone_number?: string;
    /** @example hello@company.com */
    email?: string;
    /**
     * @description Company identification number
     * @example 123456789MVA
     */
    organization_number: string;
    /**
     * @description The location's legal name
     * @example TKP technology AS
     */
    business_name: string;
    business_address?: definitions["Address"];
    registry_address?: definitions["Address"];
    /** @description The company's website */
    website_url?: string;
  };
}

export interface parameters {
  /**
   * Format: ^[PT]{1}\d{8}$
   * @description An id that uniquely identifies the account.
   */
  accountId: string;
  /**
   * @description A limit on the number of objects to be returned. Limit can range
   * between 1 and 100 items, and the default is 10 items.
   *
   * @default 10
   */
  limit: number;
  /**
   * @description cursor for use in pagination. starting_after is an object ID
   * that defines your place in the list. For instance, if you make
   * a list request and receive 100 objects, end the result contains
   *   `paging_token=pt1`, your subsequent call can include
   * `starting_after=pt1` in order to fetch the next page of the list.
   */
  startingAfter: string;
  /**
   * @description include `total-count` header in the response
   *
   * @default false
   */
  total: boolean;
  /**
   * @description The customer id you have defined for the customer.
   * (must not have trailing or leading spaces)
   */
  customerId: string;
}

export interface responses {
  /** Bad / Invalid request */
  BadRequest: {
    schema: definitions["Error"];
  };
  /** Access forbidden, invalid JWT token was used */
  AccessForbidden: {
    schema: definitions["Error"];
  };
  /** Forbidden */
  Forbidden: {
    schema: definitions["Error"];
  };
  /** Unexpected Error */
  ServerError: {
    schema: definitions["Error"];
  };
  /** Resource was not found */
  NotFound: {
    schema: definitions["Error"];
  };
  /** Too Many Requests */
  TooManyRequests: {
    headers: {};
    schema: definitions["Error"];
  };
}

export interface operations {
  /**
   * Specify the email address of the user whose password you
   * would like to reset. If the call is successful, the user
   * will receive an email prompting them to change their password.
   * The caller must have scope `write:accounts:/auth/users` to perform a
   * change password request.
   * scopes:
   * - write:accounts:/auth/users
   */
  aid_customers_change_password: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        data: {
          email: string;
          /**
           * @description The unique identifier of the target API you want to access.
           * The audience must be a grant associated with the client used
           * when calling this resource.
           */
          audience: string;
          /**
           * @description user type to login, required as users with different
           * type can share email
           *
           * @enum {string}
           */
          type: "customer" | "company";
        };
      };
    };
    responses: {
      /** Success */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Login a customer user, the caller must have scope
   * `write:accounts:/auth/users`.
   * If MFA is enabled on account, use
   * `write:accounts:/auth/users/no-mfa` to skip MFA.
   * scopes:
   * - write:accounts:/auth/users
   * - write:accounts:/auth/users/no-mfa
   */
  aid_customers_login_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** credentials */
        data: definitions["Auth"] & {
          /**
           * @description The customer pin or password. The caller must have scope
           * `write:accounts:/auth/users` or `write:accounts:/auth/users/no-mfa`
           * when password is included in the body
           */
          password: string;
        };
      };
    };
    responses: {
      /** Success */
      200: {
        schema: definitions["AccessToken"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Initiate a Multi-Factor Authentication for a customer user, the caller must
   * have scope `write:accounts:/auth/users` to perform a login.
   * Post the `ident_type`, along with the `ident` and `secret`.
   * The server will return a challenge response specifying the
   * `challenge_type` that will have to be completed to when getting an access
   * token from the `POST /v1/accounts/{oid}/auth/token` endpoint.
   * scopes:
   * - write:accounts:/auth/users
   */
  aid_customers_mfa_login_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** credentials */
        data: definitions["MFAAuth"] & {
          /** @description The customers pin or password. */
          secret: string;
        };
      };
    };
    responses: {
      /** MFA login challenge */
      200: {
        schema: definitions["MultiFactorAuthenticationChallenge"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Initiate a Multi-Factor Authentication recovery login for a customer user
   * that has forgotten/lost their `secret`.
   * Specify the ident_type and the ident (email or phone_number) of the user. If
   * the call is successful, the user will get an email with an one time recovery
   * code that has to be submitted to the mfa_recovery endpoint.
   * When a valid one time recovery has been posted the server response with a
   * regular MFA challenge.
   * Once authenticated the password or pin can be changed by updating the
   * customer.
   * scopes:
   *   - write:accounts:/auth/users
   */
  aid_customers_mfa_login_initiate_recovery_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        data: definitions["MFAAuth"];
      };
    };
    responses: {
      /** Recovery MFA challenge */
      200: {
        schema: definitions["MultiFactorAuthenticationRecoveryChallenge"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get customers settings
   *
   * scopes:
   * - admin:customers
   * - read:customers
   * - public:customers
   */
  aid_customers_atributes_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
    };
    responses: {
      /** an object of customers settings */
      200: {
        schema: definitions["CustomersSettings"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Update customers settings
   *
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_atributes_put: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** customers settings */
        data: definitions["CustomersSettings"];
      };
    };
    responses: {
      /** added/updated object of customers settings */
      200: {
        schema: definitions["CustomersSettings"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get all customer tags (also known as groups).
   * scopes:
   * - admin:customers
   * - read:customers
   */
  aid_customers_tags_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
    };
    responses: {
      /** Customers Tags */
      200: {
        schema: definitions["CustomerTag"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Create a tag
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_tags_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** customer tag add */
        data: definitions["CustomerTag"];
      };
    };
    responses: {
      /** Customers Tags */
      200: {
        schema: definitions["CustomerTag"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Delete a tag.
   * A deleted tag is removed from customer tags
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_tags_tid_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** tag id */
        tag_id: string;
      };
    };
    responses: {
      /** Tag deleted */
      200: {
        schema: definitions["CustomerTag"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get all customer terms and conditions
   * scopes:
   * - admin:customers
   * - read:customers
   * - public:customers
   */
  aid_customers_terms_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /** include deleted terms in the response */
        include_deleted?: boolean;
      };
    };
    responses: {
      /** Terms collection */
      200: {
        schema: definitions["TermsAndConditions"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Create customer terms and conditions
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_terms_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** terms to create */
        data: definitions["TermsAndConditions"];
      };
    };
    responses: {
      /** Term created */
      200: {
        schema: definitions["TermsAndConditions"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get single terms and conditions
   * scopes:
   * - admin:customers
   * - read:customers
   * - public:customers
   */
  aid_customers_terms_tid_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** terms id */
        tid: string;
      };
    };
    responses: {
      /** Term details */
      200: {
        schema: definitions["TermsAndConditions"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Delete the customer term
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_terms_tid_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** terms id */
        tid: string;
      };
    };
    responses: {
      /** Deleted term */
      200: {
        schema: definitions["TermsAndConditions"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get the token events
   * scopes:
   * - admin:customers
   * - read:customers
   */
  aid_customers_tokens_events_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /**
         * Only token events added/updated at or after this time is returned
         * NOTE: this parameter can't be combined with `starting_after` parameter.
         * Retrieve next page by updating since_datetime to the latest updated_at
         * value found in the result.
         */
        since_datetime?: string;
        /** return only token events that has been deleted */
        deleted_since?: string;
      };
    };
    responses: {
      /** events collection */
      200: {
        headers: {};
        schema: {
          /** @description Auto-generated ID identifying the token type/value. */
          id?: string;
          /**
           * @description The status resolved from latest events registered on
           * given token type and value
           *
           * @default UNKNOWN
           * @example DELETED
           */
          status?: string;
          /**
           * @description Events recorded given token type and value
           *
           * @example [
           *   {
           *     "created_at": "2018-01-31T16:56:33Z",
           *     "event": "anonymous token",
           *     "status": "PENDING"
           *   },
           *   {
           *     "created_at": "2018-02-05T00:00:00Z",
           *     "event": "reqruited",
           *     "status": "DELETED"
           *   }
           * ]
           */
          events?: definitions["TokenEvent"][];
        }[];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
    };
  };
  /**
   * Find details about a token, inclusive details about
   * any customer the token belongs to and any token events recorded
   * Include event in the request to update the status of the token
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_tokens_events_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        data: {
          token: definitions["TokenTypeValue"];
          event?: definitions["TokenEvent"];
        };
      };
    };
    responses: {
      /** Token details */
      200: {
        schema: definitions["TokenDetail"];
      };
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /**
   * Delete the connection between token (type/value) and
   * list of events.
   * Include an event in the request to store the reason
   * for the request
   * scopes:
   * - admin:customers
   * - write:customers
   */
  aid_customers_tokens_events_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        data: {
          token: definitions["TokenTypeValue"];
          /** @description Record an delete event, the status will be set to DELETED. */
          event?: {
            /** @example customer registered in webshop */
            event?: string;
            metadata?: { [key: string]: unknown };
          };
        };
      };
    };
    responses: {
      /** events cleared */
      204: never;
    };
  };
  /**
   * Get all customers, limited by parameters. The result will
   * match all parameters with `AND`.
   * Search is done by prefix match, and `+` in phone_number/email
   * must be URL encoded, (+4799999999 => %2B4799999999)
   *
   * Users with type `contact` are by default excluded from the result,
   * use `type=contact` or `type=any` to include contact users
   *
   * The response from a request that match contact users will include the
   * users that are linked from the contact
   *
   * scopes:
   * - admin:customers
   * - read:customers
   */
  aid_customers_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /** lookup customers by token value */
        token_value?: string;
        /** lookup customer by token type */
        token_type?: string;
        /** lookup customer by email */
        email?: string;
        /** lookup customer by phone_number */
        phone_number?: string;
        /** lookup customer by type */
        type?:
          | "customer"
          | "company"
          | "contact"
          | "employee"
          | "other"
          | "any";
        /**
         * lookup customer where search term match name,
         * phone number, customer_id or email. The search term will be matched
         * with the user details
         */
        search?: string;
        /** lookup customers by tag id */
        tag_id?: string;
        /**
         * include deleted customers in the response. A deleted
         * user will only have an id/customer_id, created_at/created_by
         * and deleted_at/deleted_by set
         * All other details of a customer, like email or phone_number
         * will be deleted.
         */
        include_deleted?: boolean;
        /** include customers that has all the attributes. */
        attributes_keys?: string[];
        /**
         * Combine with `attributes_keys` to include customers
         * with match on attribute values
         */
        attributes_values?: string[];
        /**
         * lookup customers that has been added or modified
         * since an ISO timestamp. NOTE: this parameter can't be combined
         * with `starting_after` parameter. Retrieve next page by updating
         * since_datetime to the latest updated_at value found in the result
         */
        since_datetime?: string;
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /** include `total-count` header in the response */
        total?: parameters["total"];
      };
    };
    responses: {
      /** Customer collection */
      200: {
        headers: {};
        schema: definitions["CustomerResponse"][];
      };
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /**
   * Create a new customer, `customer_id`, `email` and `phone_number` must
   * be unique if specified.
   * scopes:
   * - admin:customers
   * - write:customers
   * - create:customers:/users
   */
  aid_customers_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** customer to create */
        data: definitions["Customer"] & {
          /**
           * @description The customer id you have defined for the customer.
           * (must not have trailing or leading spaces)
           * An auto-generated customer_id will be created if no
           * customer_id is provided.
           */
          customer_id?: string;
          /**
           * @description The customer password. The caller must have scope
           * `write:accounts:/auth/users` when password is included in the body
           */
          password?: string;
          /**
           * @description 6 digit customer pin, can only used for MFA login. The caller must have scope
           * `write:accounts:/auth/users` when pin is included in the body
           */
          pin?: string;
        };
      };
    };
    responses: {
      /** Customer created */
      200: {
        schema: definitions["CustomerResponse"];
      };
      /**
       * Bad request - missing required fields or
       * duplicate field detected
       */
      400: {
        schema: definitions["Error"];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Check if there is users that match the parameters. The result will
   * match all parameters with `AND`.
   * This endpoint must be enabled from [PUT /customers/settings](#operation/aid_customers_atributes_put)
   * scopes:
   * - admin:customers
   * - read:customers
   * - public:customers
   */
  aid_customers_head: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /** lookup customer by email */
        email?: string;
        /** lookup customer by phone_number */
        phone_number?: string;
      };
    };
    responses: {
      /** Customer user exist */
      200: unknown;
      /** No user match given query parameters */
      404: {
        schema: definitions["Error"];
      };
      /** Method not allowed by customer settings */
      405: {
        schema: definitions["Error"];
      };
      /** Unexpected error */
      default: {
        schema: definitions["Error"];
      };
    };
  };
  /**
   * Customer details
   * scopes:
   * - admin:customers
   * - read:customers
   * - user:customers
   * - user:customers:/customer/details
   */
  aid_customers_cid_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
    };
    responses: {
      /** Customer */
      200: {
        schema: definitions["CustomerResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Update customer properties, properties not included in the body
   * will remain unchanged.
   * scopes:
   * - admin:customers
   * - write:customers
   * - user:customers
   */
  aid_customers_cid_put: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
      body: {
        /** Customer update */
        data: definitions["BasicUser"] & {
          /**
           * @description The customer password. The caller must have scope
           * `write:accounts:/auth/users` when password is included in the body
           */
          password?: string;
          /**
           * @description 6 digit customer pin, can only be used for MFA login. The caller must have scope
           * `write:accounts:/auth/users` when pin is included in the body
           */
          pin?: string;
        };
      };
    };
    responses: {
      /** Customer updated */
      200: {
        schema: definitions["CustomerResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Delete single customer
   * scopes:
   * - admin:customers
   * - write:customers
   * - user:customers
   */
  aid_customers_cid_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
      query: {
        /** Delete all tokens owned by the customer */
        delete_tokens?: boolean;
      };
    };
    responses: {
      /** Customer deleted */
      200: {
        schema: definitions["CustomerResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Update customer_id for an customer
   * **warning**: Any external resources "owned" by the user, i.e
   * receipts, discounts etc. will not be updated with the new
   * customer_id.
   * A new metadata property `dintero_change_customer_id_{timestamp}.{hash}`
   * will be added everytime the customer_id is changed
   * Following data will be included in the metadata property
   *  - created_at
   *  - created_by
   *  - old
   *  - new
   * scopes:
   * - admin:customers
   * - admin:accounts
   */
  aid_customers_cid_change_customer_id_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
      body: {
        /** Customer update */
        data: {
          /**
           * @description New customer_id
           * (must not have trailing or leading spaces).
           */
          customer_id?: string;
        };
      };
    };
    responses: {
      /** Customer updated */
      200: {
        schema: definitions["CustomerResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get the status of customer email / phone_number communication
   * scopes:
   * - admin:customers
   * - read:customers
   * - user:customers
   */
  aid_customers_cid_verify_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
    };
    responses: {
      /** Customer email / phone_number communication status */
      200: {
        schema: definitions["Communication"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Verify customer email/phone_number field. Consist of
   * to steps:
   *   - send verification code to the customer (sms or email)
   *   - verify the email/phone_number by posting verification code sent to customer
   * scopes:
   * - admin:customers
   * - write:customers
   * - user:customers
   */
  aid_customers_cid_verify_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
        /** field to verify */
        field: "email" | "phone_number";
        /** Verify operation */
        operation: "send-verification-code" | "confirm-verification-code";
      };
      body: {
        /** verification code */
        data?: {
          /** @description Verification code sent to customer */
          code?: string;
        };
      };
    };
    responses: {
      /** No content */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get tags for a customer
   * scopes:
   * - admin:customers
   * - read:customers
   * - user:customers
   */
  aid_customers_cid_tags_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
    };
    responses: {
      /** Customer tags */
      200: {
        schema: definitions["CustomerTag"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Update Customer Tags
   * scopes:
   * - admin:customers
   * - write:customers
   * - user:customers
   */
  aid_customers_cid_tags_put: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
      body: {
        /** tag ids to set */
        data: string[];
      };
    };
    responses: {
      /** Customer Data */
      200: {
        schema: definitions["CustomerTag"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get all tokens for a Customer
   * scopes:
   * - admin:customers
   * - read:customers
   * - user:customers
   */
  aid_customers_cid_tokens_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
      query: {
        /** filter tokens on type */
        type?: string;
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /** include `total-count` header in the response */
        total?: parameters["total"];
        /** include deleted tokens in the response. */
        include_deleted?: boolean;
      };
    };
    responses: {
      /** Token collection */
      200: {
        headers: {};
        schema: definitions["CustomerToken"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Create a new customer token
   * scopes:
   * - admin:customers
   * - write:customers
   * - user:customers
   */
  aid_customers_cid_tokens_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
      };
      query: {
        /**
         * delete all token events recorded on token type/value
         * before creating new customer token
         */
        delete_token_events?: boolean;
      };
      body: {
        /** customer token to add */
        data: {
          /**
           * @description The token id you have defined for the token.
           * (must not have trailing or leading spaces).
           * An auto-generated token_id will be created if no
           * token_id is provided.
           */
          token_id?: string;
        } & definitions["CustomerToken"];
      };
    };
    responses: {
      /** Customer token added */
      201: {
        schema: definitions["CustomerToken"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Delete Token
   *
   * scopes:
   * - admin:customers
   * - write:customers
   * - user:customers
   */
  aid_customers_cid_tokens_tid_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /**
         * The customer id you have defined for the customer.
         * (must not have trailing or leading spaces)
         */
        customer_id: parameters["customerId"];
        /**
         * The token id you have defined for the token.
         * (must not have trailing or leading spaces)
         */
        tid: string;
      };
    };
    responses: {
      /** Token deleted */
      200: {
        schema: definitions["CustomerToken"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get all sales locations, the starting_after have to be set to location_id
   * scopes:
   * - admin:locations
   * - read:locations
   */
  aid_locations_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /**
         * lookup locations where search term match name,
         * phone_number, email, organization_number and business_name
         */
        search?: string;
        /** filter locations by status */
        status?: string[];
        /** filter locations by country */
        country?: string[];
        /** filter locations by phone_number */
        phone_number?: string[];
        /** filter locations by organization_number */
        organization_number?: string[];
        /** filter locations by email */
        email?: string[];
        /** filter locations by type */
        type?: string[];
      };
    };
    responses: {
      /** SalesLocation collection */
      200: {
        schema: definitions["SalesLocationResponse"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Create a sales location
   * scopes:
   * - admin:locations
   * - write:locations
   */
  aid_location_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** location to create */
        data: {
          /**
           * @description The id you have defined for the sales location.
           * (must not have trailing or leading spaces). An
           * auto-generated location_id will be created if no location_id
           * is provided
           *
           * @example S01923
           */
          location_id?: string;
        } & definitions["SalesLocation"];
      };
    };
    responses: {
      /** created an location */
      200: {
        schema: definitions["SalesLocationResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get single sales location
   * scopes:
   * - admin:locations
   * - read:locations
   */
  aid_locations_lid_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** location id */
        lid: string;
      };
    };
    responses: {
      /** a single sales location details */
      200: {
        schema: definitions["SalesLocationResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Update location properties
   * scopes:
   * - admin:locations
   * - write:locations
   */
  aid_location_lid_put: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** location id */
        lid: string;
      };
      body: {
        /** Location update */
        data: definitions["SalesLocation"];
      };
    };
    responses: {
      /** Location updated */
      200: {
        schema: definitions["SalesLocationResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Delete single location
   * scopes:
   * - admin:locations
   * - write:locations
   */
  aid_location_lid_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** location id */
        lid: string;
      };
    };
    responses: {
      /** Location deleted */
      200: {
        schema: definitions["SalesLocationResponse"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * scopes:
   * - public
   */
  aid_get_external_organizations: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** ISO 3166-1 country code */
        country: string;
        /** Organization number to get addresses for */
        organization_number: string;
      };
    };
    responses: {
      /** Organization search result collection */
      200: {
        schema: {
          items?: definitions["GetExternalOrganizationResult"][];
        };
      };
      400: responses["BadRequest"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get postal place by country and postal code.
   *
   * scopes:
   * - public
   */
  aid_search_external_postal_place: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** ISO 3166-1 country code */
        country: string;
        /** Postal code */
        postal_code: string;
      };
    };
    responses: {
      /** Result with postal_place */
      200: {
        schema: definitions["PostalPlaceResult"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      429: responses["TooManyRequests"];
      500: responses["ServerError"];
    };
  };
  /**
   * Validate the given address and return close matching alternative
   * suggestions if the provided address was most likely wrong.
   *
   * scopes:
   * - public
   */
  aid_search_external_validate_address: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** ISO 3166-1 country code */
        country: string;
      };
      body: {
        /**
         * Address information, including the name of the address, the postal code,
         * the postal place (city where the address is in), and the country.
         */
        address?: definitions["Address"] & unknown;
      };
    };
    responses: {
      /** Result with close matching alternative addresses if found. */
      200: {
        schema: definitions["AddressValidationResult"];
      };
      400: responses["BadRequest"];
      404: responses["NotFound"];
      429: responses["TooManyRequests"];
      500: responses["ServerError"];
    };
  };
  /**
   * List all departments register by company customers
   *
   * scopes:
   * - admin:customers
   * - read:customers
   * - public:customers
   */
  aid_company_departments_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        organization_number: string;
      };
    };
    responses: {
      /** company departments */
      200: {
        schema: {
          /** @example 123456789MVA */
          organization_number?: string;
          /**
           * @example [
           *   "Production",
           *   "Research and Development",
           *   "Accounting and Finance"
           * ]
           */
          departments?: string[];
        }[];
      };
      400: responses["BadRequest"];
    };
  };
  /**
   * Proxy queries to the Norwegian organization registry aka.
   * "enhetsregisteret".
   *
   * scopes:
   * - public
   */
  aid_search_external_organizations_no: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /** Search for organization */
        name?: string;
        /** Search for organization */
        organization_number?: string;
      };
    };
    responses: {
      /** Organization search result collection */
      200: {
        schema: definitions["SearchExternalOrganizationNorwayResult"][];
      };
      400: responses["BadRequest"];
      500: responses["ServerError"];
    };
  };
}

export interface external {}
