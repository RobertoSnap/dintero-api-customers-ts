/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/accounts/{aid}/hooks/subscriptions": {
    /**
     * Get all subscriptions
     *
     * scopes:
     * - admin:hooks
     * - read:hooks
     */
    get: operations["aid_source_hooks_get"];
    /**
     * When you create a new webhook, we'll send you a simple ping event to
     * let you know you've set up the webhook correctly.
     * You can trigger a ping again by calling the
     * [ping endpoint](#operation/aid_source_hooks_hid_ping_post).
     *
     * ## Receiving Webhooks
     *
     * In order for Dintero to send webhook payloads, your server needs to be
     * accessible from the Internet. We also highly suggest using SSL
     * so that we can send encrypted payloads over HTTPS.
     *
     * ## Respond to a webhook
     *
     * Your webhook acknowledges that it received data by sending a 200 OK
     * response. Any response outside of the 200 range will let Dintero
     * know that you did not receive your webhook, including 301 Redirect.
     * Dintero does not follow redirects for webhook notifications and will
     * consider a redirection as an error response.
     *
     * Dintero has implemented a 60-second timeout period and a retry
     * period for subscriptions. We wait 120 seconds for a response to
     * each request, and if there isn't one or we get an error, we retry
     * the connection to a total of 5 times.
     * A webhook will be deleted if there are consecutive failures for the
     * exact same webhook. You should monitor the admin of your webhook
     * tool for failing webhooks.
     *
     * ### Webhooks Headers
     *
     * Dintero will send along several HTTP headers to differentiate between
     * event types and payload identifiers.
     *
     * | Name           | Description                                          |
     * |----------------|------------------------------------------------------|
     * | event          | The event type                                       |
     * | event-delivery | A guid to indentify the payload and event being sent |
     * | event-signature| The value of this header is computed as the HMAC SHA1 hex digest of the body, using the secret config option as the key. |
     *
     * scopes:
     * - admin:hooks
     * - write:hooks
     */
    post: operations["aid_source_hooks_post"];
  };
  "/accounts/{aid}/hooks/subscriptions/{hid}": {
    /**
     * Get subscription details
     *
     * scopes:
     * - admin:hooks
     * - read:hooks
     */
    get: operations["aid_source_hooks_hid_get"];
    /**
     * Delete a webhook subscription
     *
     * No more events will be sent to the webhook
     *
     * scopes:
     * - admin:hooks
     * - write:hooks
     */
    delete: operations["aid_source_hooks_hid_delete"];
  };
  "/accounts/{aid}/hooks/subscriptions/{hid}/deliveries": {
    /**
     * Get recent subscription deliveries
     *
     * scopes:
     * - admin:hooks
     * - read:hooks
     */
    get: operations["aid_source_hooks_hid_deliveries_get"];
  };
  "/accounts/{aid}/hooks/subscriptions/{hid}/deliveries/{delivery_id}": {
    /**
     * Get subscription delivery details
     *
     * scopes:
     * - admin:hooks
     * - read:hooks
     */
    get: operations["aid_source_hooks_hid_deliveries_did_get"];
  };
  "/accounts/{aid}/hooks/subscriptions/{hid}/ping": {
    /**
     * This will trigger a ping event to be sent to the subscription URL.
     *
     * ### Ping Event Payload
     *
     *       POST /
     *         User-Agent: Dintero-Hook/0c9ad03b
     *         Content-Type: application/json
     *         event: ping
     *         event-delivery: cfedde7e-b088-415e-ad5b-cbe54acbb6f9
     *
     *         {
     *           "created_at": "2017-12-06T15:36:43Z",
     *           "created_by": "1c92f7e1-2897-4d46-bdcc-c127a914fb4e",
     *           "id": "string",
     *           "updated_at": "2017-12-06T15:36:43Z",
     *           "active": true,
     *           "config": {
     *             "content_type": "application/json",
     *             "insecure_ssl": 0,
     *             "secret": { ... }
     *             "url": "string"
     *           },
     *           "events": ["receipt_add"]
     *         }
     * scopes:
     * - admin:hooks
     * - write:hooks
     */
    post: operations["aid_source_hooks_hid_ping_post"];
  };
  "/examples/approval_payout_destination_update": {
    /**
     * Event is pushed to subscribers when the `case_status`
     * of a seller approval changes
     */
    post: operations["example_approval_payout_destination_update_event"];
  };
  "/examples/approval_payout_destination_delete": {
    /** Event is pushed to subscribers when the approval is archived */
    post: operations["example_approval_payout_destination_update_delete"];
  };
  "/examples/checkout_transaction": {
    /**
     * Event is pushed to subscribers when the checkout transaction is created or
     * updated
     */
    post: operations["example_checkout_transaction_event"];
  };
}

export interface definitions {
  /** @description Sign all request  with AWS Signature Version 4. */
  "AWS4-HMAC-SHA256": definitions["Secret"] & {
    /**
     * @description AWS access key
     * @example AKIAIOSFODNN7EXAMPLE
     */
    aws_access_key_id: string;
    /**
     * @description AWS secret key
     * @example wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
     */
    aws_secret_access_key: string;
    /** @example eu-west-1 */
    region: string;
    /** @example execute-api */
    service: string;
  };
  /** @description Include Authorization header on all request */
  Authorization: definitions["Secret"] & {
    /** @example Bearer <token> */
    value: string;
  };
  /** @description Sign all request with HMAC SHA1, signature added to `event-signature` header. */
  "HMAC-SHA1": definitions["Secret"] & {
    /**
     * @description Use the value to compute HMAC SHA1 hex digest of
     * the body and pass it with the HTTP request as
     * an `event-signatur` header.
     */
    value: string;
  };
  Entity: {
    /**
     * Format: uuid
     * @description An UUID that uniquely identifies the resource
     */
    id?: string;
    /**
     * Format: date-time
     * @description The date-time when the resource was created
     */
    created_at?: string;
    /**
     * @description The ID of the user/client created the resource
     *
     * @example 1c92f7e1-2897-4d46-bdcc-c127a914fb4e
     */
    created_by?: string;
    /**
     * Format: date-time
     * @description The date-time when the resource was last updated
     */
    updated_at?: string;
    /**
     * @description The ID of the user/client created the resource
     *
     * @example 1c92f7e1-2897-4d46-bdcc-c127a914fb4e
     */
    deleted_by?: string;
    /** Format: date-time */
    deleted_at?: string;
  };
  Secret: {
    /** @enum {string} */
    type: "HMAC-SHA1" | "AWS4-HMAC-SHA256" | "Authorization";
  };
  /** @description Configuration for a webhook */
  Hook: definitions["Entity"] & {
    /**
     * @description Determines whether the hook is actually triggered.
     *
     * @default true
     */
    active?: boolean;
    config: {
      /**
       * @description A required string defining the URL to which
       * the payloads will be delivered.
       *
       * The URL must be public available and you cannot use the
       * following as value:
       *
       *   - localhost
       *   - "fake" domains like www.example.com
       *   - Dintero domains (i.e. dintero.com)
       */
      url: string;
      /**
       * @default application/json
       * @enum {string}
       */
      content_type?: "application/json";
      secret?: definitions["Secret"];
      /**
       * @description An optional string that determines whether the
       * SSLcertificate of the host for url will be
       * verified when delivering payloads. Supported
       * values include `"0"` (verification is performed)
       * and `"1"` (verification is not performed).
       * The default is `"0"`.
       *
       * @default 0
       */
      insecure_ssl?: number;
    };
    /**
     * Format: field-mask
     * @description Limit the event data included in the delivery
     *
     * The syntax is loosely based on XPath:
     * - a,b,c comma-separated list will select multiple fields
     * - a/b/c path will select a field from its parent
     * - a(b,c) sub-selection will select many fields from a parent
     * - a/*\/c the star * wildcard will select all items in a field
     *
     * @example account(partner_id,account_id,created_at)
     */
    fields?: string;
    events: (
      | "account_add"
      | "account_update"
      | "receipt_add"
      | "receipt_update"
      | "customer_add"
      | "customer_update"
      | "customer_delete"
      | "customer_change_password"
      | "token_add"
      | "token_remove"
      | "transaction"
      | "wallet_transaction"
      | "discount_add"
      | "discount_update"
      | "discount_delete"
      | "discount_add_customers"
      | "discount_customer_update"
      | "shopping_draft_add"
      | "shopping_draft_update"
      | "shopping_draft_complete"
      | "shopping_order_update"
      | "shopping_order_event_add"
      | "shopping_order_delete"
      | "settlement_add"
      | "location_add"
      | "location_delete"
      | "location_update"
      | "cdd_case_update"
      | "approval_payout_destination_update"
      | "approval_payout_destination_delete"
      | "checkout_transaction"
    )[];
  };
  Error: {
    error: {
      /** @description The code used to identify the error/warning */
      code?: string;
      /** @description The nested error(s) encountered during validation */
      errors?: { [key: string]: unknown }[];
      /** @description The human readable description of the error/warning */
      message: string;
    };
  };
  HookDelivery: {
    id?: string;
    event_delivery?: string;
    /** Format: date-time */
    created_at?: string;
    /**
     * @description HTTP status code
     *
     * @example 200
     */
    status?: number;
  };
  HookDeliveryDetail: definitions["HookDelivery"] & {
    /** @description The payload URL */
    url?: string;
    request?: {
      headers?: {
        event?: string;
        "event-delivery"?: string;
        "event-signature"?: string;
      };
      body?: { [key: string]: unknown };
    };
    response?: {
      headers?: { [key: string]: unknown };
      body?: string;
    };
    details?: {
      /** Format: date-time */
      delivery_at?: string;
      /** @example 848 */
      delivery_duration?: number;
      /** @example true */
      delivery_success?: boolean;
    };
  };
  ApprovalPayoutDestinationUpdateEvent: {
    /** @example P12345678 */
    account_id: string;
    /**
     * @example approval_payout_destination_update
     * @enum {string}
     */
    event: "approval_payout_destination_update";
    /**
     * Format: uuid
     * @example 9ebb6d41-dca5-484e-8330-9c9fa96b60ba
     */
    event_delivery: string;
    /** @description The seller approval case that was updated */
    payout_destination_case: {
      /**
       * Format: uuid
       * @example 497f6eca-6276-4993-bfeb-53cbbbba6f08
       */
      id: string;
      /** Format: date-time */
      created_at: string;
      created_by?: string;
      /** Format: date-time */
      updated_at: string;
      payout_destination_id: string;
      payout_destination_name?: string;
      payout_destination_description?: string;
      payout_reference: string;
      organization_number: string;
      /** @enum {undefined} */
      case_status:
        | "ACTIVE"
        | "DECLINED"
        | "UNDER_MANUAL_REVIEW"
        | "AUTOMATIC_REVIEW"
        | "WAITING_FOR_SIGNATURE"
        | "WAITING_FOR_DECLARATION"
        | "ERROR";
    };
  };
  ApprovalPayoutDestinationDeleteEvent: {
    /** @example P12345678 */
    account_id: string;
    /**
     * @example approval_payout_destination_delete
     * @enum {string}
     */
    event: "approval_payout_destination_delete";
    /**
     * Format: uuid
     * @example 9ebb6d41-dca5-484e-8330-9c9fa96b60ba
     */
    event_delivery: string;
    /** @description The seller approval case that was deleted */
    payout_destination_case: {
      /**
       * Format: uuid
       * @example 497f6eca-6276-4993-bfeb-53cbbbba6f08
       */
      id: string;
      /** Format: date-time */
      created_at: string;
      created_by?: string;
      /** Format: date-time */
      updated_at: string;
      /** Format: date-time */
      deleted_at?: string;
      deleted_by?: string;
      payout_destination_id: string;
      payout_destination_name?: string;
      payout_destination_description?: string;
      payout_reference: string;
      organization_number: string;
      /** @enum {undefined} */
      case_status: "ARCHIVED";
    };
  };
  CheckoutTransactionEvent: {
    /** @example P12345678 */
    account_id: string;
    /**
     * @example checkout_transaction
     * @enum {string}
     */
    event: "checkout_transaction";
    /**
     * Format: uuid
     * @example 9ebb6d41-dca5-484e-8330-9c9fa96b60ba
     */
    event_delivery: string;
    /** @description The transaction details, see Checkout API https://docs.dintero.com/checkout-api.html#operation/transactions_id_get for complete description of all properties that can be included in the transaction object */
    transaction: {
      /** @example P12345678.465UfBENeLpkBvwmqfTC4k */
      id: string;
      /**
       * @description The session id for the transaction
       * @example P12345678.465U8CUzaPVpneu1wt8Wei
       */
      session_id: string;
      /** @description A reference specified by the merchant to identify the transaction */
      merchant_reference: string;
      /** Format: date-time */
      created_at: string;
      /** Format: date-time */
      updated_at: string;
      /**
       * @description A reference specified by the merchant to identify the transaction,
       * can be updated after the transaction has been created
       */
      merchant_reference_2?: string;
    };
  };
}

export interface parameters {
  /**
   * Format: ^[PT]{1}\d{8}$
   * @description An id that uniquely identifies the account.
   */
  accountId: string;
  /**
   * @description A limit on the number of objects to be returned. Limit can range
   * between 1 and 100 items, and the default is 10 items.
   *
   * @default 10
   */
  limit: number;
  /**
   * @description cursor for use in pagination. starting_after is an object ID
   * that defines your place in the list. For instance, if you make
   * a list request and receive 100 objects, end the result contains
   *   `paging_token=pt1`, your subsequent call can include
   * `starting_after=pt1` in order to fetch the next page of the list.
   */
  startingAfter: string;
  /**
   * @description include `total-count` header in the response
   *
   * @default false
   */
  total: boolean;
  /**
   * Format: uuid
   * @description subscription id
   */
  subscriptionId: string;
}

export interface responses {
  /** Access forbidden, invalid JWT token was used */
  AccessForbidden: {
    schema: definitions["Error"];
  };
  /** Forbidden */
  Forbidden: {
    schema: definitions["Error"];
  };
  /** Unexpected Error */
  ServerError: {
    schema: definitions["Error"];
  };
  /** Bad / Invalid request */
  BadRequest: {
    schema: definitions["Error"];
  };
  /** Resource was not found */
  NotFound: {
    schema: definitions["Error"];
  };
}

export interface operations {
  /**
   * Get all subscriptions
   *
   * scopes:
   * - admin:hooks
   * - read:hooks
   */
  aid_source_hooks_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      query: {
        /** include deleted subscriptions in the response. */
        include_deleted?: boolean;
        /**
         * A limit on the number of objects to be returned. Limit can range
         * between 1 and 100 items, and the default is 10 items.
         */
        limit?: parameters["limit"];
        /**
         * cursor for use in pagination. starting_after is an object ID
         * that defines your place in the list. For instance, if you make
         * a list request and receive 100 objects, end the result contains
         *   `paging_token=pt1`, your subsequent call can include
         * `starting_after=pt1` in order to fetch the next page of the list.
         */
        starting_after?: parameters["startingAfter"];
        /** include `total-count` header in the response */
        total?: parameters["total"];
      };
    };
    responses: {
      /** Subscriptions */
      200: {
        headers: {};
        schema: definitions["Hook"][];
      };
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * When you create a new webhook, we'll send you a simple ping event to
   * let you know you've set up the webhook correctly.
   * You can trigger a ping again by calling the
   * [ping endpoint](#operation/aid_source_hooks_hid_ping_post).
   *
   * ## Receiving Webhooks
   *
   * In order for Dintero to send webhook payloads, your server needs to be
   * accessible from the Internet. We also highly suggest using SSL
   * so that we can send encrypted payloads over HTTPS.
   *
   * ## Respond to a webhook
   *
   * Your webhook acknowledges that it received data by sending a 200 OK
   * response. Any response outside of the 200 range will let Dintero
   * know that you did not receive your webhook, including 301 Redirect.
   * Dintero does not follow redirects for webhook notifications and will
   * consider a redirection as an error response.
   *
   * Dintero has implemented a 60-second timeout period and a retry
   * period for subscriptions. We wait 120 seconds for a response to
   * each request, and if there isn't one or we get an error, we retry
   * the connection to a total of 5 times.
   * A webhook will be deleted if there are consecutive failures for the
   * exact same webhook. You should monitor the admin of your webhook
   * tool for failing webhooks.
   *
   * ### Webhooks Headers
   *
   * Dintero will send along several HTTP headers to differentiate between
   * event types and payload identifiers.
   *
   * | Name           | Description                                          |
   * |----------------|------------------------------------------------------|
   * | event          | The event type                                       |
   * | event-delivery | A guid to indentify the payload and event being sent |
   * | event-signature| The value of this header is computed as the HMAC SHA1 hex digest of the body, using the secret config option as the key. |
   *
   * scopes:
   * - admin:hooks
   * - write:hooks
   */
  aid_source_hooks_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
      };
      body: {
        /** subscription configuration */
        data: definitions["Hook"];
      };
    };
    responses: {
      /** Subscription created */
      200: {
        schema: definitions["Hook"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get subscription details
   *
   * scopes:
   * - admin:hooks
   * - read:hooks
   */
  aid_source_hooks_hid_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** subscription id */
        hid: parameters["subscriptionId"];
      };
    };
    responses: {
      /** Subscription */
      200: {
        schema: definitions["Hook"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Delete a webhook subscription
   *
   * No more events will be sent to the webhook
   *
   * scopes:
   * - admin:hooks
   * - write:hooks
   */
  aid_source_hooks_hid_delete: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** subscription id */
        hid: parameters["subscriptionId"];
      };
    };
    responses: {
      /** Subscription deleted */
      200: {
        schema: definitions["Hook"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get recent subscription deliveries
   *
   * scopes:
   * - admin:hooks
   * - read:hooks
   */
  aid_source_hooks_hid_deliveries_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** subscription id */
        hid: parameters["subscriptionId"];
      };
    };
    responses: {
      /** Deliveries Collection */
      200: {
        schema: definitions["HookDelivery"][];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Get subscription delivery details
   *
   * scopes:
   * - admin:hooks
   * - read:hooks
   */
  aid_source_hooks_hid_deliveries_did_get: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** subscription id */
        hid: parameters["subscriptionId"];
        /** delivery id */
        delivery_id: string;
      };
    };
    responses: {
      /** Deliveries */
      200: {
        schema: definitions["HookDeliveryDetail"];
      };
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * This will trigger a ping event to be sent to the subscription URL.
   *
   * ### Ping Event Payload
   *
   *       POST /
   *         User-Agent: Dintero-Hook/0c9ad03b
   *         Content-Type: application/json
   *         event: ping
   *         event-delivery: cfedde7e-b088-415e-ad5b-cbe54acbb6f9
   *
   *         {
   *           "created_at": "2017-12-06T15:36:43Z",
   *           "created_by": "1c92f7e1-2897-4d46-bdcc-c127a914fb4e",
   *           "id": "string",
   *           "updated_at": "2017-12-06T15:36:43Z",
   *           "active": true,
   *           "config": {
   *             "content_type": "application/json",
   *             "insecure_ssl": 0,
   *             "secret": { ... }
   *             "url": "string"
   *           },
   *           "events": ["receipt_add"]
   *         }
   * scopes:
   * - admin:hooks
   * - write:hooks
   */
  aid_source_hooks_hid_ping_post: {
    parameters: {
      path: {
        /** An id that uniquely identifies the account. */
        aid: parameters["accountId"];
        /** subscription id */
        hid: parameters["subscriptionId"];
      };
    };
    responses: {
      /** No Content */
      204: never;
      400: responses["BadRequest"];
      401: responses["AccessForbidden"];
      403: responses["Forbidden"];
      404: responses["NotFound"];
      500: responses["ServerError"];
    };
  };
  /**
   * Event is pushed to subscribers when the `case_status`
   * of a seller approval changes
   */
  example_approval_payout_destination_update_event: {
    parameters: {
      header: {
        event: string;
        "event-delivery": string;
        "event-signature"?: string;
        "content-type": string;
      };
      body: {
        event: definitions["ApprovalPayoutDestinationUpdateEvent"];
      };
    };
    responses: {
      /** event handled */
      200: unknown;
      /** ignored, stop resend */
      400: unknown;
      /** unhandled, resend */
      500: unknown;
    };
  };
  /** Event is pushed to subscribers when the approval is archived */
  example_approval_payout_destination_update_delete: {
    parameters: {
      header: {
        event: string;
        "event-delivery": string;
        "event-signature"?: string;
        "content-type": string;
      };
      body: {
        event: definitions["ApprovalPayoutDestinationDeleteEvent"];
      };
    };
    responses: {
      /** event handled */
      200: unknown;
      /** ignored, stop resend */
      400: unknown;
      /** unhandled, resend */
      500: unknown;
    };
  };
  /**
   * Event is pushed to subscribers when the checkout transaction is created or
   * updated
   */
  example_checkout_transaction_event: {
    parameters: {
      header: {
        event: string;
        "event-delivery": string;
        "event-signature"?: string;
        "content-type": string;
      };
      body: {
        event: definitions["CheckoutTransactionEvent"];
      };
    };
    responses: {
      /** event handled */
      200: unknown;
      /** ignored, stop resend */
      400: unknown;
      /** unhandled, resend */
      500: unknown;
    };
  };
}

export interface external {}
